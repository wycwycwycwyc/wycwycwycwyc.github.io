<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D第一视角贪吃蛇大作战</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #0a0a2a, #1a1a3a);
            color: white;
            overflow: hidden;
            height: 100vh;
        }

        #game-container {
            width: 100%;
            height: 100vh;
            position: relative;
        }

        /* 分屏容器 */
        .split-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
        }

        .split-left {
            width: 50%;
            height: 100%;
            overflow: hidden;
            position: relative;
            border-right: 2px solid rgba(255, 255, 255, 0.3);
        }

        .split-right {
            width: 50%;
            height: 100%;
            overflow: hidden;
            position: relative;
        }

        .player-viewport {
            width: 100%;
            height: 100%;
            position: relative;
            /* 移除或调整背景色 */
            background: rgba(0, 0, 0, 0.3);
            /* 半透明黑色，让视野更清晰 */
        }

        .player-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* UI覆盖层 */
        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }

        /* 玩家信息面板 */
        .player-panel {
            position: absolute;
            top: 10px;
            width: 250px;
            background: rgba(0, 0, 0, 0.8);
            padding: 12px;
            border-radius: 8px;
            border: 2px solid;
            pointer-events: auto;
            font-size: 0.9rem;
        }

        #player1-panel {
            left: 10px;
            border-color: #FF7F00;
        }

        #player2-panel {
            right: 10px;
            border-color: #4169E1;
        }

        .player-header {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }

        .snake-type {
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: bold;
            margin-left: 8px;
            font-size: 0.8rem;
        }

        .speed-snake {
            background: #FFA500;
            color: #000;
        }

        .hard-snake {
            background: #C0C0C0;
            color: #000;
        }

        .magic-snake {
            background: #9370DB;
            color: #000;
        }

        .health-bar {
            width: 100%;
            height: 16px;
            background: #333;
            border-radius: 8px;
            overflow: hidden;
            margin: 4px 0;
        }

        .health-fill {
            height: 100%;
            transition: width 0.3s;
        }

        #player1-health {
            background: linear-gradient(to right, #FF4444, #FF7F00);
        }

        #player2-health {
            background: linear-gradient(to right, #4444FF, #4169E1);
        }

        .magic-balls {
            display: flex;
            gap: 4px;
            margin: 8px 0;
        }

        .ball-slot {
            width: 26px;
            height: 26px;
            border-radius: 50%;
            border: 2px solid #555;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            cursor: pointer;
            pointer-events: auto;
        }

        .invincible {
            background: #FFFF00;
            color: #000;
        }

        .health {
            background: #FF0000;
            color: #FFF;
        }

        .reverse {
            background: #800080;
            color: #FFF;
        }

        .attack {
            background: #87CEEB;
            color: #000;
        }

        .bomb {
            background: #FF8C00;
            color: #000;
        }

        /* 游戏控制按钮 */
        .game-controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 12px;
            pointer-events: auto;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 8px;
        }

        button {
            background: linear-gradient(to bottom, #4444FF, #2222AA);
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 0.9rem;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
            pointer-events: auto;
        }

        button:hover {
            background: linear-gradient(to bottom, #5555FF, #3333BB);
            transform: translateY(-2px);
        }

        #start-btn {
            background: linear-gradient(to bottom, #00AA00, #008800);
        }

        #start-btn:hover {
            background: linear-gradient(to bottom, #00CC00, #00AA00);
        }

        /* 商店界面 */
        .shop-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            z-index: 200;
            pointer-events: auto;
            background: transparent !important; /* 完全透明背景 */
        }
        #shop1-overlay {
            justify-content: flex-start; /* 左对齐 */
        }

        #shop2-overlay {
            justify-content: flex-end; /* 右对齐 */
        }
        .shop-content {
            background: transparent !important; /* 透明背景 */
            padding: 0 !important;
            border: none !important;
            box-shadow: none !important;
            width: 30% !important; /* 只占屏幕30%宽度 */
            height: 100%;
            max-width: none !important;
        }
        #shop1-overlay .shop-content {
            margin-left: 0;
            align-items: flex-start;
        }

        #shop2-overlay .shop-content {
            margin-right: 0;
            align-items: flex-end;
        }
        .shop-title {
            text-align: center;
            font-size: 1.8rem;
            color: #FFD700;
            margin-bottom: 15px;
        }

        .shop-items {
            display: flex !important;
            flex-direction: column !important; /* 竖向排列 */
            gap: 15px !important;
            padding: 20px;
            background: rgba(0, 0, 0, 0.85); /* 商店内容有背景，但覆盖层透明 */
            border-radius: 10px;
            margin: 20px;
            width: 80%;
            max-width: 300px;
        }
        #shop1-overlay .shop-items {
            border: 3px solid #FF7F00; /* 玩家1颜色边框 */
            background: rgba(0, 0, 0, 0.9);
        }

        #shop2-overlay .shop-items {
            border: 3px solid #4169E1; /* 玩家2颜色边框 */
            background: rgba(0, 0, 0, 0.9);
        }
        .shop-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 12px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
            border: 2px solid transparent;
        }

        .shop-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            border: 2px solid transparent;
            display: flex;
            flex-direction: column;
            gap: 5px;
            position: relative;
        }

        .shop-item:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        .shop-item.selected {
            border-color: #FFD700;
            background: rgba(255, 215, 0, 0.2);
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
        }
        .shop-item.selected::before {
            content: '▶';
            position: absolute;
            left: -25px;
            top: 50%;
            transform: translateY(-50%);
            color: #FFD700;
            font-size: 1.5rem;
            text-shadow: 0 0 5px rgba(255, 215, 0, 0.8);
            animation: pulse 1s infinite;
        }

        /* 添加闪烁动画 */
        @keyframes pulse {
            0% { opacity: 0.5; transform: translateY(-50%) scale(1); }
            50% { opacity: 1; transform: translateY(-50%) scale(1.2); }
            100% { opacity: 0.5; transform: translateY(-50%) scale(1); }
        }
        .shop-item.selected .item-price {
            color: #FFFFFF;
            font-weight: bold;
            background: rgba(255, 215, 0, 0.3);
            padding: 2px 8px;
            border-radius: 4px;
            display: inline-block;
        }

        /* 选中的项目名称高亮 */
        .shop-item.selected .item-name {
            color: #FFFFFF;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.8);
        }
        .item-name {
            font-size: 1.1rem;
            color: #FFD700;
            margin-bottom: 4px;
        }

        .item-price {
            color: #87CEEB;
            font-weight: bold;
            font-size: 0.9rem;
        }
        .shop-hint {
            text-align: center;
            margin-top: 10px;
            color: #AAAAAA;
            font-size: 0.8rem;
        }
        /* 游戏结束界面 */
        .game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
            pointer-events: auto;
        }

        #winner-text {
            font-size: 2.5rem;
            margin-bottom: 15px;
            text-shadow: 0 0 10px currentColor;
        }

        .stats-container {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            width: 70%;
            max-width: 450px;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            margin: 8px 0;
        }

        .key-hint {
            display: inline-block;
            background-color: #333;
            color: white;
            padding: 4px 8px;
            margin: 0 2px;
            border-radius: 4px;
            font-family: monospace;
            border: 1px solid #666;
        }

        /* 分数显示 */
        .score-display {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 1.2rem;
            color: #FFD700;
            background: rgba(0, 0, 0, 0.8);
            padding: 8px 15px;
            border-radius: 6px;
        }

        /* 基地信息 */
        .base-info {
            position: absolute;
            bottom: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 8px;
            border-radius: 6px;
            min-width: 130px;
            font-size: 0.9rem;
        }

        #player1-base {
            left: 10px;
            border: 2px solid #FF7F00;
        }

        #player2-base {
            right: 10px;
            border: 2px solid #4169E1;
        }

        .base-health {
            height: 8px;
            background: #333;
            border-radius: 4px;
            overflow: hidden;
            margin: 4px 0;
        }

        .base-health-fill {
            height: 100%;
            background: #00FF00;
        }

        /* 第一视角准星 */
        .crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
        }

        .crosshair::before,
        .crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.8);
        }

        .crosshair::before {
            width: 2px;
            height: 20px;
            top: 0;
            left: 9px;
        }

        .crosshair::after {
            width: 20px;
            height: 2px;
            top: 9px;
            left: 0;
        }

        .p1-crosshair {
            position: absolute;
            top: 50%;
            left: 25%;
            transform: translate(-50%, -50%);
        }

        .p2-crosshair {
            position: absolute;
            top: 50%;
            left: 75%;
            transform: translate(-50%, -50%);
        }

        /* 第一视角镜头晃动效果 */

        @keyframes shake {
            0% {
                transform: translate(0, 0);
            }

            25% {
                transform: translate(-2px, 2px);
            }

            50% {
                transform: translate(2px, -2px);
            }

            75% {
                transform: translate(-2px, -2px);
            }

            100% {
                transform: translate(0, 0);
            }
        }

        /* 受伤效果 */
        .damage-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 0, 0, 0.3);
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }

        .p1-damage {
            left: 0;
            width: 50%;
        }

        .p2-damage {
            left: 50%;
            width: 50%;
        }

        .selection-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0a0a2a, #1a1a3a);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 300;
        }

        .selection-content {
            background: rgba(0, 0, 0, 0.8);
            padding: 30px;
            border-radius: 15px;
            width: 90%;
            max-width: 1200px;
            max-height: 90vh;
            overflow-y: auto;
            border: 3px solid #FFD700;
        }

        .player-selection,
        .map-selection {
            margin-bottom: 30px;
        }

        .player-selection h3,
        .map-selection h3 {
            color: #FFD700;
            margin-bottom: 15px;
            text-align: center;
            font-size: 1.8rem;
        }

        .snake-options,
        .map-options {
            display: flex;
            justify-content: center;
            gap: 20px;
            flex-wrap: wrap;
        }

        .snake-option,
        .map-option {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
            width: 200px;
            cursor: pointer;
            transition: all 0.3s;
            border: 2px solid transparent;
        }

        .snake-option:hover,
        .map-option:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-5px);
        }

        .snake-option.active,
        .map-option.active {
            border-color: #FFD700;
            background: rgba(255, 215, 0, 0.1);
        }

        .snake-preview {
            width: 100%;
            height: 60px;
            border-radius: 8px;
            margin-bottom: 10px;
        }

        .map-preview {
            width: 100%;
            height: 100px;
            border-radius: 8px;
            margin-bottom: 10px;
        }

        .classic-map {
            background: linear-gradient(135deg, #2E7D32, #388E3C);
        }

        .snow-map {
            background: linear-gradient(135deg, #87CEEB, #FFFFFF);
        }

        .volcano-map {
            background: linear-gradient(135deg, #FF4500, #8B4513);
        }

        .snake-option h4,
        .map-option h4 {
            color: #FFD700;
            margin-bottom: 8px;
        }

        .snake-option p,
        .map-option p {
            font-size: 0.9rem;
            margin: 3px 0;
            color: #CCCCCC;
        }

        .start-game-section {
            text-align: center;
            margin-top: 30px;
        }

        #confirm-start-btn {
            background: linear-gradient(to bottom, #00AA00, #008800);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 1.2rem;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
        }

        #confirm-start-btn:hover {
            background: linear-gradient(to bottom, #00CC00, #00AA00);
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0, 255, 0, 0.4);
        }

        /* 全屏游戏时的简化UI */
        .game-fullscreen .player-panel {
            background: rgba(0, 0, 0, 0.6);
            padding: 8px;
            border-radius: 5px;
            width: 180px;
            font-size: 0.8rem;
        }

        .game-fullscreen .player-header {
            font-size: 0.9rem;
            margin-bottom: 5px;
        }

        .game-fullscreen .health-bar {
            height: 12px;
            margin: 3px 0;
        }

        .game-fullscreen .magic-balls {
            gap: 2px;
        }

        .game-fullscreen .ball-slot {
            width: 22px;
            height: 22px;
            font-size: 0.7rem;
        }

        .game-fullscreen .score-display {
            font-size: 1rem;
            padding: 6px 12px;
        }

        .game-fullscreen .base-info {
            padding: 6px;
            min-width: 120px;
            font-size: 0.8rem;
        }
        .game-fullscreen .game-controls {
            opacity: 0.3;
            transition: opacity 0.3s;
        }

        .game-fullscreen .game-controls:hover {
            opacity: 1;
        }
    </style>
</head>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<body>
    <div class="selection-overlay" id="selection-overlay">
        <div class="selection-content">
            <!-- 玩家1选择 -->
            <div class="player-selection">
                <h3>玩家1选择蛇类型</h3>
                <div class="snake-options">
                    <div class="snake-option active" data-type="speed" onclick="selectSnakeType('player1', 'speed')">
                        <div class="snake-preview" style="background: #FFA500;"></div>
                        <h4>速度蛇</h4>
                        <p>生命: ★★★☆☆</p>
                        <p>速度: ★★★★★</p>
                        <p>特点: 双击方向键俯冲加速</p>
                    </div>
                    <div class="snake-option" data-type="hard" onclick="selectSnakeType('player1', 'hard')">
                        <div class="snake-preview" style="background: #C0C0C0;"></div>
                        <h4>坚硬蛇</h4>
                        <p>生命: ★★★★★</p>
                        <p>速度: ★★☆☆☆</p>
                        <p>特点: 伤害减半，50%子弹免疫</p>
                    </div>
                    <div class="snake-option" data-type="magic" onclick="selectSnakeType('player1', 'magic')">
                        <div class="snake-preview" style="background: #9370DB;"></div>
                        <h4>魔法蛇</h4>
                        <p>生命: ★★★☆☆</p>
                        <p>速度: ★★★☆☆</p>
                        <p>特点: 效果时间延长，自动生成魔法球</p>
                    </div>
                </div>
            </div>

            <!-- 玩家2选择 -->
            <div class="player-selection">
                <h3>玩家2选择蛇类型</h3>
                <div class="snake-options">
                    <div class="snake-option active" data-type="speed" onclick="selectSnakeType('player2', 'speed')">
                        <div class="snake-preview" style="background: #4169E1;"></div>
                        <h4>速度蛇</h4>
                        <p>生命: ★★★☆☆</p>
                        <p>速度: ★★★★★</p>
                        <p>特点: 双击方向键俯冲加速</p>
                    </div>
                    <div class="snake-option" data-type="hard" onclick="selectSnakeType('player2', 'hard')">
                        <div class="snake-preview" style="background: #C0C0C0;"></div>
                        <h4>坚硬蛇</h4>
                        <p>生命: ★★★★★</p>
                        <p>速度: ★★☆☆☆</p>
                        <p>特点: 伤害减半，50%子弹免疫</p>
                    </div>
                    <div class="snake-option" data-type="magic" onclick="selectSnakeType('player2', 'magic')">
                        <div class="snake-preview" style="background: #9370DB;"></div>
                        <h4>魔法蛇</h4>
                        <p>生命: ★★★☆☆</p>
                        <p>速度: ★★★☆☆</p>
                        <p>特点: 效果时间延长，自动生成魔法球</p>
                    </div>
                </div>
            </div>

            <!-- 地图选择 -->
            <div class="map-selection">
                <h3>选择地图类型</h3>
                <div class="map-options">
                    <div class="map-option active" data-map="classic" onclick="selectMapType('classic')">
                        <div class="map-preview classic-map"></div>
                        <h4>经典地图</h4>
                        <p>标准对战地图，随机墙壁</p>
                    </div>
                    <div class="map-option" data-map="snow" onclick="selectMapType('snow')">
                        <div class="map-preview snow-map"></div>
                        <h4>雪山地图</h4>
                        <p>暴风雪机制，减速冻结效果</p>
                    </div>
                    <div class="map-option" data-map="volcano" onclick="selectMapType('volcano')">
                        <div class="map-preview volcano-map"></div>
                        <h4>火山地图</h4>
                        <p>火山喷发，岩浆区域伤害</p>
                    </div>
                </div>
            </div>

            <!-- 开始游戏按钮 -->
            <div class="start-game-section">
                <button id="confirm-start-btn" onclick="startGameWithSelections()">开始游戏</button>
            </div>
        </div>
    </div>
    <div id="game-container">
        <!-- 分屏第一视角 -->
        <div class="split-screen">
            <div class="split-left">
                <div class="player-viewport" id="player1-viewport">
                    <canvas class="player-canvas" id="player1-canvas"></canvas>
                    <!-- 玩家1受伤效果 -->
                    <div class="damage-overlay p1-damage" id="p1-damage"></div>
                </div>
            </div>
            <div class="split-right">
                <div class="player-viewport" id="player2-viewport">
                    <canvas class="player-canvas" id="player2-canvas"></canvas>
                    <!-- 玩家2受伤效果 -->
                    <div class="damage-overlay p2-damage" id="p2-damage"></div>
                </div>
            </div>
        </div>

        <!-- UI覆盖层 -->
        <div id="ui-overlay">
            <!-- 玩家1面板 -->
            <div class="player-panel" id="player1-panel">
                <div class="player-header">
                    <span>玩家1</span>
                    <span class="snake-type speed-snake" id="player1-type">速度蛇</span>
                </div>
                <div>生命值: <span id="player1-hp">10</span>/<span id="player1-max-hp">10</span></div>
                <div class="health-bar">
                    <div class="health-fill" id="player1-health" style="width: 100%"></div>
                </div>
                    <div>魔法球:</div>
                    <div class="magic-balls" id="player1-balls"></div>
                <div>护盾: <span id="player1-shield">0</span></div>
                <div>分数: <span id="player1-score">0</span></div>
            </div>

            <!-- 玩家2面板 -->
            <div class="player-panel" id="player2-panel">
                <div class="player-header">
                    <span>玩家2</span>
                    <span class="snake-type magic-snake" id="player2-type">魔法蛇</span>
                </div>
                <div>生命值: <span id="player2-hp">10</span>/<span id="player2-max-hp">10</span></div>
                <div class="health-bar">
                    <div class="health-fill" id="player2-health" style="width: 100%"></div>
                </div>
                    <div>魔法球:</div>
                    <div class="magic-balls" id="player2-balls"></div>
                <div>护盾: <span id="player2-shield">0</span></div>
                <div>分数: <span id="player2-score">0</span></div>
            </div>

            <!-- 分数显示 -->
            <div class="score-display">
                游戏时间: <span id="game-time">00:00</span>
            </div>

            

            <!-- 游戏控制按钮 -->
            <div class="game-controls">
                <button id="start-btn">开始游戏</button>
                <button id="reset-btn">重新开始</button>
                <button id="map-btn">切换地图</button>
            </div>

            <!-- 玩家1商店界面 -->
            <div class="shop-overlay" id="shop1-overlay">
                <div class="shop-content">
                    <div class="shop-items">
                        <!-- 项目会通过JavaScript动态生成 -->
                    </div>
                </div>
            </div>

            <!-- 玩家2商店 -->
            <div class="shop-overlay" id="shop2-overlay">
                <div class="shop-content">
                    <div class="shop-items">
                        <!-- 项目会通过JavaScript动态生成 -->
                    </div>
                </div>
            </div>
            <div class="base-info" id="player1-base">
                <div>基地</div>
                <div>生命值: <span id="base1-hp">50</span></div>
                <div class="base-health">
                    <div class="base-health-fill" id="base1-health" style="width: 100%"></div>
                </div>
            </div>

            <div class="base-info" id="player2-base">
                <div>基地</div>
                <div>生命值: <span id="base2-hp">50</span></div>
                <div class="base-health">
                    <div class="base-health-fill" id="base2-health" style="width: 100%"></div>
                </div>
            </div>

            <!-- 游戏结束界面 -->
            <div class="game-over" id="game-over">
                <div id="winner-text">游戏结束</div>
                <div class="stats-container" id="stats-container">
                    <!-- 统计信息会动态生成 -->
                </div>
                <div class="game-controls">
                    <button id="play-again-btn">再玩一次</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // 游戏状态
        let gameState = {
            running: false,
            gameTime: 0,
            mapType: 'classic', // classic, snow, volcano
            player1: {
                snake: null,
                type: 'speed', // speed, hard, magic
                hp: 10,
                maxHp: 10,
                shield: 0,
                score: 0,
                magicBalls: [],
                status: 'normal', // normal, invincible, reversed, attacking
                statusTime: 0,
                speedMultiplier: 1,
                hardUpgrades: 0,
                magicUpgrades: 0,
                lastDashTime: 0,
                dashDuration: 0,
                isDashing: false,
                position: { x: -50, y: 1.5, z: 0 },
                direction: { x: 1, y: 0, z: 0 },
                targetDirection: { x: 1, y: 0, z: 0 }, // 用于平滑转向
                rotationAngle: 0, // 当前旋转角度
                segments: [],
                baseHp: 50,
                basePosition: { x: -80, y: 0, z: 0 },
                camera: null, // 第一视角相机
                renderer: null,// 玩家1的渲染器
                paused: false,
            },
            player2: {
                snake: null,
                type: 'speed',
                hp: 10,
                maxHp: 10,
                shield: 0,
                score: 0,
                magicBalls: [],
                status: 'normal',
                statusTime: 0,
                speedMultiplier: 1,
                hardUpgrades: 0,
                magicUpgrades: 0,
                lastMagicGenerateTime: 0,
                position: { x: 50, y: 1.5, z: 0 },
                direction: { x: -1, y: 0, z: 0 },
                targetDirection: { x: -1, y: 0, z: 0 }, // 用于平滑转向
                rotationAngle: Math.PI, // 当前旋转角度
                segments: [],
                baseHp: 50,
                basePosition: { x: 80, y: 0, z: 0 },
                camera: null, // 第一视角相机
                renderer: null, // 玩家2的渲染器
                paused: false,
            },
            magicBalls: [], // 地图上的魔法球
            food: [], // 食物
            walls: [], // 墙壁
            bullets: [], // 子弹
            explosions: [], // 爆炸效果
            volcanoes: [], // 火山
            stormDirection: null, // 暴风雪方向
            stormActive: false,
            stormWarning: false,
            keys: {},
            scene: null, // 共享场景
            selectionMode: true
        };
        let lastWallCollisionTime = {
            player1: 0,
            player2: 0
        };
        gameState.lastCollisionTime = {
                player1: 0,
                player2: 0
            };  
       gameState.player1.status = {
                        normal: true,
                        effects: [] // 确保 effects 数组存在
                    };

                    // 重置玩家2  
        gameState.player2.status = {
                        normal: true,
                        effects: [] // 确保 effects 数组存在
                    };
        let shopState = {
                player1: {
                    open: false,
                    selectedIndex: 0,
                    items: [
                        { id: 'shield', name: '能量护盾', desc: '获得10点护盾值', price: 400 },
                        { id: 'magic-pack', name: '魔法球礼包', desc: '获得3个随机魔法球', price: 400 },
                        { id: 'speed-upgrade', name: '速度升级', desc: '永久增加15%移动速度', price: 500 },
                        { id: 'hard-upgrade', name: '坚硬升级', desc: '永久增加2点生命上限', price: 500 },
                        { id: 'magic-upgrade', name: '魔法升级', desc: '延长20%效果时间', price: 500 }
                    ]
                },
                player2: {
                    open: false,
                    selectedIndex: 0,
                    items: [
                        { id: 'shield', name: '能量护盾', desc: '获得10点护盾值', price: 400 },
                        { id: 'magic-pack', name: '魔法球礼包', desc: '获得3个随机魔法球', price: 400 },
                        { id: 'speed-upgrade', name: '速度升级', desc: '永久增加15%移动速度', price: 500 },
                        { id: 'hard-upgrade', name: '坚硬升级', desc: '永久增加2点生命上限', price: 500 },
                        { id: 'magic-upgrade', name: '魔法升级', desc: '延长20%效果时间', price: 500 }
                    ]
                }
            };              
        let clock;
        // 游戏元素
        const gameTimeElement = document.getElementById('game-time');
        const player1HealthElement = document.getElementById('player1-hp');
        const player1MaxHealthElement = document.getElementById('player1-max-hp');
        const player1HealthBar = document.getElementById('player1-health');
        const player2HealthElement = document.getElementById('player2-hp');
        const player2MaxHealthElement = document.getElementById('player2-max-hp');
        const player2HealthBar = document.getElementById('player2-health');
        const player1ShieldElement = document.getElementById('player1-shield');
        const player2ShieldElement = document.getElementById('player2-shield');
        const player1ScoreElement = document.getElementById('player1-score');
        const player2ScoreElement = document.getElementById('player2-score');
        const player1BallsElement = document.getElementById('player1-balls');
        const player2BallsElement = document.getElementById('player2-balls');
        const base1HpElement = document.getElementById('base1-hp');
        const base2HpElement = document.getElementById('base2-hp');
        const base1HealthBar = document.getElementById('base1-health');
        const base2HealthBar = document.getElementById('base2-health');
        const p1DamageOverlay = document.getElementById('p1-damage');
        const p2DamageOverlay = document.getElementById('p2-damage');
        const startButton = document.getElementById('start-btn');
        const resetButton = document.getElementById('reset-btn');
        const mapButton = document.getElementById('map-btn');
        const shop1Overlay = document.getElementById('shop1-overlay');
        const shop2Overlay = document.getElementById('shop2-overlay');
        const gameOverScreen = document.getElementById('game-over');
        const winnerText = document.getElementById('winner-text');
        const statsContainer = document.getElementById('stats-container');
        const playAgainButton = document.getElementById('play-again-btn');
        function selectSnakeType(playerKey, type) {
            const player = gameState[playerKey];
            player.type = type;

            // 根据类型设置血量
            if (type === 'hard') {
                player.maxHp = 15;
                player.hp = 15;
            } else {
                player.maxHp = 10;
                player.hp = 10;
            }

            // 更新UI显示
            const options = document.querySelectorAll(`.player-selection:nth-child(${playerKey === 'player1' ? 1 : 2}) .snake-option`);
            options.forEach(option => {
                if (option.dataset.type === type) {
                    option.classList.add('active');
                } else {
                    option.classList.remove('active');
                }
            });

            // 更新预览颜色
            const previews = document.querySelectorAll(`.player-selection:nth-child(${playerKey === 'player1' ? 1 : 2}) .snake-preview`);
            previews.forEach((preview, index) => {
                const types = ['speed', 'hard', 'magic'];
                if (types[index] === type) {
                    if (playerKey === 'player1') {
                        preview.style.background = type === 'speed' ? '#FFA500' :
                            type === 'hard' ? '#C0C0C0' : '#9370DB';
                    } else {
                        preview.style.background = type === 'speed' ? '#4169E1' :
                            type === 'hard' ? '#C0C0C0' : '#9370DB';
                    }
                }
            });
        }

        // 选择地图类型
        function selectMapType(mapType) {
            gameState.mapType = mapType;

            // 更新UI显示
            const options = document.querySelectorAll('.map-option');
            options.forEach(option => {
                if (option.dataset.map === mapType) {
                    option.classList.add('active');
                } else {
                    option.classList.remove('active');
                }
            });
        }

        // 使用选择开始游戏
        function startGameWithSelections() {
            // 隐藏选择界面
            document.getElementById('selection-overlay').style.display = 'none';

            // 进入全屏游戏模式
            document.body.classList.add('game-fullscreen');

            // 隐藏不需要的UI元素
            hideUnnecessaryUI();

            // 初始化游戏
            initGame();

            // 开始游戏
            gameState.running = true;
            document.getElementById('start-btn').textContent = '游戏中';
            document.getElementById('start-btn').disabled = true;
            clock.start();
            startButton.style.display = 'none';
            // 设置选择模式为false
            gameState.selectionMode = false;
        }

        // 隐藏不必要的UI元素
        function hideUnnecessaryUI() {
            // 可以在这里选择性隐藏一些UI元素
            const elementsToHide = [
                '.game-controls button:not(#start-btn)' // 除了开始按钮的其他按钮
            ];

            elementsToHide.forEach(selector => {
                const elements = document.querySelectorAll(selector);
                elements.forEach(el => {
                    el.style.display = 'none';
                });
            });
        }

        // 重新开始游戏（返回选择界面）
        function resetToSelection() {
            if (gameState.running) {
                gameState.running = false;
            }

            // 显示选择界面
            document.getElementById('selection-overlay').style.display = 'flex';

            // 退出全屏模式
            document.body.classList.remove('game-fullscreen');

            // 恢复UI元素
            const elementsToShow = [
                '.game-controls button'
            ];

            elementsToShow.forEach(selector => {
                const elements = document.querySelectorAll(selector);
                elements.forEach(el => {
                    el.style.display = '';
                });
            });

            // 设置选择模式为true
            gameState.selectionMode = true;
        }

        // 修改reset按钮事件
        resetButton.addEventListener('click', resetToSelection);

        // 修改playAgain按钮事件
        playAgainButton.addEventListener('click', function () {
            // 游戏结束后返回选择界面
            resetToSelection();
        });

        // 初始化场景
        function initScene() {
            // 创建场景
            gameState.scene = new THREE.Scene();
            gameState.scene.fog = new THREE.Fog(0x87CEEB, 20, 200);
            clock = new THREE.Clock();
            // 创建相机
            gameState.player1.camera = new THREE.PerspectiveCamera(
                75,
                (window.innerWidth / 2) / window.innerHeight,
                1,
                300
            );

            gameState.player2.camera = new THREE.PerspectiveCamera(
                75,
                (window.innerWidth / 2) / window.innerHeight,
                1,
                300
            );

            // 创建渲染器
            gameState.player1.renderer = new THREE.WebGLRenderer({
                canvas: document.getElementById('player1-canvas'),
                antialias: true,
                alpha: true
            });
            gameState.player1.renderer.setSize(window.innerWidth / 2, window.innerHeight);

            gameState.player2.renderer = new THREE.WebGLRenderer({
                canvas: document.getElementById('player2-canvas'),
                antialias: true,
                alpha: true
            });
            gameState.player2.renderer.setSize(window.innerWidth / 2, window.innerHeight);

            // 创建灯光
            createLights();

            // 创建环境
            createEnvironment();

            // 显示选择界面
            document.getElementById('selection-overlay').style.display = 'flex';

            // 不初始化游戏，等待选择

            // 开始动画循环
            animate();
        }

        // 创建灯光
        function createLights() {
            // 环境光
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            gameState.scene.add(ambientLight);

            // 主方向光
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 100, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.left = -100;
            directionalLight.shadow.camera.right = 100;
            directionalLight.shadow.camera.top = 100;
            directionalLight.shadow.camera.bottom = -100;
            gameState.scene.add(directionalLight);

            // 补充灯光
            const fillLight = new THREE.DirectionalLight(0xffffff, 0.3);
            fillLight.position.set(-50, 50, -50);
            gameState.scene.add(fillLight);
        }

        // 创建环境
        function createEnvironment() {
            // 天空盒
            const skyGeometry = new THREE.SphereGeometry(500, 32, 32);
            const skyMaterial = new THREE.MeshBasicMaterial({
                color: 0x87CEEB,
                side: THREE.BackSide
            });
            const sky = new THREE.Mesh(skyGeometry, skyMaterial);
            gameState.scene.add(sky);

            // 创建地面
            createGround();
        }

        // 创建地面
        function createGround() {
            const groundSize = 300;
            const groundGeometry = new THREE.PlaneGeometry(groundSize, groundSize, 32, 32);

            // 创建网格地面纹理
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');

            // 绘制网格
            ctx.fillStyle = '#2E7D32'; // 绿色背景
            ctx.fillRect(0, 0, 512, 512);

            // 绘制网格线
            ctx.strokeStyle = '#388E3C';
            ctx.lineWidth = 2;

            // 水平线
            for (let i = 0; i <= 20; i++) {
                const y = i * 25.6;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(512, y);
                ctx.stroke();
            }

            // 垂直线
            for (let i = 0; i <= 20; i++) {
                const x = i * 25.6;
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, 512);
                ctx.stroke();
            }

            const groundTexture = new THREE.CanvasTexture(canvas);
            groundTexture.wrapS = THREE.RepeatWrapping;
            groundTexture.wrapT = THREE.RepeatWrapping;
            groundTexture.repeat.set(10, 10);

            const groundMaterial = new THREE.MeshStandardMaterial({
                map: groundTexture,
                roughness: 0.9
            });

            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            gameState.scene.add(ground);

            // 添加地图边界线
            createMapBoundaries();
        }

        // 创建地图边界线
        function createMapBoundaries() {
            const boundarySize = 100; // 边界大小
            const boundaryHeight = 0.2; // 边界线高度
            const boundaryColor = 0xFF0000; // 红色边界线

            // 创建边界线材质
            const boundaryMaterial = new THREE.LineBasicMaterial({
                color: boundaryColor,
                linewidth: 3
            });

            // 创建边界几何体
            const boundaryPoints = [];

            // 左上角
            boundaryPoints.push(new THREE.Vector3(-boundarySize, boundaryHeight, -boundarySize));
            // 右上角
            boundaryPoints.push(new THREE.Vector3(boundarySize, boundaryHeight, -boundarySize));
            // 右下角
            boundaryPoints.push(new THREE.Vector3(boundarySize, boundaryHeight, boundarySize));
            // 左下角
            boundaryPoints.push(new THREE.Vector3(-boundarySize, boundaryHeight, boundarySize));
            // 闭合回到左上角
            boundaryPoints.push(new THREE.Vector3(-boundarySize, boundaryHeight, -boundarySize));

            const boundaryGeometry = new THREE.BufferGeometry().setFromPoints(boundaryPoints);
            const boundaryLine = new THREE.Line(boundaryGeometry, boundaryMaterial);
            gameState.scene.add(boundaryLine);

        }

        // 初始化游戏
        function initGame() {
            // 清除场景
            clearScene();

            // 重置游戏状态
            resetGameState();

            // 根据地图类型创建环境
            createMapEnvironment();

            // 创建基地
            createBases();

            // 创建蛇
            createSnakes();

            // 生成食物
            generateFood();

            // 生成魔法球
            generateMagicBalls();

            // 更新相机初始位置
            updateCameras();

            // 更新UI
            updateUI();
            clock = new THREE.Clock();
            
            // 隐藏商店和游戏结束界面
            shop1Overlay.style.display = 'none';
            shop2Overlay.style.display = 'none';
            gameOverScreen.style.display = 'none';
        }

        // 清除场景
        function clearScene() {
            // 移除所有游戏对象
            const objectsToRemove = [];
            gameState.scene.children.forEach(child => {
                if (child.userData && child.userData.type) {
                    objectsToRemove.push(child);
                }
            });

            objectsToRemove.forEach(obj => gameState.scene.remove(obj));

            // 清空数组
            gameState.magicBalls = [];
            gameState.food = [];
            gameState.walls = [];
            gameState.bullets = [];
            gameState.explosions = [];
            gameState.volcanoes = [];
        }

        // 重置游戏状态
    function resetGameState() {
        gameState.running = false;
        gameState.paused = false;
        gameState.gameTime = 0;

        // 重置玩家1 - 使用简单属性
        gameState.player1.hp = gameState.player1.type === 'hard' ? 15 : 10;
        gameState.player1.maxHp = gameState.player1.type === 'hard' ? 15 : 10;
        gameState.player1.shield = 0;
        gameState.player1.score = 0;
        gameState.player1.magicBalls = [];
        // 使用简单状态属性
        gameState.player1.isInvincible = false;
        gameState.player1.isReversed = false;
        gameState.player1.isAttacking = false;
        gameState.player1.invincibleTime = 0;
        gameState.player1.reversedTime = 0;
        gameState.player1.attackTime = 0;
        gameState.player1.speedMultiplier = 1;
        gameState.player1.hardUpgrades = 0;
        gameState.player1.magicUpgrades = 0;
        gameState.player1.segments = [];
        gameState.player1.baseHp = 50;
        gameState.player1.position = {
            x: -80,
            y: 1.5,
            z: -80
        };
        gameState.player1.direction = { x: 1, y: 0, z: 0 };
        gameState.player1.targetDirection = { x: 1, y: 0, z: 0 };
        gameState.player1.rotationAngle = 0;
        gameState.player1.paused = false;

        // 重置玩家2 - 使用简单属性
        gameState.player2.hp = gameState.player2.type === 'hard' ? 15 : 10;
        gameState.player2.maxHp = gameState.player2.type === 'hard' ? 15 : 10;
        gameState.player2.shield = 0;
        gameState.player2.score = 0;
        gameState.player2.magicBalls = [];
        // 使用简单状态属性
        gameState.player2.isInvincible = false;
        gameState.player2.isReversed = false;
        gameState.player2.isAttacking = false;
        gameState.player2.invincibleTime = 0;
        gameState.player2.reversedTime = 0;
        gameState.player2.attackTime = 0;
        gameState.player2.speedMultiplier = 1;
        gameState.player2.hardUpgrades = 0;
        gameState.player2.magicUpgrades = 0;
        gameState.player2.segments = [];
        gameState.player2.baseHp = 50;
        gameState.player2.position = {
            x: 80,
            y: 1.5,
            z: 80
        };
        gameState.player2.direction = { x: -1, y: 0, z: 0 };
        gameState.player2.targetDirection = { x: -1, y: 0, z: 0 };
        gameState.player2.rotationAngle = Math.PI;
        gameState.player2.paused = false;

        // 重置其他状态
        gameState.magicBalls = [];
        gameState.food = [];
        gameState.walls = [];
        gameState.bullets = [];
        gameState.explosions = [];
        gameState.volcanoes = [];
        gameState.stormDirection = null;
        gameState.stormActive = false;
        gameState.stormWarning = false;
    }
        // 创建地图环境
        function createMapEnvironment() {
            switch (gameState.mapType) {
                case 'classic':
                    createClassicMap();
                    break;
                case 'snow':
                    createSnowMap();
                    break;
                case 'volcano':
                    createVolcanoMap();
                    break;
            }
        }

        // 创建经典地图
    function createClassicMap() {
        // 设置边界和基地的安全区域
        const boundaryMargin = 15; // 边界安全距离
        const baseSafeRadius = 25; // 基地安全半径

        // 生成更多墙（增加到30个）
        const wallCount = 20;

        for (let i = 0; i < wallCount; i++) {
            let validPosition = false;
            let startX, startZ, endX, endZ;

            // 尝试生成有效的位置
            for (let attempts = 0; attempts < 10; attempts++) {
                // 随机生成起点
                startX = Math.random() * 180 - 90; // -90 到 90
                startZ = Math.random() * 180 - 90;

                // 随机生成长度和方向
                const length = 5 + Math.random() * 15; // 长度5-20
                const angle = Math.random() * Math.PI * 2; // 随机方向

                // 计算终点
                endX = startX + Math.cos(angle) * length;
                endZ = startZ + Math.sin(angle) * length;

                // 检查起点和终点是否都在边界内
                if (Math.abs(startX) > 100 - boundaryMargin || Math.abs(startZ) > 100 - boundaryMargin ||
                    Math.abs(endX) > 100 - boundaryMargin || Math.abs(endZ) > 100 - boundaryMargin) {
                    continue; // 太靠近边界，重新生成
                }

                // 检查是否太靠近基地
                const player1Base = gameState.player1.basePosition;
                const player2Base = gameState.player2.basePosition;

                // 计算到两个基地的距离
                const distToBase1Start = Math.sqrt(Math.pow(startX - player1Base.x, 2) + Math.pow(startZ - player1Base.z, 2));
                const distToBase2Start = Math.sqrt(Math.pow(startX - player2Base.x, 2) + Math.pow(startZ - player2Base.z, 2));
                const distToBase1End = Math.sqrt(Math.pow(endX - player1Base.x, 2) + Math.pow(endZ - player1Base.z, 2));
                const distToBase2End = Math.sqrt(Math.pow(endX - player2Base.x, 2) + Math.pow(endZ - player2Base.z, 2));

                // 确保墙的起点和终点都不在基地安全区域内
                if (distToBase1Start < baseSafeRadius || distToBase2Start < baseSafeRadius ||
                    distToBase1End < baseSafeRadius || distToBase2End < baseSafeRadius) {
                    continue; // 太靠近基地，重新生成
                }

                // 检查墙的中点是否太靠近基地
                const midX = (startX + endX) / 2;
                const midZ = (startZ + endZ) / 2;
                const distToBase1Mid = Math.sqrt(Math.pow(midX - player1Base.x, 2) + Math.pow(midZ - player1Base.z, 2));
                const distToBase2Mid = Math.sqrt(Math.pow(midX - player2Base.x, 2) + Math.pow(midZ - player2Base.z, 2));

                if (distToBase1Mid < baseSafeRadius || distToBase2Mid < baseSafeRadius) {
                    continue; // 中点太靠近基地，重新生成
                }

                validPosition = true;
                break;
            }

            if (!validPosition) {
                continue; // 无法找到有效位置，跳过这个墙
            }

            const wall = createWall(startX, startZ, endX, endZ);
            gameState.walls.push(wall);
            gameState.scene.add(wall);
        }

        // 3. 添加一些固定方向的墙来增加多样性（可选）
        addDirectionalWalls();
    }
    function addDirectionalWalls() {
        // 水平和垂直墙
        const directionalWalls = [
            // 水平墙
            { x1: -60, z1: -30, x2: -30, z2: -30, length: 30 },
            { x1: 30, z1: -30, x2: 60, z2: -30, length: 30 },
            { x1: -60, z1: 30, x2: -30, z2: 30, length: 30 },
            { x1: 30, z1: 30, x2: 60, z2: 30, length: 30 },

            // 垂直墙
            { x1: -30, z1: -60, x2: -30, z2: -30, length: 30 },
            { x1: 30, z1: -60, x2: 30, z2: -30, length: 30 },
            { x1: -30, z1: 30, x2: -30, z2: 60, length: 30 },
            { x1: 30, z1: 30, x2: 30, z2: 60, length: 30 },
        ];

        directionalWalls.forEach(wallData => {
            // 检查是否太靠近基地
            const player1Base = gameState.player1.basePosition;
            const player2Base = gameState.player2.basePosition;
            const baseSafeRadius = 25;

            const midX = (wallData.x1 + wallData.x2) / 2;
            const midZ = (wallData.z1 + wallData.z2) / 2;

            const distToBase1 = Math.sqrt(Math.pow(midX - player1Base.x, 2) + Math.pow(midZ - player1Base.z, 2));
            const distToBase2 = Math.sqrt(Math.pow(midX - player2Base.x, 2) + Math.pow(midZ - player2Base.z, 2));

            if (distToBase1 < baseSafeRadius || distToBase2 < baseSafeRadius) {
                return; // 太靠近基地，跳过
            }

            const wall = createWall(wallData.x1, wallData.z1, wallData.x2, wallData.z2);
            gameState.walls.push(wall);
            gameState.scene.add(wall);
        });
    }
        // 创建雪山地圖
    function createSnowMap() {
        // 改变天空颜色
        const sky = gameState.scene.children.find(child => child.material && child.material.color);
        if (sky) {
            sky.material.color.set(0x778899);
        }

        // 添加一些冰块条状墙
        createClassicMap(); // 使用相同的墙生成逻辑

        // 添加雪山
        createMountains();
    }
        // 创建火山地图
    function createVolcanoMap() {
        // 改变天空颜色
        const sky = gameState.scene.children.find(child => child.material && child.material.color);
        if (sky) {
            sky.material.color.set(0xFF4500);
        }

        // 使用相同的墙生成逻辑
        createClassicMap();

        // 创建火山
        const volcanoCount = Math.floor(Math.random() * 4) + 4;
        for (let i = 0; i < volcanoCount; i++) {
            const volcano = createVolcano(
                Math.random() * 150 - 75,
                Math.random() * 150 - 75
            );
            if (volcano) {
                gameState.volcanoes.push(volcano);
                gameState.scene.add(volcano);
            }
        }
    }


        // 创建墙壁
    function createWall(x1, z1, x2, z2) {
        // 计算墙的长度和方向
        const length = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(z2 - z1, 2));
        const angle = Math.atan2(z2 - z1, x2 - x1);

        // 创建墙的几何体：条状，高度与蛇相同（2个单位），宽度较窄
        const wallGeometry = new THREE.BoxGeometry(length, 2, 1); // 长度可变，高度2，宽度1
        const wallMaterial = new THREE.MeshStandardMaterial({
            color: 0x808080,
            roughness: 0.8,
            metalness: 0.2
        });

        const wall = new THREE.Mesh(wallGeometry, wallMaterial);

        // 计算中心点位置
        const centerX = (x1 + x2) / 2;
        const centerZ = (z1 + z2) / 2;

        wall.position.set(centerX, 1, centerZ); // 高度设为1（中心点在y=1，总高度2）
        wall.rotation.y = -angle; // 旋转到正确方向

        wall.castShadow = true;
        wall.receiveShadow = true;
        wall.userData = {
            type: 'wall',
            start: { x: x1, z: z1 },
            end: { x: x2, z: z2 },
            length: length
        };

        return wall;
    }

        // 创建冰墙
        function createIceWall(x, y, z) {
            const geometry = new THREE.BoxGeometry(5, 1, 5);
            const material = new THREE.MeshStandardMaterial({
                color: 0x87CEEB,
                roughness: 0.2,
                transparent: true,
                opacity: 0.7
            });
            const ice = new THREE.Mesh(geometry, material);
            ice.position.set(x, y, z);
            ice.castShadow = true;
            ice.receiveShadow = true;
            ice.userData = { type: 'wall' };
            return ice;
        }

        // 创建熔岩墙
        function createLavaWall(x, y, z) {
            const geometry = new THREE.BoxGeometry(5, 1, 5);
            const material = new THREE.MeshStandardMaterial({
                color: 0xFF4500,
                emissive: 0xFF4500,
                emissiveIntensity: 0.2,
                roughness: 0.5
            });
            const lavaRock = new THREE.Mesh(geometry, material);
            lavaRock.position.set(x, y, z);
            lavaRock.castShadow = true;
            lavaRock.receiveShadow = true;
            lavaRock.userData = { type: 'wall' };
            return lavaRock;
        }

        // 创建火山
        function createVolcano(x, z) {
            const player1BasePos = gameState.player1.basePosition;
            const player2BasePos = gameState.player2.basePosition;
            const baseSafeRadius = 40; // 火山需要更大的安全距离

            // 检查是否在基地安全区域内
            const distToBase1 = Math.sqrt(
                Math.pow(x - player1BasePos.x, 2) +
                Math.pow(z - player1BasePos.z, 2)
            );

            const distToBase2 = Math.sqrt(
                Math.pow(x - player2BasePos.x, 2) +
                Math.pow(z - player2BasePos.z, 2)
            );

            // 如果在基地安全区域内，返回null
            if (distToBase1 < baseSafeRadius || distToBase2 < baseSafeRadius) {
                return null; // 不在基地附近生成火山
            }
            const volcanoGroup = new THREE.Group();

            // 火山主体
            const coneGeometry = new THREE.ConeGeometry(8, 15, 32);
            const coneMaterial = new THREE.MeshStandardMaterial({
                color: 0x8B4513,
                roughness: 0.9
            });
            const volcano = new THREE.Mesh(coneGeometry, coneMaterial);
            volcano.position.y = 7.5;
            volcanoGroup.add(volcano);

            // 火山口
            const craterGeometry = new THREE.CylinderGeometry(3, 5, 2, 32);
            const craterMaterial = new THREE.MeshStandardMaterial({
                color: 0xFF4500,
                emissive: 0xFF4500,
                emissiveIntensity: 0.3
            });
            const crater = new THREE.Mesh(craterGeometry, craterMaterial);
            crater.position.y = 14;
            volcanoGroup.add(crater);

            volcanoGroup.position.set(x, 0, z);
            volcanoGroup.userData = {
                type: 'volcano',
                cooldown: 0,
                warning: false,
                active: false
            };

            return volcanoGroup;
        }

        // 创建山脉
        function createMountains() {
            const mountainGeometry = new THREE.ConeGeometry(20, 40, 32);
            const mountainMaterial = new THREE.MeshStandardMaterial({
                color: 0xFFFFFF,
                roughness: 0.8
            });

            // 在边界处添加山脉
            const positions = [
                { x: -120, z: -120 },
                { x: 120, z: -120 },
                { x: -120, z: 120 },
                { x: 120, z: 120 }
            ];

            positions.forEach(pos => {
                const mountain = new THREE.Mesh(mountainGeometry, mountainMaterial);
                mountain.position.set(pos.x, 20, pos.z);
                mountain.castShadow = true;
                gameState.scene.add(mountain);
            });
        }

        // 创建基地
    function createBase(position, color) {
        const baseGroup = new THREE.Group();

        // 基地底座
        const baseGeometry = new THREE.BoxGeometry(30, 2, 30);
        const baseMaterial = new THREE.MeshStandardMaterial({
            color: color,
            emissive: color,
            emissiveIntensity: 0.3,
            transparent: true,
            opacity: 0.4,
            side: THREE.DoubleSide
        });
        const base = new THREE.Mesh(baseGeometry, baseMaterial);
        base.position.y = 1;
        base.receiveShadow = true;
        baseGroup.add(base);

        // 基地防护罩
        const shieldGeometry = new THREE.SphereGeometry(18, 32, 32);
        const shieldMaterial = new THREE.MeshStandardMaterial({
            color: color,
            emissive: color,
            emissiveIntensity: 0.2,
            transparent: true,
            opacity: 0.2,
            side: THREE.DoubleSide,
            wireframe: true
        });
        const shield = new THREE.Mesh(shieldGeometry, shieldMaterial);
        shield.position.y = 8;
        baseGroup.add(shield);

        baseGroup.position.set(position.x, position.y, position.z);
        baseGroup.userData = {
            type: 'base',
            safeRadius: 20,
            color: color
        };

        return baseGroup;
    }


    // 更新基地血量显示
    function updateBaseHealthDisplay(playerKey) {
        const player = gameState[playerKey];
        if (!player || !player.baseHealthDisplay) {
            return;
        }

        const healthDisplay = player.baseHealthDisplay;

        // 检查 healthDisplay 是否已被销毁
        if (!healthDisplay.parent) {
            player.baseHealthDisplay = null;
            return;
        }

        const healthBar = healthDisplay.userData.healthBar;
        const sprite = healthDisplay.userData.textSprite;
        const ctx = healthDisplay.userData.ctx;
        const canvas = healthDisplay.userData.canvas;

        if (healthBar && healthBar.material) {
            // 更新血量条宽度
            const healthRatio = player.baseHp / 50;
            healthBar.scale.x = Math.max(0, healthRatio);

            // 根据血量改变颜色
            if (healthRatio > 0.5) {
                healthBar.material.color.set(playerKey === 'player1' ? 0x00FF00 : 0x00AAFF);
            } else if (healthRatio > 0.25) {
                healthBar.material.color.set(0xFFFF00);
            } else {
                healthBar.material.color.set(0xFF0000);
            }
        }

        if (sprite && ctx && canvas) {
            // 更新血量数值
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 绘制背景
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // 绘制血量数值
            ctx.font = 'bold 40px Arial';
            ctx.fillStyle = '#FFFFFF';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            const displayHp = Math.max(0, Math.ceil(player.baseHp));
            ctx.fillText(displayHp.toString(), 64, 32);

            // 更新纹理
            if (sprite.material && sprite.material.map) {
                sprite.material.map.needsUpdate = true;
            }
        }

        // 基地被摧毁时移除显示
        if (player.baseHp <= 0) {
            // 不在这里移除，让 destroyBase 处理
        }
    }
        function showBaseThreatWarning(position) {
            if (Math.random() > 0.1) return; // 降低频率

            const warningGeometry = new THREE.RingGeometry(15, 17, 16);
            const warningMaterial = new THREE.MeshBasicMaterial({
                color: 0xFF0000,
                transparent: true,
                opacity: 0.3,
                side: THREE.DoubleSide
            });
            const warningRing = new THREE.Mesh(warningGeometry, warningMaterial);
            warningRing.rotation.x = -Math.PI / 2;
            warningRing.position.set(position.x, 0.1, position.z);

            gameState.scene.add(warningRing);

            // 1秒后移除
            setTimeout(() => {
                if (warningRing.parent) {
                    gameState.scene.remove(warningRing);
                }
            }, 1000);
        }
        // 创建单个基地
    function createBases() {
        // 玩家1基地
        const base1 = createBase(
            { x: -80, y: 0, z: -80 },
            0xFF7F00,
            'player1' // 传递 playerKey
        );
        gameState.scene.add(base1);
        gameState.player1.baseObject = base1;
        gameState.player1.basePosition = { x: -80, y: 0, z: -80 };

        // 玩家2基地
        const base2 = createBase(
            { x: 80, y: 0, z: 80 },
            0x4169E1,
            'player2' // 传递 playerKey
        );
        gameState.scene.add(base2);
        gameState.player2.baseObject = base2;
        gameState.player2.basePosition = { x: 80, y: 0, z: 80 };
    }
        // 创建蛇
        function createSnakes() {
            // 玩家1的蛇
            const snake1 = createSnake(
                gameState.player1.position,
                gameState.player1.direction,
                0xFF7F00
            );
            gameState.scene.add(snake1);
            gameState.player1.snake = snake1;

            // 初始化蛇段
            for (let i = 0; i < 5; i++) {
                const segment = createSnakeSegment(
                    gameState.player1.position.x - i * 2,
                    gameState.player1.position.y - 0.25,
                    gameState.player1.position.z,
                    0xFFA500
                );
                gameState.scene.add(segment);
                gameState.player1.segments.push(segment);
            }

            // 玩家2的蛇
            const snake2 = createSnake(
                gameState.player2.position,
                gameState.player2.direction,
                0x4169E1
            );
            gameState.scene.add(snake2);
            gameState.player2.snake = snake2;

            // 初始化蛇段
            for (let i = 0; i < 5; i++) {
                const segment = createSnakeSegment(
                    gameState.player2.position.x + i * 2,
                    gameState.player2.position.y - 0.25,
                    gameState.player2.position.z,
                    0x87CEEB
                );
                gameState.scene.add(segment);
                gameState.player2.segments.push(segment);
            }
        }

        // 创建蛇头（在第一视角中，蛇头不可见，但保留用于碰撞检测）
        function createSnake(position, direction, color) {
            // 在第一视角中，我们不需要渲染蛇头模型
            // 但为了碰撞检测，我们创建一个不可见的立方体
            const snakeHead = new THREE.Mesh(
                new THREE.BoxGeometry(2, 2, 2),
                new THREE.MeshBasicMaterial({ visible: false })
            );
            snakeHead.position.set(position.x, position.y, position.z);
            snakeHead.userData = { type: 'snake' };
            return snakeHead;
        }

        // 创建蛇段
    function createSnakeSegment(x, y, z, color) {
        const geometry = new THREE.BoxGeometry(2, 2, 2);
        const material = new THREE.MeshStandardMaterial({
            color: color,
            roughness: 0.5
        });
        const segment = new THREE.Mesh(geometry, material);
        segment.position.set(x, y, z);
        segment.castShadow = true;
        segment.userData = { type: 'snakeSegment' };
        return segment;
    }

        // 生成食物
        function generateFood() {
            for (let i = 0; i < 20; i++) {
                const food = createFood(
                    Math.random() * 200 - 100,
                    0.5,
                    Math.random() * 200 - 100
                );
                gameState.food.push(food);
                gameState.scene.add(food);
            }
        }

        // 创建食物
        function createFood(x, y, z) {
            const foodGroup = new THREE.Group();

            // 食物主体
            const foodGeometry = new THREE.SphereGeometry(0.8, 16, 16);
            const foodMaterial = new THREE.MeshStandardMaterial({
                color: 0x00FF00,
                emissive: 0x00FF00,
                emissiveIntensity: 0.2
            });
            const food = new THREE.Mesh(foodGeometry, foodMaterial);
            foodGroup.add(food);

            // 食物茎
            const stemGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.5, 8);
            const stemMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22 });
            const stem = new THREE.Mesh(stemGeometry, stemMaterial);
            stem.position.y = 0.5;
            foodGroup.add(stem);

            foodGroup.position.set(x, y, z);
            foodGroup.userData = { type: 'food' };

            return foodGroup;
        }

        // 生成魔法球
        function generateMagicBalls() {
            const ballTypes = ['invincible', 'health', 'reverse', 'attack', 'bomb'];

            for (let i = 0; i < 10; i++) {
                const type = ballTypes[Math.floor(Math.random() * ballTypes.length)];
                const ball = createMagicBall(
                    Math.random() * 200 - 100,
                    0.5,
                    Math.random() * 200 - 100,
                    type
                );
                gameState.magicBalls.push(ball);
                gameState.scene.add(ball);
            }
        }

        // 创建魔法球
        function createMagicBall(x, y, z, type) {
            const geometry = new THREE.SphereGeometry(1, 16, 16);
            let material;

            switch (type) {
                case 'invincible':
                    material = new THREE.MeshStandardMaterial({
                        color: 0xFFFF00,
                        emissive: 0xFFFF00,
                        emissiveIntensity: 0.5
                    });
                    break;
                case 'health':
                    material = new THREE.MeshStandardMaterial({
                        color: 0xFF0000,
                        emissive: 0xFF0000,
                        emissiveIntensity: 0.5
                    });
                    break;
                case 'reverse':
                    material = new THREE.MeshStandardMaterial({
                        color: 0x800080,
                        emissive: 0x800080,
                        emissiveIntensity: 0.5
                    });
                    break;
                case 'attack':
                    material = new THREE.MeshStandardMaterial({
                        color: 0x87CEEB,
                        emissive: 0x87CEEB,
                        emissiveIntensity: 0.5
                    });
                    break;
                case 'bomb':
                    material = new THREE.MeshStandardMaterial({
                        color: 0xFF8C00,
                        emissive: 0xFF8C00,
                        emissiveIntensity: 0.5
                    });
                    break;
            }

            const ball = new THREE.Mesh(geometry, material);
            ball.position.set(x, y, z);
            ball.userData = { type: 'magicBall', ballType: type };

            return ball;
        }

        // 更新相机位置和朝向（第一视角）
        function updateCameras() {
            // 玩家1相机 - 斜45度俯视视角
            const p1 = gameState.player1;
            const p1Camera = p1.camera;

            // 相机高度和距离
            const cameraHeight = 50;  // 俯视高度
            const cameraDistance = 40; // 距离玩家水平距离

            // 相机位置：在玩家斜上方45度角
            p1Camera.position.set(
                p1.position.x + cameraDistance, // X方向偏移
                p1.position.y + cameraHeight,   // 高度
                p1.position.z + cameraDistance  // Z方向偏移
            );

            // 相机朝向：看向玩家位置
            p1Camera.lookAt(
                p1.position.x,
                p1.position.y + 10, // 稍微看向玩家上方一点
                p1.position.z
            );

            // 玩家2相机 - 同样的俯视视角
            const p2 = gameState.player2;
            const p2Camera = p2.camera;

            p2Camera.position.set(
                p2.position.x + cameraDistance,
                p2.position.y + cameraHeight,
                p2.position.z + cameraDistance
            );

            p2Camera.lookAt(
                p2.position.x,
                p2.position.y + 10,
                p2.position.z
            );
        }


    function updateInvincibleParticles(playerKey, deltaTime) {
        const player = gameState[playerKey];
        if (!player.isInvincible || !player.invincibleParticles) return;

        const particleGroup = player.invincibleParticles;
        const position = player.position;

        // 更新粒子组位置到蛇的位置
        particleGroup.position.set(position.x, position.y + 2, position.z);

        // 更新单个粒子的旋转和移动
        particleGroup.children.forEach((particle, index) => {
            if (particle.userData) {
                particle.userData.angle += particle.userData.speed * deltaTime;

                // 粒子围绕蛇旋转
                particle.position.x = Math.cos(particle.userData.angle) * particle.userData.radius;
                particle.position.z = Math.sin(particle.userData.angle) * particle.userData.radius;
                particle.position.y = Math.sin(particle.userData.angle + index) * 1.5;

                // 粒子闪烁效果
                particle.material.opacity = 0.3 + 0.4 * Math.sin(gameState.gameTime * 5 + index);
            }
        });
    }
        // 更新游戏
    function update() {
        if (!clock) {
            clock = new THREE.Clock();
        }

        const deltaTime = clock.getDelta();

        if (gameState.running) {
            // === 商店控制处理 ===
            if (shopState.player1.open) {
                handleShopControls('player1');
            }
            if (shopState.player2.open) {
                handleShopControls('player2');
            }

            gameState.gameTime += deltaTime;
            updateGameTime();

            // === 更新游戏元素（无论是否暂停都更新）===
            // 这些应该永远运行：
            updateBullets(deltaTime);
            updateExplosions(deltaTime);
            updateExplosionFragments(deltaTime);
            updateEnvironment(deltaTime);
            updateCameras();
            renderScenes();
            updateUI();
            updatePlayerStatus('player1', deltaTime);
            moveSnake('player1', deltaTime);
            checkCollisions('player1'); // 碰撞检测只在移动时检查
            updatePlayerStatus('player2', deltaTime);
            moveSnake('player2', deltaTime);
            checkCollisions('player2'); // 碰撞检测只在移动时检查

            // === 检查游戏结束 ===
            checkGameEnd();
        }
    }

        // 渲染场景（两个分屏视角）
        function renderScenes() {
            // 渲染玩家1视角
            gameState.player1.renderer.render(gameState.scene, gameState.player1.camera);

            // 渲染玩家2视角
            gameState.player2.renderer.render(gameState.scene, gameState.player2.camera);
        }

        // 更新游戏时间显示
        function updateGameTime() {
            const minutes = Math.floor(gameState.gameTime / 60);
            const seconds = Math.floor(gameState.gameTime % 60);
            gameTimeElement.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        function updatePlayerStatus(playerKey, deltaTime) {
            const player = gameState[playerKey];

            // 更新状态时间
            if (player.status !== 'normal' && player.statusTime > 0) {
                player.statusTime -= deltaTime;
                if (player.statusTime <= 0) {
                    player.status = 'normal';
                    player.statusTime = 0;
                }
            }

            // 更新俯冲状态
            if (player.isDashing && player.dashDuration > 0) {
                player.dashDuration -= deltaTime;
                if (player.dashDuration <= 0) {
                    player.isDashing = false;
                    player.dashDuration = 0;
                }
            }

            // 魔法蛇自动生成魔法球
            if (player.type === 'magic') {
                player.lastMagicGenerateTime += deltaTime;
                if (player.lastMagicGenerateTime >= 20) {
                    player.lastMagicGenerateTime = 0;
                    generateRandomMagicBall(playerKey);
                }
            }

            // 更新攻击模式下的自动射击
            if (player.status === 'attacking') {
                player.lastAttackTime = (player.lastAttackTime || 0) + deltaTime;
                if (player.lastAttackTime >= 0.4) {
                    player.lastAttackTime = 0;
                    shootBullet(playerKey);
                }
            }
        }

        // 为玩家生成随机魔法球
        function generateRandomMagicBall(playerKey) {
            const player = gameState[playerKey];
            if (player.magicBalls.length >= 5) return;

            const rand = Math.random();
            let ballType;

            if (rand < 0.4) ballType = 'attack';      // 40%
            else if (rand < 0.7) ballType = 'health'; // 30%
            else if (rand < 0.9) ballType = 'invincible'; // 20%
            else ballType = 'reverse';                // 10%

            player.magicBalls.push(ballType);
            updateMagicBallsDisplay(playerKey);
        }
        // 更新蛇的朝向（用于蛇头模型）
        function updateSnakeOrientation(playerKey) {
            const player = gameState[playerKey];
            const snake = player.snake;
            if (!snake) return;

            // 根据方向旋转蛇头
            const direction = player.direction;
            if (direction.x !== 0 || direction.z !== 0) {
                // 计算旋转角度
                const angle = Math.atan2(direction.z, direction.x);
                snake.rotation.y = -angle + Math.PI / 2;
            }
        }
        function getClosestPointOnSegment(px, pz, x1, z1, x2, z2) {
                const A = px - x1;
                const B = pz - z1;
                const C = x2 - x1;
                const D = z2 - z1;

                const dot = A * C + B * D;
                const lenSq = C * C + D * D;
                let param = -1;

                if (lenSq !== 0) {
                    param = dot / lenSq;
                }

                let xx, zz;

                if (param < 0) {
                    xx = x1;
                    zz = z1;
                } else if (param > 1) {
                    xx = x2;
                    zz = z2;
                } else {
                    xx = x1 + param * C;
                    zz = z1 + param * D;
                }

                return { x: xx, z: zz };
            }
    function checkWallCollision(playerKey) {
        const player = gameState[playerKey];
        const currentTime = performance.now();
        const timeSinceLastCollision = currentTime - lastWallCollisionTime[playerKey];

        for (let i = gameState.walls.length - 1; i >= 0; i--) {
            const wall = gameState.walls[i];
            const wallData = wall.userData;

            if (!wallData) continue;

            // 计算玩家到墙线段的最近点
            const closestPoint = getClosestPointOnSegment(
                player.position.x, player.position.z,
                wallData.start.x, wallData.start.z,
                wallData.end.x, wallData.end.z
            );

            // 计算距离
            const distance = Math.sqrt(
                Math.pow(player.position.x - closestPoint.x, 2) +
                Math.pow(player.position.z - closestPoint.z, 2)
            );

            // 考虑墙的宽度（0.5）和玩家的半径（1.5）
            const collisionDistance = 0.5 + 1.5;

            if (distance < collisionDistance) {
                // 如果距离上次撞墙不到1秒，跳过伤害
                if (timeSinceLastCollision > 1000) {
                    applyDamage(playerKey, 5, 'wall');
                    lastWallCollisionTime[playerKey] = currentTime;
                }

                // 撞烂墙
                gameState.scene.remove(wall);
                gameState.walls.splice(i, 1);

                // 显示墙被撞烂的效果
                showWallDestroyEffect({ x: closestPoint.x, y: 1, z: closestPoint.z });

                break;
            }
        }
    }
        function showWallDestroyEffect(position) {
            // 创建碎片粒子效果
            const fragmentCount = 8;

            for (let i = 0; i < fragmentCount; i++) {
                const fragmentGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
                const fragmentMaterial = new THREE.MeshStandardMaterial({
                    color: 0x808080,
                    roughness: 0.8
                });
                const fragment = new THREE.Mesh(fragmentGeometry, fragmentMaterial);

                fragment.position.copy(position);
                fragment.position.y = 0.5; // 从地面高度开始

                // 随机速度和方向
                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 8,
                    Math.random() * 4 + 2,
                    (Math.random() - 0.5) * 8
                );

                fragment.userData = {
                    velocity: velocity,
                    lifeTime: 1.5,
                    rotationSpeed: new THREE.Vector3(
                        Math.random() * 0.2 - 0.1,
                        Math.random() * 0.2 - 0.1,
                        Math.random() * 0.2 - 0.1
                    )
                };

                gameState.scene.add(fragment);

                // 添加碎片到临时数组，用于更新
                if (!gameState.wallFragments) {
                    gameState.wallFragments = [];
                }
                gameState.wallFragments.push(fragment);
            }
        }
    function checkSnakeCollision(playerKey) {
        const player = gameState[playerKey];
        const otherPlayerKey = playerKey === 'player1' ? 'player2' : 'player1';
        const otherPlayer = gameState[otherPlayerKey];

        const currentTime = performance.now();
        const collisionCooldown = 500;

        // 使用gameState中的lastCollisionTime
        if (currentTime - gameState.lastCollisionTime[playerKey] < collisionCooldown) {
            return;
        }

        // 1. 只检测与对方蛇头的碰撞
        const distanceToOtherHead = Math.sqrt(
            Math.pow(player.position.x - otherPlayer.position.x, 2) +
            Math.pow(player.position.z - otherPlayer.position.z, 2)
        );

        const headCollisionDistance = 5;

        if (distanceToOtherHead < headCollisionDistance) {

            const damage = 1;
            if (applyDamage(playerKey, damage, 'headCollision')) {
                showDamageEffect(playerKey);
            }
            if (applyDamage(otherPlayerKey, damage, 'headCollision')) {
                showDamageEffect(otherPlayerKey);
            }

            // 更新碰撞时间
            gameState.lastCollisionTime[playerKey] = currentTime;
            gameState.lastCollisionTime[otherPlayerKey] = currentTime;

            return;
        }

        // 2. 移除自己撞自己的检测（完全注释掉）
        // 不检测自己撞自己

        // 3. 检测与对方蛇身体的碰撞（放宽条件）
        for (let i = 2; i < otherPlayer.segments.length; i++) {
            const segment = otherPlayer.segments[i];
            const distance = Math.sqrt(
                Math.pow(player.position.x - segment.position.x, 2) +
                Math.pow(player.position.z - segment.position.z, 2)
            );

            const bodyCollisionDistance = 3.5;

            if (distance < bodyCollisionDistance) {
                // 只有撞到的蛇掉血
                const damage = 1;
                if (applyDamage(playerKey, damage, 'bodyCollision')) {
                    showDamageEffect(playerKey);
                }

                // 更新碰撞时间
                gameState.lastCollisionTime[playerKey] = currentTime;

                // 被撞的蛇从碰撞点截断（可选，先注释掉）
                
                if (i < otherPlayer.segments.length - 3 && i > 5) {
                    const segmentsToRemove = otherPlayer.segments.slice(i + 1);
                    segmentsToRemove.forEach(seg => {
                        if (seg.parent) {
                            gameState.scene.remove(seg);
                        }
                    });
                    
                    otherPlayer.segments = otherPlayer.segments.slice(0, i + 1);
                }
                

                break;
            }
        }
    }

        // 更新墙碎片
        function updateWallFragments(deltaTime) {
            if (!gameState.wallFragments || gameState.wallFragments.length === 0) return;

            for (let i = gameState.wallFragments.length - 1; i >= 0; i--) {
                const fragment = gameState.wallFragments[i];
                const data = fragment.userData;

                // 应用重力
                data.velocity.y -= 9.8 * deltaTime;

                // 更新位置
                fragment.position.x += data.velocity.x * deltaTime;
                fragment.position.y += data.velocity.y * deltaTime;
                fragment.position.z += data.velocity.z * deltaTime;

                // 更新旋转
                fragment.rotation.x += data.rotationSpeed.x;
                fragment.rotation.y += data.rotationSpeed.y;
                fragment.rotation.z += data.rotationSpeed.z;

                // 减少生命周期
                data.lifeTime -= deltaTime;

                // 如果碰到地面或生命周期结束
                if (fragment.position.y < 0 || data.lifeTime <= 0) {
                    gameState.scene.remove(fragment);
                    gameState.wallFragments.splice(i, 1);
                }
            }
        }
        // 更新蛇的方向
    function updateSnakeDirection(playerKey) {
        const player = gameState[playerKey];

        // 玩家1控制
        if (playerKey === 'player1') {
            if (player.isReversed) {
                // 反向控制时，按键映射相反
                if ((gameState.keys['s'] || gameState.keys['S']) && player.direction.z <= 0) {
                    player.targetDirection.x = 0;
                    player.targetDirection.z = -1; // 原本的S变成向上
                } else if ((gameState.keys['w'] || gameState.keys['W']) && player.direction.z >= 0) {
                    player.targetDirection.x = 0;
                    player.targetDirection.z = 1; // 原本的W变成向下
                } else if ((gameState.keys['d'] || gameState.keys['D']) && player.direction.x <= 0) {
                    player.targetDirection.x = -1; // 原本的D变成向左
                    player.targetDirection.z = 0;
                } else if ((gameState.keys['a'] || gameState.keys['A']) && player.direction.x >= 0) {
                    player.targetDirection.x = 1; // 原本的A变成向右
                    player.targetDirection.z = 0;
                }
            } else {
                // 正常控制
                if ((gameState.keys['w'] || gameState.keys['W']) && player.direction.z <= 0) {
                    player.targetDirection.x = 0;
                    player.targetDirection.z = -1;
                } else if ((gameState.keys['s'] || gameState.keys['S']) && player.direction.z >= 0) {
                    player.targetDirection.x = 0;
                    player.targetDirection.z = 1;
                } else if ((gameState.keys['a'] || gameState.keys['A']) && player.direction.x <= 0) {
                    player.targetDirection.x = -1;
                    player.targetDirection.z = 0;
                } else if ((gameState.keys['d'] || gameState.keys['D']) && player.direction.x >= 0) {
                    player.targetDirection.x = 1;
                    player.targetDirection.z = 0;
                }
            }
        }
        // 玩家2控制
        else if (playerKey === 'player2') {
            if (player.isReversed) {
                // 反向控制
                if (gameState.keys['ArrowDown'] && player.direction.z <= 0) {
                    player.targetDirection.x = 0;
                    player.targetDirection.z = -1; // 下键变成上
                } else if (gameState.keys['ArrowUp'] && player.direction.z >= 0) {
                    player.targetDirection.x = 0;
                    player.targetDirection.z = 1; // 上键变成下
                } else if (gameState.keys['ArrowRight'] && player.direction.x <= 0) {
                    player.targetDirection.x = -1; // 右键变成左
                    player.targetDirection.z = 0;
                } else if (gameState.keys['ArrowLeft'] && player.direction.x >= 0) {
                    player.targetDirection.x = 1; // 左键变成右
                    player.targetDirection.z = 0;
                }
            } else {
                // 正常控制
                if (gameState.keys['ArrowUp'] && player.direction.z <= 0) {
                    player.targetDirection.x = 0;
                    player.targetDirection.z = -1;
                } else if (gameState.keys['ArrowDown'] && player.direction.z >= 0) {
                    player.targetDirection.x = 0;
                    player.targetDirection.z = 1;
                } else if (gameState.keys['ArrowLeft'] && player.direction.x <= 0) {
                    player.targetDirection.x = -1;
                    player.targetDirection.z = 0;
                } else if (gameState.keys['ArrowRight'] && player.direction.x >= 0) {
                    player.targetDirection.x = 1;
                    player.targetDirection.z = 0;
                }
            }
        }
    }
    function updatePlayerStatusDisplay(playerKey) {
        const player = gameState[playerKey];

        // 检查是否已初始化蛇对象
        if (!player.snake) return;

        // 无敌时蛇冒金光
        if (player.isInvincible) {
            // 确保蛇头有材质
            if (player.snake.material) {
                // 蛇头不可见，不需要修改材质
            }

            // 给所有蛇段添加金光效果
            for (let i = 0; i < player.segments.length; i++) {
                const segment = player.segments[i];
                if (segment && segment.material) {
                    segment.material.color.set(0xFFFF00);
                    if (segment.material.emissive) {
                        segment.material.emissive.set(0xFFFF00);
                        segment.material.emissiveIntensity = 0.3;
                    }
                }
            }

            // 添加金色粒子效果
            if (!player.invincibleParticles) {
                createInvincibleParticles(playerKey);
            }
        } else {
            // 恢复蛇段的原始颜色
            const segmentColor = playerKey === 'player1' ? 0xFFA500 : 0x87CEEB;
            for (let i = 0; i < player.segments.length; i++) {
                const segment = player.segments[i];
                if (segment && segment.material) {
                    segment.material.color.set(segmentColor);
                    if (segment.material.emissive) {
                        segment.material.emissive.set(0x000000);
                        if (segment.material.emissiveIntensity) {
                            segment.material.emissiveIntensity = 0;
                        }
                    }
                }
            }

            // 移除粒子效果
            if (player.invincibleParticles) {
                removeInvincibleParticles(playerKey);
            }
        }
    }
    // 创建无敌时的粒子效果
    function createInvincibleParticles(playerKey) {
        const player = gameState[playerKey];

        // 创建一个粒子组
        const particleGroup = new THREE.Group();

        // 在蛇周围创建一些金色粒子
        for (let i = 0; i < 10; i++) {
            const particleGeometry = new THREE.SphereGeometry(0.4, 6, 6);
            const particleMaterial = new THREE.MeshBasicMaterial({
                color: 0xFFFF00,
                transparent: true,
                opacity: 0.5
            });
            const particle = new THREE.Mesh(particleGeometry, particleMaterial);

            // 随机位置（在蛇周围）
            particle.userData = {
                angle: Math.random() * Math.PI * 2,
                radius: 3 + Math.random() * 2,
                speed: 1 + Math.random() * 1
            };

            particleGroup.add(particle);
        }

        particleGroup.userData = {
            type: 'invincibleParticles',
            playerKey: playerKey
        };

        gameState.scene.add(particleGroup);
        player.invincibleParticles = particleGroup;
    }

    // 移除无敌粒子效果
    function removeInvincibleParticles(playerKey) {
        const player = gameState[playerKey];
        if (player.invincibleParticles && player.invincibleParticles.parent) {
            gameState.scene.remove(player.invincibleParticles);
            player.invincibleParticles = null;
        }
    }
        function updateSnakeSegments(playerKey) {
            const player = gameState[playerKey];
            const segments = player.segments;

            if (segments.length === 0) {
                // 初始化蛇段
                for (let i = 0; i < 5; i++) {
                    const segment = createSnakeSegment(
                        player.position.x - i * 2,
                        player.position.y - 0.25,
                        player.position.z,
                        playerKey === 'player1' ? 0xFFA500 : 0x87CEEB
                    );
                    gameState.scene.add(segment);
                    segments.push(segment);
                }
                return;
            }

            // 正常更新蛇段位置
            // 将最后一个蛇段移动到蛇头后面
            const lastSegment = segments[segments.length - 1];
            lastSegment.position.set(
                player.position.x,
                player.position.y + 1.25,
                player.position.z
            );

            // 将最后一个蛇段移到数组开头
            segments.unshift(segments.pop());
        }

        // 移动蛇
        function moveSnake(playerKey, deltaTime) {
            const player = gameState[playerKey];
            const snake = player.snake;
            if (!snake) return;
            if (player.paused) return;
            // 计算移动速度
            let speed = 15 * deltaTime; // 基础速度

            // 应用蛇类型的速度加成
            if (player.type === 'speed') {
                speed *= 1.5; // 速度蛇增加50%
            } else if (player.type === 'magic') {
                speed *= 1.15; // 魔法蛇增加15%
            }

            // 应用速度升级
            speed *= player.speedMultiplier;

            // 应用俯冲加速
            if (player.isDashing) {
                speed *= 3; // 俯冲期间3倍速度
            }

            // 应用暴风雪减速
            if (gameState.stormActive) {
                speed *= 0.8; // 暴风雪中减速20%
            }

            // 更新方向
            updateSnakeDirection(playerKey);

            // 直接设置方向
            if (player.targetDirection.x !== 0 || player.targetDirection.z !== 0) {
                player.direction.x = player.targetDirection.x;
                player.direction.z = player.targetDirection.z;
            }

            // 更新位置
            player.position.x += player.direction.x * speed;
            player.position.z += player.direction.z * speed;

            // 边界检查（使用新的边界大小100）
            const boundary = 100;
            if (player.position.x < -boundary) player.position.x = boundary;
            if (player.position.x > boundary) player.position.x = -boundary;
            if (player.position.z < -boundary) player.position.z = boundary;
            if (player.position.z > boundary) player.position.z = -boundary;

            // 更新蛇头位置
            snake.position.set(
                player.position.x,
                player.position.y,
                player.position.z
            );

            // 更新蛇段位置
            updateSnakeSegments(playerKey);
        }


        // 更新蛇段位置
        function addSnakeSegment(playerKey) {
            const player = gameState[playerKey];

            // 如果蛇段数量为0，创建第一个段
            if (player.segments.length === 0) {
                const segment = createSnakeSegment(
                    player.position.x,
                    player.position.y - 0.25,
                    player.position.z,
                    playerKey === 'player1' ? 0xFFA500 : 0x87CEEB
                );
                gameState.scene.add(segment);
                player.segments.push(segment);
                return;
            }

            // 获取最后一个蛇段
            const lastSegment = player.segments[player.segments.length - 1];

            // 修改：每次吃球增加3个段（原来是1个）
            for (let i = 0; i < 9; i++) {
                const newSegment = createSnakeSegment(
                    lastSegment.position.x,
                    lastSegment.position.y,
                    lastSegment.position.z,
                    playerKey === 'player1' ? 0xFFA500 : 0x87CEEB
                );
                gameState.scene.add(newSegment);
                player.segments.push(newSegment);
            }
        }


        function checkCollisions(playerKey, deltaTime) {
            const player = gameState[playerKey];
            const otherPlayerKey = playerKey === 'player1' ? 'player2' : 'player1';
            const otherPlayer = gameState[otherPlayerKey];

            // 检查与食物的碰撞
            for (let i = gameState.food.length - 1; i >= 0; i--) {
                const food = gameState.food[i];
                const distance = Math.sqrt(
                    Math.pow(player.position.x - food.position.x, 2) +
                    Math.pow(player.position.z - food.position.z, 2)
                );

                if (distance < 2) {
                    // 吃食物，增加分数
                    player.score += 50;

                    // 蛇变长：增加3个段
                    addSnakeSegment(playerKey);

                    // 移除食物
                    gameState.scene.remove(food);
                    gameState.food.splice(i, 1);

                    // 生成新食物
                    const newFood = createFood(
                        Math.random() * 200 - 100,
                        0.5,
                        Math.random() * 200 - 100
                    );
                    gameState.food.push(newFood);
                    gameState.scene.add(newFood);
                }
            }

            // 检查与魔法球的碰撞
            for (let i = gameState.magicBalls.length - 1; i >= 0; i--) {
                const ball = gameState.magicBalls[i];
                const distance = Math.sqrt(
                    Math.pow(player.position.x - ball.position.x, 2) +
                    Math.pow(player.position.z - ball.position.z, 2)
                );

                if (distance < 2) {
                    player.score += 100;
                    // 收集魔法球
                    if (player.magicBalls.length < 5) {
                        player.magicBalls.push(ball.userData.ballType);
                        updateMagicBallsDisplay(playerKey);
                    }

                    // 蛇变长：增加3个段（魔法球也增长）
                    addSnakeSegment(playerKey);

                    // 移除魔法球
                    gameState.scene.remove(ball);
                    gameState.magicBalls.splice(i, 1);

                    // 生成新魔法球
                    const ballTypes = ['invincible', 'health', 'reverse', 'attack', 'bomb'];
                    const type = ballTypes[Math.floor(Math.random() * ballTypes.length)];
                    const newBall = createMagicBall(
                        Math.random() * 200 - 100,
                        0.5,
                        Math.random() * 200 - 100,
                        type
                    );
                    gameState.magicBalls.push(newBall);
                    gameState.scene.add(newBall);
                }
            }

            // 修改：调用新的撞墙检测函数
            checkWallCollision(playerKey);

            checkSnakeCollision(playerKey);

            // 检查与子弹的碰撞
            for (let i = gameState.bullets.length - 1; i >= 0; i--) {
                const bullet = gameState.bullets[i];

                if (bullet.userData.owner === playerKey) continue;

                const distance = Math.sqrt(
                    Math.pow(player.position.x - bullet.position.x, 2) +
                    Math.pow(player.position.z - bullet.position.z, 2)
                );

                if (distance < 2) {
                    applyDamage(playerKey, 0.5, 'bullet');
                    gameState.scene.remove(bullet);
                    gameState.bullets.splice(i, 1);
                }
            }

            // 检查与基地的交互
            checkBaseInteraction(playerKey);

            // 检查与岩浆的碰撞
            if (gameState.mapType === 'volcano') {
                checkLavaDamage(playerKey);
            }
        }
        // 显示受伤效果
        function showDamageEffect(playerKey) {
            const damageOverlay = playerKey === 'player1' ? p1DamageOverlay : p2DamageOverlay;

            // 显示红色覆盖层
            damageOverlay.style.opacity = '0.7';

            // 添加镜头晃动效果
            const viewport = playerKey === 'player1' ?
                document.getElementById('player1-viewport') :
                document.getElementById('player2-viewport');
            viewport.classList.add('camera-shake');

            // 1秒后隐藏效果
            setTimeout(() => {
                damageOverlay.style.opacity = '0';
                viewport.classList.remove('camera-shake');
            }, 300);
        }

        // 应用伤害
    function applyDamage(playerKey, damage, source) {
        const player = gameState[playerKey];

        // 检查无敌状态
        if (player.isInvincible) {
            return false;
        }

        // 检查护盾
        if (player.shield > 0) {
            const shieldDamage = Math.min(damage, player.shield);
            player.shield -= shieldDamage;
            damage -= shieldDamage;

            console.log(`${playerKey}护盾吸收${shieldDamage}点伤害，剩余护盾: ${player.shield}`);

            if (player.shield <= 0) {
                player.shield = 0;
            }

            if (damage <= 0) return false;
        }

        // 坚硬蛇特性：非子弹类伤害减半
        let finalDamage = damage;
        if (player.type === 'hard' && source !== 'bullet' && source !== 'baseBullet') {
            finalDamage *= 0.5;

            // 子弹免疫：50%概率免疫子弹伤害
            if ((source === 'bullet' || source === 'baseBullet') && Math.random() < 0.5) {
                return false;
            }
        }

        // 应用伤害
        const oldHp = player.hp;
        player.hp -= finalDamage;
        if (player.hp < 0) player.hp = 0;

        // 返回是否实际造成了伤害
        return oldHp > player.hp;
    }

        // 检查基地交互
        // 检查基地交互 - 修复回血部分
    function checkBaseInteraction(playerKey) {
        const player = gameState[playerKey];
        const otherPlayerKey = playerKey === 'player1' ? 'player2' : 'player1';
        const otherPlayer = gameState[otherPlayerKey];

        // 如果自己的基地被摧毁了，不能回血
        if (player.baseDestroyed) {
            // 基地被摧毁，不能回血
            player.lastHealTime = null;
        } else {
            // 1. 检查自己基地（回血）- 只在基地未被摧毁时有效
            const distanceToOwnBaseCenter = Math.sqrt(
                Math.pow(player.position.x - player.basePosition.x, 2) +
                Math.pow(player.position.z - player.basePosition.z, 2)
            );

            const baseRadius = 15;
            if (distanceToOwnBaseCenter < baseRadius) {
                // 每秒回1点血
                const currentTime = performance.now();
                if (!player.lastHealTime) player.lastHealTime = currentTime;

                if (currentTime - player.lastHealTime > 100) {
                    if (player.hp < player.maxHp) {
                        player.hp += 0.1;
                        if (player.hp > player.maxHp) player.hp = player.maxHp;
                    }
                    player.lastHealTime = currentTime;
                }
            }
        }

        // 2. 检查对方基地（攻击）- 只在对方基地未被摧毁时有效
        if (!otherPlayer.baseDestroyed && otherPlayer.baseObject) {
            const distanceToOtherBaseCenter = Math.sqrt(
                Math.pow(player.position.x - otherPlayer.basePosition.x, 2) +
                Math.pow(player.position.z - otherPlayer.basePosition.z, 2)
            );

            const baseRadius = 15;
            if (distanceToOtherBaseCenter < baseRadius) {
                // 对玩家自身造成伤害（每秒1点）
                const currentTime = performance.now();
                if (!player.lastBaseDamageTime) player.lastBaseDamageTime = currentTime;

                if (currentTime - player.lastBaseDamageTime > 1000) {
                    if (player.status !== 'invincible') {
                        const damage = player.type === 'hard' ? 0.5 : 1;
                        applyDamage(playerKey, damage, 'base');
                    }
                    player.lastBaseDamageTime = currentTime;
                }

                // 对基地造成伤害（每秒3点）
                if (!otherPlayer.lastBaseUnderAttackTime) {
                    otherPlayer.lastBaseUnderAttackTime = currentTime;
                }

                if (currentTime - otherPlayer.lastBaseUnderAttackTime > 1000) {
                    otherPlayer.baseHp -= 3;
                    if (otherPlayer.baseHp < 0) otherPlayer.baseHp = 0;
                    otherPlayer.lastBaseUnderAttackTime = currentTime;

                    // 显示基地被攻击效果
                    showBaseDamageEffect(otherPlayer.basePosition);

                    // 基地被摧毁
                    if (otherPlayer.baseHp <= 0) {
                        destroyBase(otherPlayerKey);
                    }
                }
            } else {
                // 离开基地范围，重置计时器
                player.lastBaseDamageTime = null;
                if (otherPlayer) otherPlayer.lastBaseUnderAttackTime = null;
            }

            // 3. 基地防御系统 - 只在基地未被摧毁时有效
            const defenseDetectionRange = baseRadius + 50;
            if (distanceToOtherBaseCenter < defenseDetectionRange) {
                // 基地防御：每1秒发射一次子弹
                const currentTime = performance.now();
                if (!otherPlayer.lastBaseShotTime) {
                    otherPlayer.lastBaseShotTime = 0;
                }

                if (currentTime - otherPlayer.lastBaseShotTime > 1000) {
                    shootBaseBullet(otherPlayerKey, playerKey);
                    otherPlayer.lastBaseShotTime = currentTime;
                }
            }
        } else {
            // 对方基地已被摧毁，清除相关计时器
            player.lastBaseDamageTime = null;
            if (otherPlayer) {
                otherPlayer.lastBaseUnderAttackTime = null;
                otherPlayer.lastBaseShotTime = null;
            }
        }
    }
    function destroyBase(playerKey) {
        const player = gameState[playerKey];

        console.log(`${playerKey}基地被完全摧毁！`);

        // 1. 设置基地血量为0
        player.baseHp = 0;

        // 2. 移除基地对象
        if (player.baseObject && player.baseObject.parent) {
            // 创建爆炸效果
            createBaseExplosion(player.basePosition);

            // 移除基地
            gameState.scene.remove(player.baseObject);
            player.baseObject = null;
        }

        // 3. 停止基地的所有功能
        // 移除基地防御系统的引用和计时器
        player.lastBaseShotTime = null;
        player.lastBaseUnderAttackTime = null;
        player.lastBaseDamageTime = null;

        // 4. 标记基地已被摧毁
        player.baseDestroyed = true;

        // 5. 更新UI
        updateUI();
    }
        // 创建基地爆炸效果
        function createBaseExplosion(position) {
            // 创建大型爆炸效果
            const explosionGroup = new THREE.Group();

            // 爆炸火球
            const fireGeometry = new THREE.SphereGeometry(8, 32, 32);
            const fireMaterial = new THREE.MeshStandardMaterial({
                color: 0xFF4500,
                emissive: 0xFF4500,
                emissiveIntensity: 0.9,
                transparent: true,
                opacity: 0.8
            });
            const fireball = new THREE.Mesh(fireGeometry, fireMaterial);
            explosionGroup.add(fireball);

            // 爆炸冲击波
            const shockwaveGeometry = new THREE.RingGeometry(5, 15, 32);
            const shockwaveMaterial = new THREE.MeshBasicMaterial({
                color: 0xFFFF00,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.6
            });
            const shockwave = new THREE.Mesh(shockwaveGeometry, shockwaveMaterial);
            shockwave.rotation.x = -Math.PI / 2;
            shockwave.position.y = 0.1;
            explosionGroup.add(shockwave);

            // 碎片
            for (let i = 0; i < 20; i++) {
                const fragmentGeometry = new THREE.BoxGeometry(1, 1, 1);
                const fragmentMaterial = new THREE.MeshStandardMaterial({
                    color: Math.random() > 0.5 ? 0xFF7F00 : 0x4169E1,
                    emissiveIntensity: 0.3
                });
                const fragment = new THREE.Mesh(fragmentGeometry, fragmentMaterial);

                fragment.position.set(
                    position.x + (Math.random() - 0.5) * 5,
                    position.y + Math.random() * 3,
                    position.z + (Math.random() - 0.5) * 5
                );

                fragment.userData = {
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 10,
                        Math.random() * 5 + 2,
                        (Math.random() - 0.5) * 10
                    ),
                    rotationSpeed: new THREE.Vector3(
                        Math.random() * 0.2 - 0.1,
                        Math.random() * 0.2 - 0.1,
                        Math.random() * 0.2 - 0.1
                    ),
                    lifeTime: 2
                };

                explosionGroup.add(fragment);
                gameState.explosionFragments = gameState.explosionFragments || [];
                gameState.explosionFragments.push(fragment);
            }

            explosionGroup.position.set(position.x, position.y, position.z);
            explosionGroup.userData = { lifeTime: 1 };
            gameState.explosions.push(explosionGroup);
            gameState.scene.add(explosionGroup);
        }

        // 更新爆炸碎片
        function updateExplosionFragments(deltaTime) {
            if (!gameState.explosionFragments) return;

            for (let i = gameState.explosionFragments.length - 1; i >= 0; i--) {
                const fragment = gameState.explosionFragments[i];
                const data = fragment.userData;

                if (!data) continue;

                // 更新位置
                fragment.position.x += data.velocity.x * deltaTime;
                fragment.position.y += data.velocity.y * deltaTime;
                fragment.position.z += data.velocity.z * deltaTime;

                // 应用重力
                data.velocity.y -= 9.8 * deltaTime;

                // 更新旋转
                fragment.rotation.x += data.rotationSpeed.x;
                fragment.rotation.y += data.rotationSpeed.y;
                fragment.rotation.z += data.rotationSpeed.z;

                // 减少生命周期
                data.lifeTime -= deltaTime;

                // 移除过期碎片
                if (data.lifeTime <= 0 || fragment.position.y < 0) {
                    if (fragment.parent) {
                        gameState.scene.remove(fragment);
                    }
                    gameState.explosionFragments.splice(i, 1);
                }
            }
        }

        // 检查岩浆伤害
        function checkLavaDamage(playerKey) {
            const player = gameState[playerKey];

            // 检查是否在火山喷发的岩浆范围内
            for (const volcano of gameState.volcanoes) {
                if (volcano.userData.active) {
                    const distance = Math.sqrt(
                        Math.pow(player.position.x - volcano.position.x, 2) +
                        Math.pow(player.position.z - volcano.position.z, 2)
                    );

                    if (distance < 10) {
                        // 岩浆伤害
                        const damageApplied = applyDamage(playerKey, 2 * clock.getDelta(), 'lava');
                        if (damageApplied && playerKey === 'player1') {
                            showDamageEffect('player1');
                        } else if (damageApplied && playerKey === 'player2') {
                            showDamageEffect('player2');
                        }
                    }
                }
            }
        }
        function shootBullet(playerKey) {
            const player = gameState[playerKey];

            // 根据攻击叠加层数增加子弹大小
            const attackStacks = player.attackStacks || 0;
            const sizeMultiplier = 1 + attackStacks * 0.2; // 每层增加20%大小

            // 获取蛇的当前前进方向
            const direction = player.direction;

            const bullet = createBullet(
                player.position.x,
                player.position.y + 1.5,
                player.position.z,
                direction,
                playerKey === 'player1' ? 0xFF7F00 : 0x4169E1,
                playerKey
            );

            // 调整子弹大小
            bullet.scale.set(sizeMultiplier, sizeMultiplier, sizeMultiplier);

            gameState.bullets.push(bullet);
            gameState.scene.add(bullet);
        }
        function createBullet(x, y, z, direction, color, owner) {
            // 改回原来的0.4大小
            const geometry = new THREE.SphereGeometry(0.4, 8, 8);
            const material = new THREE.MeshStandardMaterial({
                color: color,
                emissive: color,
                emissiveIntensity: 0.5
            });
            const bullet = new THREE.Mesh(geometry, material);
            bullet.position.set(x, y, z);
            bullet.userData = {
                type: 'bullet',
                direction: { x: direction.x, y: 0, z: direction.z },
                speed: 180, // 改回原来的速度
                lifeTime: 5,
                owner: owner,
                damage: 0.5
            };
            return bullet;
        }

    function createBaseBullet(x, y, z, direction, color) {
        const geometry = new THREE.SphereGeometry(0.4, 8, 8);
        const material = new THREE.MeshStandardMaterial({
            color: color,
            emissive: color,
            emissiveIntensity: 0.5
        });
        const bullet = new THREE.Mesh(geometry, material);
        bullet.position.set(x, y, z);
        bullet.userData = {
            type: 'baseBullet',
            direction: direction,
            speed: 15,
            damage: 0.5  // 伤害0.5
        };
        return bullet;
    }

        function getPlayerSpeed(playerKey) {
            const player = gameState[playerKey];
            let speed = 15; // 基础速度

            if (player.type === 'speed') {
                speed *= 1.5;
            } else if (player.type === 'magic') {
                speed *= 1.15;
            }

            speed *= player.speedMultiplier;

            if (player.isDashing) {
                speed *= 3;
            }

            return speed;
        }
        // 修改shootBaseBullet函数
        // 修改shootBaseBullet函数为批量发射
   function shootBaseBullet(baseOwnerKey, targetPlayerKey) {
        const owner = gameState[baseOwnerKey];
        const target = gameState[targetPlayerKey];

        if (target.hp <= 0) return;

        // 计算目标相对于基地的方向
        const dx = target.position.x - owner.basePosition.x;
        const dz = target.position.z - owner.basePosition.z;

        // 决定从哪条边发射（基地的四个边）
        let side = '';
        if (Math.abs(dx) > Math.abs(dz)) {
            // X方向距离更大，从左边或右边发射
            side = dx > 0 ? 'right' : 'left';
        } else {
            // Z方向距离更大，从上边或下边发射
            side = dz > 0 ? 'bottom' : 'top';
        }

        // 从选定的边发射6颗子弹，对准玩家
        const bulletCount = 6;
        const baseRadius = 15;

        for (let i = 0; i < bulletCount; i++) {
            let firePosition;
            let direction;

            // 根据选定的边计算发射位置和方向
            switch (side) {
                case 'top': // 上边
                    firePosition = {
                        x: owner.basePosition.x - baseRadius + (2 * baseRadius / (bulletCount - 1)) * i,
                        y: 3,
                        z: owner.basePosition.z - baseRadius
                    };
                    // 从基地上边向玩家方向发射
                    direction = {
                        x: target.position.x - firePosition.x,
                        y: 0,
                        z: target.position.z - firePosition.z
                    };
                    break;

                case 'bottom': // 下边
                    firePosition = {
                        x: owner.basePosition.x - baseRadius + (2 * baseRadius / (bulletCount - 1)) * i,
                        y: 3,
                        z: owner.basePosition.z + baseRadius
                    };
                    // 从基地下边向玩家方向发射
                    direction = {
                        x: target.position.x - firePosition.x,
                        y: 0,
                        z: target.position.z - firePosition.z
                    };
                    break;

                case 'left': // 左边
                    firePosition = {
                        x: owner.basePosition.x - baseRadius,
                        y: 3,
                        z: owner.basePosition.z - baseRadius + (2 * baseRadius / (bulletCount - 1)) * i
                    };
                    // 从基地左边向玩家方向发射
                    direction = {
                        x: target.position.x - firePosition.x,
                        y: 0,
                        z: target.position.z - firePosition.z
                    };
                    break;

                case 'right': // 右边
                    firePosition = {
                        x: owner.basePosition.x + baseRadius,
                        y: 3,
                        z: owner.basePosition.z - baseRadius + (2 * baseRadius / (bulletCount - 1)) * i
                    };
                    // 从基地右边向玩家方向发射
                    direction = {
                        x: target.position.x - firePosition.x,
                        y: 0,
                        z: target.position.z - firePosition.z
                    };
                    break;
            }

            // 归一化方向（使其长度为1）
            const length = Math.sqrt(direction.x * direction.x + direction.z * direction.z);
            if (length === 0) continue;
            direction.x /= length;
            direction.z /= length;

            // 创建子弹
            const bullet = createBaseBullet(
                firePosition.x,
                firePosition.y,
                firePosition.z,
                direction,
                baseOwnerKey === 'player1' ? 0xFF7F00 : 0x4169E1
            );

            bullet.userData.owner = baseOwnerKey;
            bullet.userData.damage = 0.5;

            gameState.bullets.push(bullet);
            gameState.scene.add(bullet);
        }
    }


        // 更新子弹
    // 4. 修改 updateBullets 函数，确保碰撞检测被调用
    function updateBullets(deltaTime) {
        for (let i = gameState.bullets.length - 1; i >= 0; i--) {
            const bullet = gameState.bullets[i];
            const data = bullet.userData;

            if (!data) continue;

            // 子弹移动
            bullet.position.x += data.direction.x * data.speed * deltaTime;
            bullet.position.z += data.direction.z * data.speed * deltaTime;

            // 边界检查
            const boundary = 120;
            if (Math.abs(bullet.position.x) > boundary ||
                Math.abs(bullet.position.z) > boundary) {
                gameState.scene.remove(bullet);
                gameState.bullets.splice(i, 1);
                continue;
            }

            // 检查与墙壁的碰撞
            checkBulletWallCollision(bullet, i);

            // 如果子弹还在，检查与基地的碰撞
            if (gameState.bullets[i] === bullet) {
                checkBulletBaseCollision(bullet, i);
            }

            // 如果子弹还在，检查与玩家的碰撞
            if (gameState.bullets[i] === bullet) {
                checkBulletPlayerCollision(bullet, i);
            }
        }
    }
    function createBullet(x, y, z, direction, color, owner) {
        const geometry = new THREE.SphereGeometry(0.4, 8, 8);
        const material = new THREE.MeshStandardMaterial({
            color: color,
            emissive: color,
            emissiveIntensity: 0.5
        });
        const bullet = new THREE.Mesh(geometry, material);
        bullet.position.set(x, y, z);
        bullet.userData = {
            type: 'bullet',
            direction: { x: direction.x, y: 0, z: direction.z },
            speed: 180,
            owner: owner,
            damage: 0.5
        };
        return bullet;
    }
    function checkBulletWallCollision(bullet, bulletIndex) {
        const data = bullet.userData;
        if (!data) return;

        for (let j = gameState.walls.length - 1; j >= 0; j--) {
            const wall = gameState.walls[j];
            const wallData = wall.userData;

            if (!wallData) continue;

            // 计算子弹到墙线段的最近点
            const closestPoint = getClosestPointOnSegment(
                bullet.position.x, bullet.position.z,
                wallData.start.x, wallData.start.z,
                wallData.end.x, wallData.end.z
            );

            const distance = Math.sqrt(
                Math.pow(bullet.position.x - closestPoint.x, 2) +
                Math.pow(bullet.position.z - closestPoint.z, 2)
            );

            // 墙的宽度0.5，子弹半径0.4
            if (distance < 0.5 + 0.4) {
                gameState.scene.remove(bullet);
                gameState.bullets.splice(bulletIndex, 1);
                break;
            }
        }
    }
    function checkBulletPlayerCollision(bullet, bulletIndex) {
        const data = bullet.userData;

        if (data.type !== 'bullet' && data.type !== 'baseBullet') return;

        const players = ['player1', 'player2'];

        for (const playerKey of players) {
            const player = gameState[playerKey];

            // 跳过自己的子弹
            if (data.owner === playerKey) continue;

            // 检查与蛇头的碰撞
            const playerRadius = 1.5;
            const bulletRadius = 0.4;

            const headDistance = Math.sqrt(
                Math.pow(player.position.x - bullet.position.x, 2) +
                Math.pow(player.position.z - bullet.position.z, 2)
            );

            if (headDistance < playerRadius + bulletRadius) {
                const damageAmount = data.damage || 0.5;
                const damageApplied = applyDamage(playerKey, damageAmount, data.type);

                if (damageApplied) {
                    showDamageEffect(playerKey);
                }

                gameState.scene.remove(bullet);
                gameState.bullets.splice(bulletIndex, 1);
                return;
            }

            // 检查与蛇身的碰撞
            for (let i = 0; i < player.segments.length; i++) {
                const segment = player.segments[i];
                if (!segment) continue;

                const segmentDistance = Math.sqrt(
                    Math.pow(segment.position.x - bullet.position.x, 2) +
                    Math.pow(segment.position.z - bullet.position.z, 2)
                );

                if (segmentDistance < 1.5 + bulletRadius) {
                    const damageAmount = data.damage || 0.5;
                    const damageApplied = applyDamage(playerKey, damageAmount, data.type);

                    if (damageApplied) {
                        showDamageEffect(playerKey);
                    }

                    gameState.scene.remove(bullet);
                    gameState.bullets.splice(bulletIndex, 1);
                    return;
                }
            }
        }
    }
    function checkBulletBaseCollision(bullet, bulletIndex) {
        const data = bullet.userData;
        if (!data) return;

        // 检查所有玩家的基地
        const players = ['player1', 'player2'];

        for (const playerKey of players) {
            const player = gameState[playerKey];

            // 跳过自己的子弹对自家基地的伤害
            if (data.owner === playerKey && data.type === 'bullet') continue;

            // 如果基地已被摧毁，跳过
            if (player.baseHp <= 0 || !player.baseObject) continue;

            // 计算子弹到基地中心的距离
            const distance = Math.sqrt(
                Math.pow(bullet.position.x - player.basePosition.x, 2) +
                Math.pow(bullet.position.z - player.basePosition.z, 2)
            );

            // 基地半径约15（30/2），子弹半径0.4
            if (distance < 15 + 0.4) {
                // 不同子弹类型对基地伤害不同
                let damage = 0;
                if (data.type === 'baseBullet') {
                    damage = 0.5; // 基地子弹对基地伤害0.5
                } else {
                    damage = 1; // 玩家子弹对基地伤害1
                }

                player.baseHp -= damage;
                if (player.baseHp < 0) player.baseHp = 0;

                // 显示基地伤害效果
                showBaseDamageEffect(player.basePosition);

                // 移除子弹
                gameState.scene.remove(bullet);
                gameState.bullets.splice(bulletIndex, 1);

                // 基地被摧毁
                if (player.baseHp <= 0 && player.baseObject) {
                    destroyBase(playerKey);
                }

                return;
            }
        }
    }

        // 基地伤害效果
        function showBaseDamageEffect(position) {
            // 创建伤害粒子效果
            const particleCount = 5;
            for (let i = 0; i < particleCount; i++) {
                const particleGeometry = new THREE.SphereGeometry(0.3, 6, 6);
                const particleMaterial = new THREE.MeshBasicMaterial({
                    color: 0xFF0000,
                    transparent: true,
                    opacity: 0.7
                });
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);

                particle.position.set(
                    position.x + (Math.random() - 0.5) * 10,
                    position.y + Math.random() * 5,
                    position.z + (Math.random() - 0.5) * 10
                );

                gameState.scene.add(particle);

                // 1秒后移除粒子
                setTimeout(() => {
                    if (particle.parent) {
                        gameState.scene.remove(particle);
                    }
                }, 1000);
            }
        }
        // 更新爆炸效果
        function updateExplosions(deltaTime) {
            for (let i = gameState.explosions.length - 1; i >= 0; i--) {
                const explosion = gameState.explosions[i];
                explosion.userData.lifeTime -= deltaTime;

                if (explosion.userData.lifeTime <= 0) {
                    gameState.scene.remove(explosion);
                    gameState.explosions.splice(i, 1);
                }
            }
        }

        // 更新环境效果
        function updateEnvironment(deltaTime) {
            // 更新火山
            if (gameState.mapType === 'volcano') {
                updateVolcanoes(deltaTime);
            }

            // 更新暴风雪
            if (gameState.mapType === 'snow') {
                updateSnowStorm(deltaTime);
            }
        }

        // 更新火山
        function updateVolcanoes(deltaTime) {
            for (const volcano of gameState.volcanoes) {
                volcano.userData.cooldown -= deltaTime;

                if (volcano.userData.cooldown <= 0) {
                    if (!volcano.userData.warning && !volcano.userData.active) {
                        // 开始警告阶段
                        volcano.userData.warning = true;
                        volcano.userData.warningTime = 5;

                        // 火山闪烁
                        const crater = volcano.children[1];
                        if (crater && crater.material) {
                            crater.material.emissiveIntensity = 0.8;
                        }
                    } else if (volcano.userData.warning && volcano.userData.warningTime > 0) {
                        // 警告阶段倒计时
                        volcano.userData.warningTime -= deltaTime;

                        // 火山闪烁效果
                        const crater = volcano.children[1];
                        if (crater && crater.material) {
                            crater.material.emissiveIntensity = 0.3 + 0.5 * Math.sin(gameState.gameTime * 10);
                        }

                        if (volcano.userData.warningTime <= 0) {
                            // 开始喷发
                            volcano.userData.warning = false;
                            volcano.userData.active = true;
                            volcano.userData.activeTime = 15;

                            // 创建岩浆区域
                            createLavaZone(volcano.position.x, volcano.position.z);
                        }
                    } else if (volcano.userData.active && volcano.userData.activeTime > 0) {
                        // 喷发阶段倒计时
                        volcano.userData.activeTime -= deltaTime;

                        if (volcano.userData.activeTime <= 0) {
                            // 结束喷发
                            volcano.userData.active = false;
                            volcano.userData.cooldown = 30;

                            // 恢复火山口亮度
                            const crater = volcano.children[1];
                            if (crater && crater.material) {
                                crater.material.emissiveIntensity = 0.3;
                            }
                        }
                    }
                }
            }
        }

        // 创建岩浆区域
        function createLavaZone(x, z) {
            // 创建3x3的岩浆区域
            for (let dx = -1; dx <= 1; dx++) {
                for (let dz = -1; dz <= 1; dz++) {
                    const lava = createLavaPatch(x + dx * 6, z + dz * 6);
                    lava.userData.lifeTime = 15;
                    gameState.scene.add(lava);

                    // 15秒后移除
                    setTimeout(() => {
                        if (lava.parent) {
                            gameState.scene.remove(lava);
                        }
                    }, 15000);
                }
            }
        }

        // 创建岩浆贴片
        function createLavaPatch(x, z) {
            const geometry = new THREE.PlaneGeometry(5, 5);
            const material = new THREE.MeshStandardMaterial({
                color: 0xFF4500,
                emissive: 0xFF4500,
                emissiveIntensity: 0.5,
                transparent: true,
                opacity: 0.7
            });
            const lava = new THREE.Mesh(geometry, material);
            lava.rotation.x = -Math.PI / 2;
            lava.position.set(x, 0.1, z);
            lava.userData = { type: 'lava' };
            return lava;
        }

        // 更新暴风雪
        function updateSnowStorm(deltaTime) {
            // 随机触发暴风雪
            if (!gameState.stormActive && !gameState.stormWarning && Math.random() < 0.001) {
                gameState.stormWarning = true;
                gameState.stormWarningTime = 5;

                // 随机选择一个方向
                const directions = [
                    { x: 0, z: -1 }, // 上
                    { x: 0, z: 1 },  // 下
                    { x: -1, z: 0 }, // 左
                    { x: 1, z: 0 }   // 右
                ];
                gameState.stormDirection = directions[Math.floor(Math.random() * directions.length)];
            }

            if (gameState.stormWarning && gameState.stormWarningTime > 0) {
                gameState.stormWarningTime -= deltaTime;
                if (gameState.stormWarningTime <= 0) {
                    gameState.stormWarning = false;
                    gameState.stormActive = true;
                    gameState.stormActiveTime = 10;
                }
            }

            if (gameState.stormActive && gameState.stormActiveTime > 0) {
                gameState.stormActiveTime -= deltaTime;
                if (gameState.stormActiveTime <= 0) {
                    gameState.stormActive = false;
                }
            }
        }

        // 添加蛇段
        function addSnakeSegment(playerKey) {
            const player = gameState[playerKey];

            if (player.segments.length === 0) {
                // 创建第一个段
                const segment = createSnakeSegment(
                    player.position.x,
                    player.position.y - 0.25,
                    player.position.z,
                    playerKey === 'player1' ? 0xFFA500 : 0x87CEEB
                );
                gameState.scene.add(segment);
                player.segments.push(segment);
                return;
            }

            // 获取最后一个蛇段的位置
            const lastSegment = player.segments[player.segments.length - 1];

            // 添加3个新段
            for (let i = 0; i < 3; i++) {
                const newSegment = createSnakeSegment(
                    lastSegment.position.x,
                    lastSegment.position.y,
                    lastSegment.position.z,
                    playerKey === 'player1' ? 0xFFA500 : 0x87CEEB
                );
                gameState.scene.add(newSegment);
                player.segments.push(newSegment);
            }
        }
        function showSnakeCutEffect(position, playerKey) {
            // 创建粒子效果
            const particleCount = 5;
            const color = playerKey === 'player1' ? 0xFFA500 : 0x87CEEB;

            for (let i = 0; i < particleCount; i++) {
                const particleGeometry = new THREE.SphereGeometry(0.3, 6, 6);
                const particleMaterial = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.7
                });
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);

                particle.position.set(
                    position.x + (Math.random() - 0.5) * 2,
                    position.y + Math.random() * 1,
                    position.z + (Math.random() - 0.5) * 2
                );

                gameState.scene.add(particle);

                // 动画效果
                const velocity = {
                    x: (Math.random() - 0.5) * 3,
                    y: Math.random() * 2,
                    z: (Math.random() - 0.5) * 3
                };

                const startTime = performance.now();
                function animateParticle() {
                    const elapsed = performance.now() - startTime;
                    if (elapsed > 1000) {
                        if (particle.parent) gameState.scene.remove(particle);
                        return;
                    }

                    particle.position.x += velocity.x * 0.016;
                    particle.position.y += velocity.y * 0.016;
                    particle.position.z += velocity.z * 0.016;

                    particle.material.opacity = 0.7 * (1 - elapsed / 1000);

                    requestAnimationFrame(animateParticle);
                }
                animateParticle();
            }
        }
        // 使用魔法球
    function useMagicBall(playerKey, ballIndex) {
        const player = gameState[playerKey];
        if (ballIndex < 0 || ballIndex >= player.magicBalls.length) return;

        const ballType = player.magicBalls[ballIndex];

        // 移除魔法球
        player.magicBalls.splice(ballIndex, 1);
        updateMagicBallsDisplay(playerKey);

        // 应用效果
        switch (ballType) {
            case 'invincible':
                player.isInvincible = true;
                player.invincibleTime = player.type === 'magic' ? 15 : 10;
                break;

            case 'health':
                player.hp += 5;
                if (player.hp > player.maxHp) player.hp = player.maxHp;
                break;

            case 'reverse':
                const otherPlayerKey = playerKey === 'player1' ? 'player2' : 'player1';
                const otherPlayer = gameState[otherPlayerKey];
                otherPlayer.isReversed = true;
                otherPlayer.reversedTime = otherPlayer.type === 'magic' ? 12 : 8;
                break;

            case 'attack':
                player.isAttacking = true;
                player.attackTime = player.type === 'magic' ? 30 : 20;
                break;

            case 'bomb':
                // 创建爆炸效果
                createExplosion(player.position.x, player.position.y, player.position.z);

                // 爆炸半径
                const explosionRadius = 10;

                // 对所有玩家和基地造成伤害
                const allTargets = ['player1', 'player2'];

                allTargets.forEach(targetKey => {
                    const target = gameState[targetKey];

                    // 跳过自己（如果炸弹不伤害自己）
                    if (targetKey === playerKey) return;

                    // 计算到爆炸中心的距离
                    const distance = Math.sqrt(
                        Math.pow(target.position.x - player.position.x, 2) +
                        Math.pow(target.position.z - player.position.z, 2)
                    );

                    // 对玩家造成伤害
                    if (distance < explosionRadius) {
                        let damage = 0;
                        if (distance < 3) damage = 5;
                        else if (distance < 6) damage = 2;
                        else if (distance < 10) damage = 1;

                        if (damage > 0) {
                            applyDamage(targetKey, damage, 'bomb');
                            showDamageEffect(targetKey);
                        }
                    }

                    // 对基地造成伤害
                    const distanceToBase = Math.sqrt(
                        Math.pow(target.basePosition.x - player.position.x, 2) +
                        Math.pow(target.basePosition.z - player.position.z, 2)
                    );

                    // 如果爆炸在基地30格范围内
                    if (distanceToBase < 30) {
                        let baseDamage = 0;
                        if (distanceToBase < 10) baseDamage = 10;
                        else if (distanceToBase < 20) baseDamage = 5;
                        else if (distanceToBase < 30) baseDamage = 2;

                        if (baseDamage > 0) {
                            target.baseHp -= baseDamage;
                            if (target.baseHp < 0) target.baseHp = 0;

                            // 显示基地被攻击效果
                            showBaseDamageEffect(target.basePosition);

                            // 检查基地是否被摧毁
                            if (target.baseHp <= 0 && target.baseObject) {
                                destroyBase(targetKey);
                            }
                        }
                    }
                });

                // 对自己添加轻微反冲效果
                const pushBack = 2;
                player.position.x += player.direction.x * -pushBack;
                player.position.z += player.direction.z * -pushBack;
                break;
        }

        // 更新状态显示
        updatePlayerStatusDisplay(playerKey);
    }

    function updatePlayerStatus(playerKey, deltaTime) {
        const player = gameState[playerKey];

        // 更新无敌状态时间
        if (player.isInvincible && player.invincibleTime > 0) {
            player.invincibleTime -= deltaTime;
            if (player.invincibleTime <= 0) {
                player.isInvincible = false;
                player.invincibleTime = 0;
            }
        }

        // 更新反向状态时间
        if (player.isReversed && player.reversedTime > 0) {
            player.reversedTime -= deltaTime;
            if (player.reversedTime <= 0) {
                player.isReversed = false;
                player.reversedTime = 0;
            }
        }

        // 更新攻击状态时间
        if (player.isAttacking && player.attackTime > 0) {
            player.attackTime -= deltaTime;
            // 攻击状态下的自动射击
            player.lastAttackTime = (player.lastAttackTime || 0) + deltaTime;
            if (player.lastAttackTime >= 0.4) { // 每0.4秒射击一次
                player.lastAttackTime = 0;
                shootBullet(playerKey);
            }
            if (player.attackTime <= 0) {
                player.isAttacking = false;
                player.attackTime = 0;
            }
        }

        // 魔法蛇自动生成魔法球
        if (player.type === 'magic') {
            player.lastMagicGenerateTime = (player.lastMagicGenerateTime || 0) + deltaTime;
            if (player.lastMagicGenerateTime >= 20) {
                player.lastMagicGenerateTime = 0;
                generateRandomMagicBall(playerKey);
            }
        }

        // 更新俯冲状态
        if (player.isDashing && player.dashDuration > 0) {
            player.dashDuration -= deltaTime;
            if (player.dashDuration <= 0) {
                player.isDashing = false;
                player.dashDuration = 0;
            }
        }

        // 更新状态显示
        updatePlayerStatusDisplay(playerKey);
    }
        // 创建爆炸效果
        function createExplosion(x, y, z) {
            const explosionGroup = new THREE.Group();

            // 爆炸球体
            const explosionGeometry = new THREE.SphereGeometry(3, 16, 16);
            const explosionMaterial = new THREE.MeshStandardMaterial({
                color: 0xFF8C00,
                emissive: 0xFF8C00,
                emissiveIntensity: 0.8,
                transparent: true,
                opacity: 0.7
            });
            const explosion = new THREE.Mesh(explosionGeometry, explosionMaterial);
            explosionGroup.add(explosion);

            explosionGroup.position.set(x, y, z);
            explosionGroup.userData = { lifeTime: 1 };
            gameState.explosions.push(explosionGroup);
            gameState.scene.add(explosionGroup);
        }

        // 检查游戏结束
        function checkGameEnd() {
            if (gameState.player1.hp <= 0 || gameState.player2.hp <= 0) {
                endGame();
            }
        }

        // 结束游戏
        function endGame() {
            gameState.running = false;
            gameOverScreen.style.display = 'flex';
            startButton.textContent = '开始游戏';
            startButton.disabled = false;

            // 确定获胜者
            let winner;
            if (gameState.player1.hp > 0 && gameState.player2.hp <= 0) {
                winner = '玩家1';
                winnerText.textContent = '玩家1 获胜！';
                winnerText.style.color = '#FF7F00';
            } else if (gameState.player2.hp > 0 && gameState.player1.hp <= 0) {
                winner = '玩家2';
                winnerText.textContent = '玩家2 获胜！';
                winnerText.style.color = '#4169E1';
            } else {
                winner = null;
                winnerText.textContent = '平局！';
                winnerText.style.color = '#FFD700';
            }

            // 显示统计数据
            displayStats();

            // 隐藏一些UI，让结果界面更清晰
            document.querySelectorAll('.player-panel, .base-info, .score-display').forEach(el => {
                el.style.opacity = '0.3';
            });
        }

        // 显示统计数据
        function displayStats() {
            const stats = `
                <div class="stat-item">
                    <span>游戏时长:</span>
                    <span>${Math.floor(gameState.gameTime)}秒</span>
                </div>
                <div class="stat-item">
                    <span>玩家1分数:</span>
                    <span>${gameState.player1.score}</span>
                </div>
                <div class="stat-item">
                    <span>玩家2分数:</span>
                    <span>${gameState.player2.score}</span>
                </div>
                <div class="stat-item">
                    <span>玩家1剩余生命:</span>
                    <span>${gameState.player1.hp.toFixed(1)}</span>
                </div>
                <div class="stat-item">
                    <span>玩家2剩余生命:</span>
                    <span>${gameState.player2.hp.toFixed(1)}</span>
                </div>
                <div class="stat-item">
                    <span>玩家1基地生命:</span>
                    <span>${gameState.player1.baseHp.toFixed(1)}</span>
                </div>
                <div class="stat-item">
                    <span>玩家2基地生命:</span>
                    <span>${gameState.player2.baseHp.toFixed(1)}</span>
                </div>
            `;

            statsContainer.innerHTML = stats;
        }

        // 更新UI
    function updateUI() {
        // 更新玩家1信息
        player1HealthElement.textContent = gameState.player1.hp.toFixed(1);
        player1MaxHealthElement.textContent = gameState.player1.maxHp;
        player1HealthBar.style.width = `${(gameState.player1.hp / gameState.player1.maxHp) * 100}%`;
        player1ShieldElement.textContent = gameState.player1.shield;
        player1ScoreElement.textContent = gameState.player1.score;

        // 更新玩家2信息
        player2HealthElement.textContent = gameState.player2.hp.toFixed(1);
        player2MaxHealthElement.textContent = gameState.player2.maxHp;
        player2HealthBar.style.width = `${(gameState.player2.hp / gameState.player2.maxHp) * 100}%`;
        player2ShieldElement.textContent = gameState.player2.shield;
        player2ScoreElement.textContent = gameState.player2.score;

        // 更新基地血量显示（在UI栏中）
        base1HpElement.textContent = Math.max(0, Math.floor(gameState.player1.baseHp));
        base1HealthBar.style.width = `${(gameState.player1.baseHp / 50) * 100}%`;
        base2HpElement.textContent = Math.max(0, Math.floor(gameState.player2.baseHp));
        base2HealthBar.style.width = `${(gameState.player2.baseHp / 50) * 100}%`;

        // 如果基地被摧毁，显示特殊状态
        if (gameState.player1.baseHp <= 0) {
            base1HpElement.textContent = "已摧毁";
            base1HealthBar.style.background = '#808080';
        }

        if (gameState.player2.baseHp <= 0) {
            base2HpElement.textContent = "已摧毁";
            base2HealthBar.style.background = '#808080';
        }

        // 更新无敌视觉效果
        updatePlayerStatusDisplay('player1');
        updatePlayerStatusDisplay('player2');

        // 更新魔法球显示（在状态栏中）
        updateMagicBallsDisplay('player1');
        updateMagicBallsDisplay('player2');
    }
        // 更新魔法球显示
    function updateMagicBallsDisplay(playerKey) {
        const player = gameState[playerKey];
        const ballsElement = document.getElementById(`${playerKey}-balls`);

        if (!ballsElement) return;

        ballsElement.innerHTML = '';

        player.magicBalls.forEach((ballType, index) => {
            const ballSlot = document.createElement('div');
            ballSlot.className = `ball-slot ${ballType}`;

            // 设置缩写
            let abbreviation;
            switch (ballType) {
                case 'invincible': abbreviation = '无'; break;
                case 'health': abbreviation = '血'; break;
                case 'reverse': abbreviation = '反'; break;
                case 'attack': abbreviation = '攻'; break;
                case 'bomb': abbreviation = '爆'; break;
                default: abbreviation = '?';
            }

            ballSlot.textContent = abbreviation;
            ballSlot.title = getBallDescription(ballType);

            // 添加点击事件
            ballSlot.style.cursor = 'pointer';
            ballSlot.onclick = () => useMagicBall(playerKey, index);

            ballsElement.appendChild(ballSlot);
        });

        // 添加空槽位
        for (let i = player.magicBalls.length; i < 5; i++) {
            const emptySlot = document.createElement('div');
            emptySlot.className = 'ball-slot';
            emptySlot.textContent = '';
            ballsElement.appendChild(emptySlot);
        }
    }
        // 获取魔法球描述
        function getBallDescription(ballType) {
            switch (ballType) {
                case 'invincible': return '无敌球：一段时间内免疫所有伤害';
                case 'health': return '血球：恢复5点生命值';
                case 'reverse': return '反转球：使对手控制反向';
                case 'attack': return '攻击球：激活自动攻击模式';
                case 'bomb': return '炸弹球：触发范围爆炸';
                default: return '未知魔法球';
            }
        }

    function openShop(playerKey) {
        const player = gameState[playerKey];
        const shop = shopState[playerKey];
        const shopOverlay = playerKey === 'player1' ? shop1Overlay : shop2Overlay;

        if (!shopOverlay) {
            console.error(`商店覆盖层未找到: ${playerKey}`);
            return;
        }

        console.log(`打开 ${playerKey} 的商店`);

        // 允许同时打开两个商店，不检查其他商店状态

        // 记录玩家是否手动暂停
        const wasManuallyPaused = player.paused;

        // 暂停玩家（如果之前不是手动暂停的）
        if (!wasManuallyPaused) {
            player.paused = true;
            player.wasPausedForShop = true;
            updatePauseStatus(playerKey);
        } else {
            player.wasManuallyPaused = true;
        }

        // 更新商店状态
        shop.open = true;
        shop.selectedIndex = 0;

        // 显示商店
        shopOverlay.style.display = 'flex';

        // 渲染商店项目
        renderShopItems(playerKey);

        // 更新选中的项目
        updateShopSelection(playerKey);
    }
    function closeShop(playerKey) {
        const player = gameState[playerKey];
        const shop = shopState[playerKey];
        const shopOverlay = playerKey === 'player1' ? shop1Overlay : shop2Overlay;

        if (!shopOverlay) return;

        console.log(`关闭 ${playerKey} 的商店`);

        // 隐藏商店
        shopOverlay.style.display = 'none';
        shop.open = false;

        // 如果是因为商店暂停的，且不是手动暂停的，恢复游戏
        if (player.wasPausedForShop && !player.wasManuallyPaused) {
            player.paused = false;
            delete player.wasPausedForShop;
            updatePauseStatus(playerKey);
        }

        // 清除手动暂停标记
        if (player.wasManuallyPaused) {
            delete player.wasManuallyPaused;
        }
    }
    function renderShopItems(playerKey) {
        const shop = shopState[playerKey];
        const shopId = playerKey === 'player1' ? 'shop1-overlay' : 'shop2-overlay';
        const shopItemsElement = document.querySelector(`#${shopId} .shop-items`);

        if (!shopItemsElement) {
            console.error(`商店项目容器未找到: #${shopId} .shop-items`);
            return;
        }

        shopItemsElement.innerHTML = '';

        // 添加商店标题
        const shopTitle = document.createElement('div');
        shopTitle.className = 'shop-title';
        shopTitle.style.cssText = `
        color: ${playerKey === 'player1' ? '#FF7F00' : '#4169E1'};
        font-size: 1.5rem;
        text-align: center;
        margin-bottom: 20px;
        text-shadow: 0 0 10px currentColor;
    `;
        shopTitle.textContent = `${playerKey === 'player1' ? '玩家1' : '玩家2'}商店`;
        shopItemsElement.appendChild(shopTitle);

        // 渲染商店项目
        shop.items.forEach((item, index) => {
            const shopItem = document.createElement('div');
            shopItem.className = 'shop-item';
            shopItem.dataset.item = item.id;
            shopItem.dataset.index = index;

            // 根据玩家设置不同颜色
            const playerColor = playerKey === 'player1' ? '#FF7F00' : '#4169E1';

            shopItem.innerHTML = `
            <div class="item-name" style="color: ${playerColor}">${item.name}</div>
            <div class="item-desc" style="color: #CCCCCC; font-size: 0.9rem; margin: 5px 0;">${item.desc}</div>
            <div class="item-price" style="color: #87CEEB; font-weight: bold;">价格: ${item.price}分</div>
        `;

            shopItemsElement.appendChild(shopItem);
        });

        // 添加控制提示
        const hint = document.createElement('div');
        hint.className = 'shop-hint';
        hint.style.cssText = `
        text-align: center;
        margin-top: 20px;
        color: #AAAAAA;
        font-size: 0.9rem;
        padding: 10px;
        background: rgba(0, 0, 0, 0.5);
        border-radius: 5px;
        border: 1px solid rgba(255, 255, 255, 0.2);
    `;

        if (playerKey === 'player1') {
            hint.innerHTML = `
            <div>控制: <span style="color: #FFD700">WASD</span> 选择</div>
            <div><span style="color: #00FF00">R</span> 购买 | <span style="color: #FF4444">E</span> 退出</div>
        `;
        } else {
            hint.innerHTML = `
            <div>控制: <span style="color: #FFD700">方向键</span> 选择</div>
            <div><span style="color: #00FF00">Enter</span> 购买 | <span style="color: #FF4444">+</span> 退出</div>
        `;
        }

        shopItemsElement.appendChild(hint);

        // 初始选中第一个项目
        updateShopSelection(playerKey);
    }

    // 7. 添加商店选择更新函数
    function updateShopSelection(playerKey) {
        const shop = shopState[playerKey];
        const shopId = playerKey === 'player1' ? 'shop1-overlay' : 'shop2-overlay';
        const shopItems = document.querySelectorAll(`#${shopId} .shop-item`);

        console.log(`更新商店选择: ${playerKey}, 选中索引: ${shop.selectedIndex}, 总项目数: ${shopItems.length}`);

        shopItems.forEach((item, index) => {
            if (index === shop.selectedIndex) {
                item.classList.add('selected');

                // 添加滚动到可见区域
                item.scrollIntoView({
                    behavior: 'smooth',
                    block: 'center',
                    inline: 'nearest'
                });
            } else {
                item.classList.remove('selected');
            }
        });
    }
    function handleShopControls(playerKey) {
        const shop = shopState[playerKey];
        if (!shop.open) return;

        const items = shop.items;
        let selectionChanged = false;

        // 调试信息
        console.log(`Handling shop controls for ${playerKey}`);
        console.log(`Player1 shop open: ${shopState.player1.open}, Player2 shop open: ${shopState.player2.open}`);

        // 玩家1商店控制
        if (playerKey === 'player1') {
            console.log(`Player1 keys - w:${gameState.keys['w']}, s:${gameState.keys['s']}, r:${gameState.keys['r']}`);

            if (gameState.keys['w'] || gameState.keys['W']) {
                console.log("Player1 shop: W pressed");
                shop.selectedIndex = Math.max(0, shop.selectedIndex - 1);
                selectionChanged = true;
                // 不清除按键状态，让update函数继续处理
            }
            if (gameState.keys['s'] || gameState.keys['S']) {
                console.log("Player1 shop: S pressed");
                shop.selectedIndex = Math.min(items.length - 1, shop.selectedIndex + 1);
                selectionChanged = true;
                // 不清除按键状态，让update函数继续处理
            }
            if (gameState.keys['r'] || gameState.keys['R']) {
                console.log("Player1 shop: R pressed");
                // 购买选中的物品
                const selectedItem = items[shop.selectedIndex];
                if (selectedItem) {
                    console.log(`Player1 buying: ${selectedItem.name}`);
                    buyItem(playerKey, selectedItem.id);
                }
                // 不清除按键状态
            }
        }
        // 玩家2商店控制
        else if (playerKey === 'player2') {
            console.log(`Player2 keys - ArrowUp:${gameState.keys['ArrowUp']}, ArrowDown:${gameState.keys['ArrowDown']}, Enter:${gameState.keys['Enter']}`);

            if (gameState.keys['ArrowUp']) {
                console.log("Player2 shop: ArrowUp pressed");
                shop.selectedIndex = Math.max(0, shop.selectedIndex - 1);
                selectionChanged = true;
                // 不清除按键状态
            }
            if (gameState.keys['ArrowDown']) {
                console.log("Player2 shop: ArrowDown pressed");
                shop.selectedIndex = Math.min(items.length - 1, shop.selectedIndex + 1);
                selectionChanged = true;
                // 不清除按键状态
            }
            if (gameState.keys['Enter']) {
                console.log("Player2 shop: Enter pressed");
                // 购买选中的物品
                const selectedItem = items[shop.selectedIndex];
                if (selectedItem) {
                    console.log(`Player2 buying: ${selectedItem.name}`);
                    buyItem(playerKey, selectedItem.id);
                }
                // 不清除按键状态
            }
        }

        if (selectionChanged) {
            console.log(`Shop selection changed for ${playerKey} to index: ${shop.selectedIndex}`);
            updateShopSelection(playerKey);
        }
    }

        // 购买物品
        function buyItem(playerKey, item) {
            const player = gameState[playerKey];

            switch (item) {
                case 'shield':
                    if (player.score >= 400 && player.shield === 0) {
                        player.score -= 400;
                        player.shield = 10;
                    }
                    break;

                case 'magic-pack':
                    if (player.score >= 400) {
                        player.score -= 400;
                        for (let i = 0; i < 3 && player.magicBalls.length < 5; i++) {
                            const ballTypes = ['invincible', 'health', 'reverse', 'attack', 'bomb'];
                            const type = ballTypes[Math.floor(Math.random() * ballTypes.length)];
                            player.magicBalls.push(type);
                        }
                        updateMagicBallsDisplay(playerKey);
                    }
                    break;

                case 'speed-upgrade':
                    if (player.score >= 500) {
                        player.score -= 500;
                        player.speedMultiplier *= 1.15;
                    }
                    break;

                case 'hard-upgrade':
                    if (player.score >= 500 && player.hardUpgrades < 3) { // 增加升级次数
                        player.score -= 500;
                        player.hardUpgrades++;
                        // 坚硬蛇增加3点，其他蛇增加2点
                        const hpIncrease = player.type === 'hard' ? 3 : 2;
                        player.maxHp += hpIncrease;
                        player.hp += hpIncrease;
                    }
                    break;

                case 'magic-upgrade':
                    if (player.score >= 500 && player.magicUpgrades < 2) {
                        player.score -= 500;
                        player.magicUpgrades++;
                    }
                    break;
            }

            // 关闭商店
            closeShop(playerKey);
        }

        // 动画循环
        function animate() {
            requestAnimationFrame(animate);
            update();
        }
    function togglePlayerPause(playerKey) {
        if (!gameState.running) return;

        const player = gameState[playerKey];
        player.paused = !player.paused;
        player.wasManuallyPaused = player.paused; // 记录手动暂停状态

        updatePauseStatus(playerKey);
        checkAllPlayersPaused();
    }

        // 更新暂停状态显示
        function updatePauseStatus(playerKey) {
            const player = gameState[playerKey];

            if (player.paused) {
                // 在蛇上方显示暂停图标
                showPauseIndicator(playerKey);
            }
            else{
                // 移除暂停图标
                removePauseIndicator(playerKey);
            }
        }

        // 显示暂停指示器
        function showPauseIndicator(playerKey) {
            const player = gameState[playerKey];

            // 创建暂停图标
            const pauseGeometry = new THREE.BoxGeometry(3, 3, 0.5);
            const pauseMaterial = new THREE.MeshBasicMaterial({
                color: 0xFF0000,
                transparent: true,
                opacity: 0.7
            });
            const pauseIndicator = new THREE.Mesh(pauseGeometry, pauseMaterial);

            // 放在蛇上方
            pauseIndicator.position.set(
                player.position.x,
                player.position.y + 5,
                player.position.z
            );
            pauseIndicator.userData = { type: 'pauseIndicator', player: playerKey };

            gameState.scene.add(pauseIndicator);
            player.pauseIndicator = pauseIndicator;
        }

        // 移除暂停指示器
        function removePauseIndicator(playerKey) {
            const player = gameState[playerKey];
            if (player.pauseIndicator) {
                gameState.scene.remove(player.pauseIndicator);
                player.pauseIndicator = null;
            }
        }

        // 检查是否所有玩家都暂停了
        function checkAllPlayersPaused() {
            const player1Paused = gameState.player1.paused;
            const player2Paused = gameState.player2.paused;

            // 如果两个玩家都暂停了，整体游戏暂停
            gameState.paused = player1Paused && player2Paused;

            if (gameState.paused) {
                // 显示整体暂停提示
            } else {
            }
        }
        // 事件处理
    document.addEventListener('keydown', (e) => {
        const relevantKeys = [
            'w', 'W', 'a', 'A', 's', 'S', 'd', 'D',
            'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight',
            'e', 'E', '+', 'r', 'R', 'Enter',
            '1', '2', '3', '4', '5', '6', '7', '8', '9', '0',
            ' ', 'q', 'Q', '/', '?',
            'Numpad6', 'Numpad7', 'Numpad8', 'Numpad9', 'Numpad0'
        ];

        if (!relevantKeys.includes(e.key)) return;

        // 设置按键状态（永远设置，供所有系统使用）
        gameState.keys[e.key] = true;

        // 防止方向键滚动页面
        if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'w', 'W', 'a', 'A', 's', 'S', 'd', 'D', ' '].includes(e.key)) {
            e.preventDefault();
        }

        // === 1. 先处理特殊功能键（无论什么状态都处理）===

        // 玩家1暂停/继续：Q 键
        if ((e.key === 'q' || e.key === 'Q') && gameState.running) {
            togglePlayerPause('player1');
            e.preventDefault();
            return;
        }

        // 玩家2暂停/继续：/ 或 ? 键
        if ((e.key === '/' || e.key === '?') && gameState.running) {
            togglePlayerPause('player2');
            e.preventDefault();
            return;
        }

        // === 2. 处理商店开关（独立处理，不阻止其他按键）===

        // 玩家1商店开关：E键
        if ((e.key === 'e' || e.key === 'E') && gameState.running) {
            e.preventDefault();
            if (shopState.player1.open) {
                closeShop('player1');
            } else {
                openShop('player1');
            }
            // 注意：这里不return，让其他按键也能处理
        }

        // 玩家2商店开关：+键
        if (e.key === '+' && gameState.running) {
            e.preventDefault();
            if (shopState.player2.open) {
                closeShop('player2');
            } else {
                openShop('player2');
            }
            // 注意：这里不return，让其他按键也能处理
        }

        // === 3. 魔法球使用（无论商店状态都处理）===
        if (gameState.running) {
            e.preventDefault(); // 为魔法球按键添加preventDefault

            // 玩家1魔法球（数字键1-5）
            if (e.key >= '1' && e.key <= '5') {
                const index = parseInt(e.key) - 1;
                useMagicBall('player1', index);
                return;
            }

            // 玩家2魔法球（数字键6-0或小键盘）
            if (e.key === '6' || e.key === 'Numpad6') {
                useMagicBall('player2', 0);
                return;
            } else if (e.key === '7' || e.key === 'Numpad7') {
                useMagicBall('player2', 1);
                return;
            } else if (e.key === '8' || e.key === 'Numpad8') {
                useMagicBall('player2', 2);
                return;
            } else if (e.key === '9' || e.key === 'Numpad9') {
                useMagicBall('player2', 3);
                return;
            } else if (e.key === '0' || e.key === 'Numpad0') {
                useMagicBall('player2', 4);
                return;
            }
        }

        // === 4. 其他游戏控制（只在商店关闭时处理）===
        if (!shopState.player1.open && !shopState.player2.open) {
            // 速度蛇俯冲
            if (e.key === ' ') {
                checkSpeedSnakeDash('player1');
                e.preventDefault();
            }
        }
    }); 

        document.addEventListener('keyup', (e) => {
            // 只处理游戏相关按键
            const relevantKeys = [
                'w', 'W', 'a', 'A', 's', 'S', 'd', 'D',
                'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'
            ];

            if (relevantKeys.includes(e.key)) {
                gameState.keys[e.key] = false;
            }
        });

        document.addEventListener('keyup', (e) => {
            gameState.keys[e.key] = false;
        });

        window.addEventListener('resize', () => {
            const width = window.innerWidth;
            const height = window.innerHeight;

            // 更新玩家1相机和渲染器
            gameState.player1.camera.aspect = (width / 2) / height;
            gameState.player1.camera.updateProjectionMatrix();
            gameState.player1.renderer.setSize(width / 2, height);

            // 更新玩家2相机和渲染器
            gameState.player2.camera.aspect = (width / 2) / height;
            gameState.player2.camera.updateProjectionMatrix();
            gameState.player2.renderer.setSize(width / 2, height);
        });

        startButton.addEventListener('click', () => {
            if (!gameState.running) {
                gameState.running = true;
                startButton.textContent = '游戏中';
                startButton.disabled = true;
                clock.start();
            }
        });

        resetButton.addEventListener('click', () => {
            initGame();
        });

        mapButton.addEventListener('click', () => {
            const maps = ['classic', 'snow', 'volcano'];
            const currentIndex = maps.indexOf(gameState.mapType);
            gameState.mapType = maps[(currentIndex + 1) % maps.length];
            mapButton.textContent = `地图: ${gameState.mapType === 'classic' ? '经典' :
                gameState.mapType === 'snow' ? '雪山' : '火山'}`;
            initGame();
        });

        playAgainButton.addEventListener('click', () => {
            initGame();
            gameState.running = true;
            startButton.textContent = '游戏中';
            startButton.disabled = true;
            clock.start();
        });

        // 加载Three.js并初始化
        function loadThreeJS() {
            if (typeof THREE === 'undefined') {
                const script = document.createElement('script');
                script.src = 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js';
                script.onload = initScene;
                document.head.appendChild(script);
            } else {
                initScene();
            }
        }

        // 初始化魔法球显示
        setTimeout(() => {
            updateMagicBallsDisplay('player1');
            updateMagicBallsDisplay('player2');
        }, 100);

        loadThreeJS();
    </script>
</body>

</html>