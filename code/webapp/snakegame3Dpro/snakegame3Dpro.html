<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="/config/serverUrl.js"></script>
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="/css/styles_button.css">
    <script src="/js/script4_goBackOrHome.js"></script>
    <script src="/js/script13_checkIslogin.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/sweetalert/1.1.3/sweetalert.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sweetalert/1.1.3/sweetalert.min.js"></script>
    <link href="/css/message.min.css" rel="stylesheet" />
    <script src="/js/message.min.js"></script>
    <title>3Dç¬¬ä¸€è§†è§’è´ªåƒè›‡å¤§ä½œæˆ˜</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #0a0a2a, #1a1a3a);
            color: white;
            overflow: hidden;
            height: 100vh;
        }

        #game-container {
            width: 100%;
            height: 100vh;
            position: relative;
        }

        /* åˆ†å±å®¹å™¨ */
        .split-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
        }

        .split-left {
            width: 50%;
            height: 100%;
            overflow: hidden;
            position: relative;
            border-right: 2px solid rgba(255, 255, 255, 0.3);
        }

        .split-right {
            width: 50%;
            height: 100%;
            overflow: hidden;
            position: relative;
        }

        .player-viewport {
            width: 100%;
            height: 100%;
            position: relative;
            /* ç§»é™¤æˆ–è°ƒæ•´èƒŒæ™¯è‰² */
            background: rgba(0, 0, 0, 0.3);
            /* åŠé€æ˜é»‘è‰²ï¼Œè®©è§†é‡æ›´æ¸…æ™° */
        }

        .player-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* UIè¦†ç›–å±‚ */
        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }

        /* ç©å®¶ä¿¡æ¯é¢æ¿ */
        .player-panel {
            position: absolute;
            top: 10px;
            width: 250px;
            background: rgba(0, 0, 0, 0.8);
            padding: 12px;
            border-radius: 8px;
            border: 2px solid;
            pointer-events: auto;
            font-size: 0.9rem;
        }

        #player1-panel {
            left: 10px;
            border-color: #FF7F00;
        }

        #player2-panel {
            right: 10px;
            border-color: #4169E1;
        }

        .player-header {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }

        .snake-type {
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: bold;
            margin-left: 8px;
            font-size: 0.8rem;
        }

        .speed-snake {
            background: #FFA500;
            color: #000;
        }

        .hard-snake {
            background: #C0C0C0;
            color: #000;
        }

        .magic-snake {
            background: #9370DB;
            color: #000;
        }

        .health-bar {
            width: 100%;
            height: 16px;
            background: #333;
            border-radius: 8px;
            overflow: hidden;
            margin: 4px 0;
        }

        .health-fill {
            height: 100%;
            transition: width 0.3s;
        }

        #player1-health {
            background: linear-gradient(to right, #FF4444, #FF7F00);
        }

        #player2-health {
            background: linear-gradient(to right, #4444FF, #4169E1);
        }

        .magic-balls {
            display: flex;
            gap: 4px;
            margin: 8px 0;
        }

        .ball-slot {
            width: 26px;
            height: 26px;
            border-radius: 50%;
            border: 2px solid #555;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            cursor: pointer;
            pointer-events: auto;
        }

        .invincible {
            background: #FFFF00;
            color: #000;
        }

        .health {
            background: #FF0000;
            color: #FFF;
        }

        .reverse {
            background: #800080;
            color: #FFF;
        }

        .attack {
            background: #87CEEB;
            color: #000;
        }

        .bomb {
            background: #FF8C00;
            color: #000;
        }

        /* æ¸¸æˆæ§åˆ¶æŒ‰é’® */
        .game-controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 12px;
            pointer-events: auto;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 8px;
        }

        button {
            background: linear-gradient(to bottom, #4444FF, #2222AA);
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 0.9rem;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
            pointer-events: auto;
        }

        button:hover {
            background: linear-gradient(to bottom, #5555FF, #3333BB);
            transform: translateY(-2px);
        }

        #start-btn {
            background: linear-gradient(to bottom, #00AA00, #008800);
        }

        #start-btn:hover {
            background: linear-gradient(to bottom, #00CC00, #00AA00);
        }

        /* å•†åº—ç•Œé¢ */
        .shop-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            z-index: 200;
            pointer-events: auto;
            background: transparent !important;
            /* å®Œå…¨é€æ˜èƒŒæ™¯ */
        }

        #shop1-overlay {
            justify-content: flex-start;
            /* å·¦å¯¹é½ */
        }

        #shop2-overlay {
            justify-content: flex-end;
            /* å³å¯¹é½ */
        }

        .shop-content {
            background: transparent !important;
            /* é€æ˜èƒŒæ™¯ */
            padding: 0 !important;
            border: none !important;
            box-shadow: none !important;
            width: 30% !important;
            /* åªå å±å¹•30%å®½åº¦ */
            height: 100%;
            max-width: none !important;
        }

        #shop1-overlay .shop-content {
            margin-left: 0;
            align-items: flex-start;
        }

        #shop2-overlay .shop-content {
            margin-right: 0;
            align-items: flex-end;
        }

        .shop-title {
            text-align: center;
            font-size: 1.8rem;
            color: #FFD700;
            margin-bottom: 15px;
        }

        .shop-items {
            display: flex !important;
            flex-direction: column !important;
            /* ç«–å‘æ’åˆ— */
            gap: 15px !important;
            padding: 20px;
            background: rgba(0, 0, 0, 0);
            /* å•†åº—å†…å®¹æœ‰èƒŒæ™¯ï¼Œä½†è¦†ç›–å±‚é€æ˜ */
            border-radius: 10px;
            margin: 20px;
            width: 80%;
            max-width: 300px;
        }

        #shop1-overlay .shop-items {
            border: 3px solid #FF7F00;
            /* ç©å®¶1é¢œè‰²è¾¹æ¡† */
            background: rgba(0, 0, 0, 0);
        }

        #shop2-overlay .shop-items {
            border: 3px solid #4169E1;
            /* ç©å®¶2é¢œè‰²è¾¹æ¡† */
            background: rgba(0, 0, 0, 0);
        }

        .shop-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 12px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
            border: 2px solid transparent;
        }

        .shop-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            border: 2px solid transparent;
            display: flex;
            flex-direction: column;
            gap: 5px;
            position: relative;
        }

        .shop-item:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        .shop-item.selected {
            border-color: #FFD700;
            background: rgba(255, 215, 0, 0.2);
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
        }

        .shop-item.selected::before {
            content: 'â–¶';
            position: absolute;
            left: -25px;
            top: 50%;
            transform: translateY(-50%);
            color: #FFD700;
            font-size: 1.5rem;
            text-shadow: 0 0 5px rgba(255, 215, 0, 0.8);
            animation: pulse 1s infinite;
        }

        /* æ·»åŠ é—ªçƒåŠ¨ç”» */
        @keyframes pulse {
            0% {
                opacity: 0.5;
                transform: translateY(-50%) scale(1);
            }

            50% {
                opacity: 1;
                transform: translateY(-50%) scale(1.2);
            }

            100% {
                opacity: 0.5;
                transform: translateY(-50%) scale(1);
            }
        }

        .shop-item.selected .item-price {
            color: #FFFFFF;
            font-weight: bold;
            background: rgba(255, 215, 0, 0.3);
            padding: 2px 8px;
            border-radius: 4px;
            display: inline-block;
        }

        /* é€‰ä¸­çš„é¡¹ç›®åç§°é«˜äº® */
        .shop-item.selected .item-name {
            color: #FFFFFF;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.8);
        }

        .item-name {
            font-size: 1.1rem;
            color: #FFD700;
            margin-bottom: 4px;
        }

        .item-price {
            color: #87CEEB;
            font-weight: bold;
            font-size: 0.9rem;
        }

        .shop-hint {
            text-align: center;
            margin-top: 10px;
            color: #AAAAAA;
            font-size: 0.8rem;
        }

        /* æ¸¸æˆç»“æŸç•Œé¢ */
        .game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
            pointer-events: auto;
        }

        #winner-text {
            font-size: 2.5rem;
            margin-bottom: 15px;
            text-shadow: 0 0 10px currentColor;
        }

        .stats-container {
            border-radius: 8px;
            margin: 15px 0;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            margin: 8px 0;
        }

        .key-hint {
            display: inline-block;
            background-color: #333;
            color: white;
            padding: 4px 8px;
            margin: 0 2px;
            border-radius: 4px;
            font-family: monospace;
            border: 1px solid #666;
        }

        /* åˆ†æ•°æ˜¾ç¤º */
        .score-display {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 1.2rem;
            color: #FFD700;
            background: rgba(0, 0, 0, 0.8);
            padding: 8px 15px;
            border-radius: 6px;
        }

        /* åŸºåœ°ä¿¡æ¯ */
        .base-info {
            position: absolute;
            bottom: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 8px;
            border-radius: 6px;
            min-width: 130px;
            font-size: 0.9rem;
        }

        #player1-base {
            left: 10px;
            border: 2px solid #FF7F00;
        }

        #player2-base {
            right: 10px;
            border: 2px solid #4169E1;
        }

        .base-health {
            height: 8px;
            background: #333;
            border-radius: 4px;
            overflow: hidden;
            margin: 4px 0;
        }

        .base-health-fill {
            height: 100%;
            background: #00FF00;
        }

        /* ç¬¬ä¸€è§†è§’å‡†æ˜Ÿ */
        .crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
        }

        .crosshair::before,
        .crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.8);
        }

        .crosshair::before {
            width: 2px;
            height: 20px;
            top: 0;
            left: 9px;
        }

        .crosshair::after {
            width: 20px;
            height: 2px;
            top: 9px;
            left: 0;
        }

        .p1-crosshair {
            position: absolute;
            top: 50%;
            left: 25%;
            transform: translate(-50%, -50%);
        }

        .p2-crosshair {
            position: absolute;
            top: 50%;
            left: 75%;
            transform: translate(-50%, -50%);
        }

        /* ç¬¬ä¸€è§†è§’é•œå¤´æ™ƒåŠ¨æ•ˆæœ */

        @keyframes shake {
            0% {
                transform: translate(0, 0);
            }

            25% {
                transform: translate(-2px, 2px);
            }

            50% {
                transform: translate(2px, -2px);
            }

            75% {
                transform: translate(-2px, -2px);
            }

            100% {
                transform: translate(0, 0);
            }
        }

        /* å—ä¼¤æ•ˆæœ */
        .damage-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 0, 0, 0.3);
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }

        .p1-damage {
            left: 0;
            width: 50%;
        }

        .p2-damage {
            left: 50%;
            width: 50%;
        }

        .selection-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0a0a2a, #1a1a3a);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 300;
        }

        .selection-content {
            background: rgba(0, 0, 0, 0.8);
            padding: 30px;
            border-radius: 15px;
            width: 90%;
            max-width: 1200px;
            max-height: 90vh;
            overflow-y: auto;
            border: 3px solid #FFD700;
        }

        .player-selection,
        .map-selection {
            margin-bottom: 30px;
        }

        .player-selection h3,
        .map-selection h3 {
            color: #FFD700;
            margin-bottom: 15px;
            text-align: center;
            font-size: 1.8rem;
        }

        .snake-options,
        .map-options {
            display: flex;
            justify-content: center;
            gap: 20px;
            flex-wrap: wrap;
        }

        .snake-option,
        .map-option {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
            width: 200px;
            cursor: pointer;
            transition: all 0.3s;
            border: 2px solid transparent;
        }

        .snake-option:hover,
        .map-option:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-5px);
        }

        .snake-option.active,
        .map-option.active {
            border-color: #FFD700;
            background: rgba(255, 215, 0, 0.1);
        }

        .snake-preview {
            width: 100%;
            height: 60px;
            border-radius: 8px;
            margin-bottom: 10px;
        }

        .map-preview {
            width: 100%;
            height: 100px;
            border-radius: 8px;
            margin-bottom: 10px;
        }

        .classic-map {
            background: linear-gradient(135deg, #2E7D32, #388E3C);
        }

        .snow-map {
            background: linear-gradient(135deg, #87CEEB, #FFFFFF);
        }

        .volcano-map {
            background: linear-gradient(135deg, #FF4500, #8B4513);
        }

        .snake-option h4,
        .map-option h4 {
            color: #FFD700;
            margin-bottom: 8px;
        }

        .snake-option p,
        .map-option p {
            font-size: 0.9rem;
            margin: 3px 0;
            color: #CCCCCC;
        }

        .start-game-section {
            text-align: center;
            margin-top: 30px;
        }

        #confirm-start-btn {
            background: linear-gradient(to bottom, #00AA00, #008800);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 1.2rem;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
        }

        #confirm-start-btn:hover {
            background: linear-gradient(to bottom, #00CC00, #00AA00);
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0, 255, 0, 0.4);
        }

        /* å…¨å±æ¸¸æˆæ—¶çš„ç®€åŒ–UI */
        .game-fullscreen .player-panel {
            background: rgba(0, 0, 0, 0.6);
            padding: 8px;
            border-radius: 5px;
            width: 180px;
            font-size: 0.8rem;
        }

        .game-fullscreen .player-header {
            font-size: 0.9rem;
            margin-bottom: 5px;
        }

        .game-fullscreen .health-bar {
            height: 12px;
            margin: 3px 0;
        }

        .game-fullscreen .magic-balls {
            gap: 2px;
        }

        .game-fullscreen .ball-slot {
            width: 22px;
            height: 22px;
            font-size: 0.7rem;
        }

        .game-fullscreen .score-display {
            font-size: 1rem;
            padding: 6px 12px;
        }

        .game-fullscreen .base-info {
            padding: 6px;
            min-width: 120px;
            font-size: 0.8rem;
        }

        .game-fullscreen .game-controls {
            opacity: 0.3;
            transition: opacity 0.3s;
        }

        .game-fullscreen .game-controls:hover {
            opacity: 1;
        }
        .homepage {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0a0a2a 0%, #1a1a3a 50%, #2d1b69 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            overflow: hidden;
        }

        /* å…¥åœºåŠ¨ç”»æ•ˆæœ */
        .enter-animation {
            animation: enterFadeIn 1.5s ease-out forwards;
        }

        @keyframes enterFadeIn {
            0% {
                opacity: 0;
                transform: translateY(50px);
            }
            100% {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* æ¸¸æˆæ ‡é¢˜æ ·å¼ */
        .game-title {
            font-size: 4.5rem;
            font-weight: 900;
            text-align: center;
            margin-bottom: 20px;
            background: linear-gradient(45deg, #FF7F00, #FFD700, #4169E1, #9370DB);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
            letter-spacing: 2px;
            animation: titleGlow 3s infinite alternate;
        }

        @keyframes titleGlow {
            0% {
                text-shadow: 0 0 20px rgba(255, 127, 0, 0.5),
                            0 0 40px rgba(255, 215, 0, 0.3);
            }
            100% {
                text-shadow: 0 0 30px rgba(65, 105, 225, 0.5),
                            0 0 60px rgba(147, 112, 219, 0.3);
            }
        }

        /* å‰¯æ ‡é¢˜æ ·å¼ */
        .subtitle {
            font-size: 1.5rem;
            color: #87CEEB;
            margin-bottom: 40px;
            text-align: center;
            animation: subtitleFloat 4s infinite ease-in-out;
        }

        @keyframes subtitleFloat {
            0%, 100% {
                transform: translateY(0);
            }
            50% {
                transform: translateY(-10px);
            }
        }

        /* è§„åˆ™å¡ç‰‡æ ·å¼ */
        .rules-container {
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            width: 80%;
            max-width: 800px;
            margin: 30px auto;
            border: 2px solid rgba(255, 215, 0, 0.3);
            box-shadow: 0 0 50px rgba(255, 215, 0, 0.2);
        }

        .rules-title {
            font-size: 2rem;
            color: #FFD700;
            text-align: center;
            margin-bottom: 25px;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        .rules-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .rule-card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: transform 0.3s, border-color 0.3s;
        }

        .rule-card:hover {
            transform: translateY(-5px);
            border-color: rgba(255, 215, 0, 0.5);
        }

        .rule-card h3 {
            color: #FFA500;
            margin-bottom: 10px;
            font-size: 1.2rem;
        }

        .rule-card p {
            color: #CCCCCC;
            font-size: 0.95rem;
            line-height: 1.5;
        }

        /* æ§åˆ¶è¯´æ˜æ ·å¼ */
        .controls-section {
            margin: 30px 0;
            text-align: center;
        }

        .controls-title {
            color: #87CEEB;
            font-size: 1.5rem;
            margin-bottom: 20px;
        }

        .control-keys {
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
            margin: 20px 0;
        }

        .key-item {
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid #4169E1;
            border-radius: 8px;
            padding: 10px 15px;
            min-width: 120px;
        }

        .key-item.p1 {
            border-color: #FF7F00;
        }

        .key-item.p2 {
            border-color: #4169E1;
        }

        .key-item h4 {
            color: #FFD700;
            margin-bottom: 8px;
        }

        .key {
            display: inline-block;
            background: #333;
            color: white;
            padding: 4px 8px;
            margin: 2px;
            border-radius: 4px;
            font-family: monospace;
            border: 1px solid #666;
        }

        /* å¼€å§‹æŒ‰é’®æ ·å¼ */
        .start-home-btn {
            background: linear-gradient(45deg, #FF7F00, #FFD700);
            color: #000;
            border: none;
            padding: 18px 60px;
            font-size: 1.5rem;
            font-weight: bold;
            border-radius: 50px;
            cursor: pointer;
            margin-top: 30px;
            transition: all 0.3s;
            box-shadow: 0 10px 30px rgba(255, 127, 0, 0.4);
            position: relative;
            overflow: hidden;
        }

        .start-home-btn:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 40px rgba(255, 127, 0, 0.6);
            background: linear-gradient(45deg, #FFD700, #FF7F00);
        }

        .start-home-btn:active {
            transform: translateY(-2px);
        }

        .start-home-btn::after {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, 
                transparent 20%, 
                rgba(255, 255, 255, 0.1) 50%, 
                transparent 80%);
            animation: buttonShine 3s infinite linear;
        }

        @keyframes buttonShine {
            0% {
                transform: translateX(-100%) translateY(-100%) rotate(45deg);
            }
            100% {
                transform: translateX(100%) translateY(100%) rotate(45deg);
            }
        }

        /* èƒŒæ™¯ç²’å­æ•ˆæœ */
        .background-particles {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: -1;
        }

        .particle {
            position: absolute;
            width: 3px;
            height: 3px;
            background: rgba(255, 215, 0, 0.6);
            border-radius: 50%;
            animation: particleFloat linear infinite;
        }

        @keyframes particleFloat {
            to {
                transform: translateY(-1000px);
            }
        }

        /* è›‡å‹å±•ç¤º */
        .snake-showcase {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin: 20px 0;
        }

        .snake-type-show {
            text-align: center;
        }

        .snake-type-show h4 {
            color: #FFD700;
            margin-bottom: 10px;
        }

        .snake-preview-show {
            width: 100px;
            height: 20px;
            border-radius: 10px;
            margin: 0 auto;
        }

        /* åŠ¨ç”»å»¶è¿Ÿç±» */
        .delay-1 { animation-delay: 0.2s; }
        .delay-2 { animation-delay: 0.4s; }
        .delay-3 { animation-delay: 0.6s; }
        .delay-4 { animation-delay: 0.8s; } 
/* æ¸¸æˆç»“æŸç•Œé¢æ ·å¼ */
.game-over {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.85);
    display: flex;
    justify-content: center;
    align-items: center;
    color: white;
    z-index: 100;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.5s;
    backdrop-filter: blur(5px);
}

.game-over.show {
    opacity: 1;
    pointer-events: all;
}

.game-over-content {
    text-align: center;
    max-width: 600px;
    width: 90%;
    animation: fadeInUp 0.8s;
}

.winner-container {
    margin-bottom: 30px;
}

.trophy-icon {
    font-size: 80px;
    margin-bottom: 20px;
    animation: bounce 1s infinite alternate;
}

.winner-banner {
    font-size: 48px;
    margin-bottom: 10px;
    text-shadow: 0 0 15px currentColor;
    animation: pulse 2s infinite;
}

.stats-container {
    display: flex;
    justify-content: center;
    align-items: center;
    margin: 30px 0;
    gap: 20px;
}

.player-stats {
    flex: 1;
    padding: 20px;
    border-radius: 15px;
    background: rgba(255, 255, 255, 0.1);
    transition: transform 0.3s;
}

.player-stats:hover {
    transform: translateY(-5px);
}

.player-1-stats {
    border: 2px solid #FF5722;
    box-shadow: 0 0 15px rgba(255, 87, 34, 0.3);
}

.player-2-stats {
    border: 2px solid #2196F3;
    box-shadow: 0 0 15px rgba(33, 150, 243, 0.3);
}

.player-avatar {
    font-size: 40px;
    margin-bottom: 10px;
}

.player-name {
    font-size: 20px;
    margin-bottom: 5px;
    font-weight: bold;
}

.win-count {
    font-size: 28px;
    font-weight: bold;
    margin: 10px 0;
}

.progress-bar {
    height: 10px;
    background: rgba(255, 255, 255, 0.2);
    border-radius: 5px;
    overflow: hidden;
    margin-top: 10px;
}

.progress-fill {
    height: 100%;
    border-radius: 5px;
    transition: width 1s ease-out;
}

.vs-text {
    font-size: 24px;
    font-weight: bold;
    margin: 0 10px;
}

.buttons-container {
    display: flex;
    justify-content: center;
    gap: 20px;
    margin-top: 30px;
}

.restart-btn {
    padding: 15px 30px;
    border: none;
    border-radius: 50px;
    font-size: 18px;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s;
    display: flex;
    align-items: center;
    gap: 10px;
}

.restart-btn i {
    font-size: 20px;
}

.restart-btn:hover {
    transform: translateY(-3px);
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
}

.upload-btn {
    background: linear-gradient(45deg, #4CAF50, #8BC34A);
}

.restart-btn:not(.upload-btn) {
    background: linear-gradient(45deg, #2196F3, #00BCD4);
}

/* åº†ç¥ç²’å­æ•ˆæœ */
.celebration-particle {
    position: absolute;
    border-radius: 50%;
    pointer-events: none;
    animation: celebrate linear forwards;
    z-index: 101;
}

@keyframes celebrate {
    to {
        transform: translate(var(--tx), var(--ty));
        opacity: 0;
    }
}

@keyframes fadeInUp {
    from {
        opacity: 0;
        transform: translateY(50px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

@keyframes bounce {
    to {
        transform: translateY(-20px);
    }
}

@keyframes pulse {
    0%, 100% {
        transform: scale(1);
    }
    50% {
        transform: scale(1.1);
    }
}
/* æ¸¸æˆç»“æŸæ¶ˆæ¯æ ·å¼ */
.game-over-message {
    margin: 15px 0;
    padding: 10px;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 5px;
    text-align: center;
    font-weight: bold;
    transition: opacity 0.5s;
}

/* å½“å‰èƒœåˆ©æ¬¡æ•°æç¤º */
.win-count .current-win {
    color: #4CAF50;
    font-weight: bold;
    margin-left: 5px;
    animation: pulse 1s infinite;
}

/* èƒœåˆ©æ¬¡æ•°æ ·å¼ */
.win-count {
    font-size: 28px;
    font-weight: bold;
    margin: 10px 0;
    display: flex;
    align-items: center;
    justify-content: center;
}

.history-wins {
    color: white;
}

@keyframes pulse {
    0%, 100% {
        transform: scale(1);
    }
    50% {
        transform: scale(1.2);
    }
}
        /* æˆ˜ç»©æŸ¥è¯¢æ¨¡æ€æ¡† */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 2000;
            overflow-y: auto;
        }

        .modal-content {
            background: linear-gradient(135deg, #0a0a2a, #1a1a3a);
            margin: 50px auto;
            padding: 20px;
            border-radius: 15px;
            width: 90%;
            max-width: 900px;
            max-height: 80vh;
            overflow-y: auto;
            border: 3px solid #FFD700;
            box-shadow: 0 0 50px rgba(255, 215, 0, 0.3);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #FFD700;
        }

        .modal-title {
            font-size: 1.8rem;
            color: #FFD700;
        }

        .close-modal {
            background: none;
            border: none;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 5px 10px;
            border-radius: 5px;
            transition: background 0.3s;
        }

        .close-modal:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .search-box {
            margin-bottom: 20px;
            display: flex;
            gap: 10px;
        }

        .search-box input {
            flex: 1;
            padding: 10px;
            border-radius: 8px;
            border: 2px solid #FFD700;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            font-size: 1rem;
        }

        .search-box button {
            background: linear-gradient(to bottom, #FF7F00, #FF5722);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .search-box button:hover {
            transform: translateY(-2px);
        }

        .records-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 15px;
        }

        .record-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(255, 215, 0, 0.3);
            transition: transform 0.3s;
        }

        .record-item:hover {
            transform: translateY(-5px);
            border-color: #FFD700;
        }

        .record-username {
            font-size: 1.2rem;
            font-weight: bold;
            color: #FFD700;
            margin-bottom: 10px;
        }

        .record-stats {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
        }

        .record-stat {
            font-size: 0.9rem;
            color: #87CEEB;
        }

        .record-match {
            background: rgba(0, 0, 0, 0.3);
            padding: 8px;
            border-radius: 5px;
            margin-top: 8px;
            font-size: 0.9rem;
        }

        .record-match-opponent {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 5px;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #FFD700;
            font-size: 1.2rem;
        }

        .error {
            text-align: center;
            padding: 40px;
            color: #FF4444;
            font-size: 1.2rem;
        }

        .no-data {
            text-align: center;
            padding: 40px;
            color: #888;
            font-size: 1.2rem;
        }

        /* ä¸»é¡µæ–°å¢æˆ˜ç»©æŸ¥è¯¢æŒ‰é’® */
        .view-records-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            background: linear-gradient(45deg, #4169E1, #9370DB);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 25px;
            cursor: pointer;
            z-index: 1001;
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: bold;
            box-shadow: 0 5px 15px rgba(65, 105, 225, 0.3);
            transition: all 0.3s;
        }

        .view-records-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(65, 105, 225, 0.5);
        }               
    </style>
</head>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<body>
        <button class="view-records-btn" id="view-records">
            <i class="fas fa-trophy"></i> æˆ˜ç»©æŸ¥è¯¢
        </button>
<!-- æ•°æ®ç»Ÿè®¡æ¨¡æ€æ¡† -->
<div id="game-stats-modal" class="modal">
    <div class="modal-content" style="max-width: 700px;">
        <div class="modal-header">
            <h2 class="modal-title">æœ¬å±€è¯¦ç»†æ•°æ®ç»Ÿè®¡</h2>
            <button class="close-modal" data-modal="game-stats-modal">&times;</button>
        </div>
        <div class="stats-details" id="stats-details">
            <!-- æ•°æ®ç»Ÿè®¡å†…å®¹ä¼šåŠ¨æ€ç”Ÿæˆ -->
        </div>
    </div>
</div>        
        <!-- æˆ˜ç»©æŸ¥è¯¢æ¨¡æ€æ¡† -->
        <div id="records-modal" class="modal">
            <div class="modal-content">
                <div class="modal-header">
                    <h2 class="modal-title">æ’è¡Œæ¦œ & æˆ˜ç»©æŸ¥è¯¢</h2>
                    <button class="close-modal">&times;</button>
                </div>
                <div class="search-box">
                    <input type="text" id="search-username" placeholder="æœç´¢ç”¨æˆ·å...">
                    <button id="refresh-records"><i class="fas fa-sync-alt"></i> åˆ·æ–°</button>
                </div>
                <div id="records-container"></div>
            </div>
        </div>
        <div class="homepage" id="homepage">
            <div class="background-particles" id="particles"></div>
        
            <div class="enter-animation">
                <h1 class="game-title">3Dç¬¬ä¸€è§†è§’è´ªåƒè›‡å¤§ä½œæˆ˜</h1>
                <div class="subtitle">åŒäººå¯¹æˆ˜ Â· 3Dè§†è§’ Â· é­”æ³•æŠ€èƒ½ Â· åŸºåœ°æ”»é˜²</div>
            </div>
        
            <div class="rules-container enter-animation delay-1">
                <h2 class="rules-title">æ¸¸æˆè§„åˆ™</h2>
                <div class="controls-section">
                    <h3 class="controls-title">ğŸ® æ§åˆ¶è¯´æ˜</h3>
        
                    <div class="control-keys">
                        <div class="key-item p1">
                            <h4>ç©å®¶1 (æ©™è‰²)</h4>
                            <div>ç§»åŠ¨: <span class="key">W</span><span class="key">A</span><span class="key">S</span><span
                                    class="key">D</span></div>
                            <div>é­”æ³•çƒ: <span class="key">1-5</span></div>
                            <div>å•†åº—: <span class="key">E</span> è´­ä¹°: <span class="key">R</span></div>
                            <div>æš‚åœ: <span class="key">Q</span></div>
                        </div>
        
                        <div class="key-item p2">
                            <h4>ç©å®¶2 (è“è‰²)</h4>
                            <div>ç§»åŠ¨: <span class="key">â†‘</span><span class="key">â†“</span><span class="key">â†</span><span
                                    class="key">â†’</span></div>
                            <div>é­”æ³•çƒ: <span class="key">6-0</span></div>
                            <div>å•†åº—: <span class="key">+</span> è´­ä¹°: <span class="key">Enter</span></div>
                            <div>æš‚åœ: <span class="key">/</span></div>
                        </div>
                    </div>
                </div>
            </div>
        
            <button class="start-home-btn enter-animation delay-2" id="start-home-btn">
                å¼€å§‹æ¸¸æˆ
            </button>
        </div> 
    <div class="selection-overlay" id="selection-overlay" style="display: none;">
        <div class="selection-content">
            <!-- ç©å®¶1é€‰æ‹© -->
            <div class="player-selection">
                <h3 id="player1-selection-title">ç©å®¶1é€‰æ‹©è›‡ç±»å‹</h3>
                <div class="snake-options">
                    <div class="snake-option active" data-type="speed" onclick="selectSnakeType('player1', 'speed')">
                        <div class="snake-preview" style="background: #FFA500;"></div>
                        <h4>é€Ÿåº¦è›‡</h4>
                        <p>ç”Ÿå‘½: â˜…â˜…â˜…â˜†â˜†</p>
                        <p>é€Ÿåº¦: â˜…â˜…â˜…â˜…â˜…</p>
                        <p>ç‰¹ç‚¹: åŒå‡»æ–¹å‘é”®ä¿¯å†²åŠ é€Ÿ</p>
                    </div>
                    <div class="snake-option" data-type="hard" onclick="selectSnakeType('player1', 'hard')">
                        <div class="snake-preview" style="background: #C0C0C0;"></div>
                        <h4>åšç¡¬è›‡</h4>
                        <p>ç”Ÿå‘½: â˜…â˜…â˜…â˜…â˜…</p>
                        <p>é€Ÿåº¦: â˜…â˜…â˜†â˜†â˜†</p>
                        <p>ç‰¹ç‚¹: ä¼¤å®³å‡åŠï¼Œ50%å­å¼¹å…ç–«</p>
                    </div>
                    <div class="snake-option" data-type="magic" onclick="selectSnakeType('player1', 'magic')">
                        <div class="snake-preview" style="background: #9370DB;"></div>
                        <h4>é­”æ³•è›‡</h4>
                        <p>ç”Ÿå‘½: â˜…â˜…â˜…â˜†â˜†</p>
                        <p>é€Ÿåº¦: â˜…â˜…â˜…â˜†â˜†</p>
                        <p>ç‰¹ç‚¹: æ•ˆæœæ—¶é—´å»¶é•¿ï¼Œè‡ªåŠ¨ç”Ÿæˆé­”æ³•çƒ</p>
                    </div>
                </div>
            </div>

            <!-- ç©å®¶2é€‰æ‹© -->
            <div class="player-selection">
                <h3 id="player2-selection-title">ç©å®¶2é€‰æ‹©è›‡ç±»å‹</h3>
                <div class="snake-options">
                    <div class="snake-option active" data-type="speed" onclick="selectSnakeType('player2', 'speed')">
                        <div class="snake-preview" style="background: #4169E1;"></div>
                        <h4>é€Ÿåº¦è›‡</h4>
                        <p>ç”Ÿå‘½: â˜…â˜…â˜…â˜†â˜†</p>
                        <p>é€Ÿåº¦: â˜…â˜…â˜…â˜…â˜…</p>
                        <p>ç‰¹ç‚¹: åŒå‡»æ–¹å‘é”®ä¿¯å†²åŠ é€Ÿ</p>
                    </div>
                    <div class="snake-option" data-type="hard" onclick="selectSnakeType('player2', 'hard')">
                        <div class="snake-preview" style="background: #C0C0C0;"></div>
                        <h4>åšç¡¬è›‡</h4>
                        <p>ç”Ÿå‘½: â˜…â˜…â˜…â˜…â˜…</p>
                        <p>é€Ÿåº¦: â˜…â˜…â˜†â˜†â˜†</p>
                        <p>ç‰¹ç‚¹: ä¼¤å®³å‡åŠï¼Œ50%å­å¼¹å…ç–«</p>
                    </div>
                    <div class="snake-option" data-type="magic" onclick="selectSnakeType('player2', 'magic')">
                        <div class="snake-preview" style="background: #9370DB;"></div>
                        <h4>é­”æ³•è›‡</h4>
                        <p>ç”Ÿå‘½: â˜…â˜…â˜…â˜†â˜†</p>
                        <p>é€Ÿåº¦: â˜…â˜…â˜…â˜†â˜†</p>
                        <p>ç‰¹ç‚¹: æ•ˆæœæ—¶é—´å»¶é•¿ï¼Œè‡ªåŠ¨ç”Ÿæˆé­”æ³•çƒ</p>
                    </div>
                </div>
            </div>

            <!-- åœ°å›¾é€‰æ‹© -->
            <div class="map-selection">
                <h3>é€‰æ‹©åœ°å›¾ç±»å‹</h3>
                <div class="map-options">
                    <div class="map-option active" data-map="classic" onclick="selectMapType('classic')">
                        <div class="map-preview classic-map"></div>
                        <h4>ç»å…¸åœ°å›¾</h4>
                        <p>æ ‡å‡†å¯¹æˆ˜åœ°å›¾ï¼Œéšæœºå¢™å£</p>
                    </div>
                    <div class="map-option" data-map="snow" onclick="selectMapType('snow')">
                        <div class="map-preview snow-map"></div>
                        <h4>é›ªå±±åœ°å›¾</h4>
                        <p>æš´é£é›ªæœºåˆ¶ï¼Œå‡é€Ÿå†»ç»“æ•ˆæœ</p>
                    </div>
                    <div class="map-option" data-map="volcano" onclick="selectMapType('volcano')">
                        <div class="map-preview volcano-map"></div>
                        <h4>ç«å±±åœ°å›¾</h4>
                        <p>ç«å±±å–·å‘ï¼Œå²©æµ†åŒºåŸŸä¼¤å®³</p>
                    </div>
                </div>
            </div>

            <!-- å¼€å§‹æ¸¸æˆæŒ‰é’® -->
            <div class="start-game-section">
                <button id="confirm-start-btn" onclick="startGameWithSelections()">å¼€å§‹æ¸¸æˆ</button>
            </div>
        </div>
    </div>
    <div id="game-container">
        <!-- åˆ†å±ç¬¬ä¸€è§†è§’ -->
        <div class="split-screen">
            <div class="split-left">
                <div class="player-viewport" id="player1-viewport">
                    <canvas class="player-canvas" id="player1-canvas"></canvas>
                    <!-- ç©å®¶1å—ä¼¤æ•ˆæœ -->
                    <div class="damage-overlay p1-damage" id="p1-damage"></div>
                </div>
            </div>
            <div class="split-right">
                <div class="player-viewport" id="player2-viewport">
                    <canvas class="player-canvas" id="player2-canvas"></canvas>
                    <!-- ç©å®¶2å—ä¼¤æ•ˆæœ -->
                    <div class="damage-overlay p2-damage" id="p2-damage"></div>
                </div>
            </div>
        </div>

        <!-- UIè¦†ç›–å±‚ -->
        <div id="ui-overlay">
            <!-- ç©å®¶1é¢æ¿ -->
            <div class="player-panel" id="player1-panel">
                <div class="player-header">
                    <span id="player1-panel-name">ç©å®¶1</span>
                    <span class="snake-type speed-snake" id="player1-type">æœªé€‰æ‹©</span>
                </div>
                <div>ç”Ÿå‘½å€¼: <span id="player1-hp">10</span>/<span id="player1-max-hp">10</span></div>
                <div class="health-bar">
                    <div class="health-fill" id="player1-health" style="width: 100%"></div>
                </div>
                <div>é­”æ³•çƒ:</div>
                <div class="magic-balls" id="player1-balls"></div>
                <div>æŠ¤ç›¾: <span id="player1-shield">0</span></div>
                <div>åˆ†æ•°: <span id="player1-score">0</span></div>
            </div>

            <!-- ç©å®¶2é¢æ¿ -->
            <div class="player-panel" id="player2-panel">
                <div class="player-header">
                    <span id="player2-panel-name">ç©å®¶2</span>
                    <span class="snake-type magic-snake" id="player2-type">æœªé€‰æ‹©</span>
                </div>
                <div>ç”Ÿå‘½å€¼: <span id="player2-hp">10</span>/<span id="player2-max-hp">10</span></div>
                <div class="health-bar">
                    <div class="health-fill" id="player2-health" style="width: 100%"></div>
                </div>
                <div>é­”æ³•çƒ:</div>
                <div class="magic-balls" id="player2-balls"></div>
                <div>æŠ¤ç›¾: <span id="player2-shield">0</span></div>
                <div>åˆ†æ•°: <span id="player2-score">0</span></div>
            </div>

            <!-- åˆ†æ•°æ˜¾ç¤º -->
            <div class="score-display">
                æ¸¸æˆæ—¶é—´: <span id="game-time">00:00</span>
            </div>



            <!-- æ¸¸æˆæ§åˆ¶æŒ‰é’® -->
            <div class="game-controls">
                <button id="start-btn">å¼€å§‹æ¸¸æˆ</button>
                <button id="reset-btn">é‡æ–°å¼€å§‹</button>
                <button id="map-btn">åˆ‡æ¢åœ°å›¾</button>
            </div>

            <!-- ç©å®¶1å•†åº—ç•Œé¢ -->
            <div class="shop-overlay" id="shop1-overlay">
                <div class="shop-content">
                    <div class="shop-items">
                        <!-- é¡¹ç›®ä¼šé€šè¿‡JavaScriptåŠ¨æ€ç”Ÿæˆ -->
                    </div>
                </div>
            </div>

            <!-- ç©å®¶2å•†åº— -->
            <div class="shop-overlay" id="shop2-overlay">
                <div class="shop-content">
                    <div class="shop-items">
                        <!-- é¡¹ç›®ä¼šé€šè¿‡JavaScriptåŠ¨æ€ç”Ÿæˆ -->
                    </div>
                </div>
            </div>
            <div class="base-info" id="player1-base">
                <div id="player1-base-name">ç©å®¶1åŸºåœ°</div>
                <div>ç”Ÿå‘½å€¼<span id="base1-hp">50</span></div>
                <div class="base-health">
                    <div class="base-health-fill" id="base1-health" style="width: 100%"></div>
                </div>
            </div>

            <div class="base-info" id="player2-base">
                <div id="player2-base-name">ç©å®¶2åŸºåœ°</div>
                <div>ç”Ÿå‘½å€¼<span id="base2-hp">50</span></div>
                <div class="base-health">
                    <div class="base-health-fill" id="base2-health" style="width: 100%"></div>
                </div>
            </div>

            <!-- æ¸¸æˆç»“æŸç•Œé¢ -->
            <div class="game-over" id="game-over">
                <div id="winner-text">æ¸¸æˆç»“æŸ</div>
                <div class="stats-container" id="stats-container">
                    <!-- ç»Ÿè®¡ä¿¡æ¯ä¼šåŠ¨æ€ç”Ÿæˆ -->
                </div>
                <div class="game-controls">
                    <button id="play-again-btn">å†ç©ä¸€æ¬¡</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // æ¸¸æˆçŠ¶æ€
        let gameState = {
            running: false,
            gameTime: 0,
            mapType: 'classic', // classic, snow, volcano
            player1: {
                snake: null,
                type: 'speed', // speed, hard, magic
                hp: 10,
                maxHp: 10,
                shield: 0,
                score: 0,
                magicBalls: [],
                status: 'normal', // normal, invincible, reversed, attacking
                statusTime: 0,
                speedMultiplier: 1,
                hardUpgrades: 0,
                magicUpgrades: 0,
                lastDashTime: 0,
                dashDuration: 0,
                isDashing: false,
                position: { x: -50, y: 1.5, z: 0 },
                direction: { x: 1, y: 0, z: 0 },
                targetDirection: { x: 1, y: 0, z: 0 }, // ç”¨äºå¹³æ»‘è½¬å‘
                rotationAngle: 0, // å½“å‰æ—‹è½¬è§’åº¦
                segments: [],
                baseHp: 50,
                basePosition: { x: -80, y: 0, z: 0 },
                camera: null, // ç¬¬ä¸€è§†è§’ç›¸æœº
                renderer: null,// ç©å®¶1çš„æ¸²æŸ“å™¨
                paused: false,
                stats: {
                    totalDistance: 0,           // æ€»è·¯ç¨‹ï¼ˆç±³ï¼‰
                    damageTaken: {              // æ‰¿å—ä¼¤å®³ç»Ÿè®¡
                        wall: 0,                // æ’å¢™ä¼¤å®³
                        snakeCollision: 0,      // ä¸è›‡ç›¸æ’ä¼¤å®³
                        bullet: 0,              // å­å¼¹ä¼¤å®³
                        base: 0,                // åŸºåœ°ä¼¤å®³
                        lava: 0,                // å²©æµ†ä¼¤å®³
                        bomb: 0,                // ç‚¸å¼¹ä¼¤å®³
                        total: 0                // æ€»æ‰¿å—ä¼¤å®³
                    },
                    damageDealt: {              // è¾“å‡ºä¼¤å®³ç»Ÿè®¡
                        snakeCollision: 0,      // å¯¹è›‡ç¢°æ’ä¼¤å®³
                        bullet: 0,              // å­å¼¹ä¼¤å®³
                        bomb: 0,                // ç‚¸å¼¹ä¼¤å®³
                        baseDamage: 0,          // å¯¹åŸºåœ°ä¼¤å®³
                        total: 0                // æ€»è¾“å‡ºä¼¤å®³ï¼ˆä¸åŒ…æ‹¬å¯¹åŸºåœ°ï¼‰
                    }
                }
            },
            player2: {
                snake: null,
                type: 'speed',
                hp: 10,
                maxHp: 10,
                shield: 0,
                score: 0,
                magicBalls: [],
                status: 'normal',
                statusTime: 0,
                speedMultiplier: 1,
                hardUpgrades: 0,
                magicUpgrades: 0,
                lastMagicGenerateTime: 0,
                position: { x: 50, y: 1.5, z: 0 },
                direction: { x: -1, y: 0, z: 0 },
                targetDirection: { x: -1, y: 0, z: 0 }, // ç”¨äºå¹³æ»‘è½¬å‘
                rotationAngle: Math.PI, // å½“å‰æ—‹è½¬è§’åº¦
                segments: [],
                baseHp: 50,
                basePosition: { x: 80, y: 0, z: 0 },
                camera: null, // ç¬¬ä¸€è§†è§’ç›¸æœº
                renderer: null, // ç©å®¶2çš„æ¸²æŸ“å™¨
                paused: false,
                stats: {
                totalDistance: 0,
                damageTaken: {
                    wall: 0,
                    snakeCollision: 0,
                    bullet: 0,
                    base: 0,
                    lava: 0,
                    bomb: 0,
                    total: 0
                },
                damageDealt: {
                    snakeCollision: 0,
                    bullet: 0,
                    bomb: 0,
                    baseDamage: 0,
                    total: 0
                }
        }
            },
            magicBalls: [], // åœ°å›¾ä¸Šçš„é­”æ³•çƒ
            food: [], // é£Ÿç‰©
            walls: [], // å¢™å£
            bullets: [], // å­å¼¹
            explosions: [], // çˆ†ç‚¸æ•ˆæœ
            volcanoes: [], // ç«å±±
            stormDirection: null, // æš´é£é›ªæ–¹å‘
            stormActive: false,
            stormWarning: false,
            keys: {},
            scene: null, // å…±äº«åœºæ™¯
            selectionMode: true
        };
        let gameStats = {
            startTime: 0,
            endTime: 0,
            deathCauses: {
                player1: null,
                player2: null
            }
        };
        let lastWallCollisionTime = {
            player1: 0,
            player2: 0
        };
        gameState.lastCollisionTime = {
            player1: 0,
            player2: 0
        };
        gameState.player1.status = {
            normal: true,
            effects: [] // ç¡®ä¿ effects æ•°ç»„å­˜åœ¨
        };
    gameState.player1 = {
        // ... å…¶ä»–å±æ€§ ...
        lastDamageSource: null,      // æœ€åå—åˆ°çš„ä¼¤å®³æ¥æº
        lastDamageAmount: 0,         // æœ€åå—åˆ°çš„ä¼¤å®³é‡
        deathReason: null            // æ­»äº¡åŸå› 
    };

    gameState.player2 = {
        // ... å…¶ä»–å±æ€§ ...
        lastDamageSource: null,
        lastDamageAmount: 0,
        deathReason: null
    };
        // é‡ç½®ç©å®¶2  
        gameState.player2.status = {
            normal: true,
            effects: [] // ç¡®ä¿ effects æ•°ç»„å­˜åœ¨
        };
        let shopState = {
            player1: {
                open: false,
                selectedIndex: 0,
                items: [
                    { id: 'shield', name: 'èƒ½é‡æŠ¤ç›¾', desc: 'è·å¾—10ç‚¹æŠ¤ç›¾å€¼', price: 400 },
                    { id: 'magic-pack', name: 'é­”æ³•çƒç¤¼åŒ…', desc: 'è·å¾—3ä¸ªéšæœºé­”æ³•çƒ', price: 400 },
                    { id: 'speed-upgrade', name: 'é€Ÿåº¦å‡çº§', desc: 'æ°¸ä¹…å¢åŠ 15%ç§»åŠ¨é€Ÿåº¦', price: 500 },
                    { id: 'hard-upgrade', name: 'åšç¡¬å‡çº§', desc: 'æ°¸ä¹…å¢åŠ 2ç‚¹ç”Ÿå‘½ä¸Šé™', price: 500 },
                    { id: 'magic-upgrade', name: 'é­”æ³•å‡çº§', desc: 'å»¶é•¿20%æ•ˆæœæ—¶é—´', price: 500 }
                ]
            },
            player2: {
                open: false,
                selectedIndex: 0,
                items: [
                    { id: 'shield', name: 'èƒ½é‡æŠ¤ç›¾', desc: 'è·å¾—10ç‚¹æŠ¤ç›¾å€¼', price: 400 },
                    { id: 'magic-pack', name: 'é­”æ³•çƒç¤¼åŒ…', desc: 'è·å¾—3ä¸ªéšæœºé­”æ³•çƒ', price: 400 },
                    { id: 'speed-upgrade', name: 'é€Ÿåº¦å‡çº§', desc: 'æ°¸ä¹…å¢åŠ 15%ç§»åŠ¨é€Ÿåº¦', price: 500 },
                    { id: 'hard-upgrade', name: 'åšç¡¬å‡çº§', desc: 'æ°¸ä¹…å¢åŠ 2ç‚¹ç”Ÿå‘½ä¸Šé™', price: 500 },
                    { id: 'magic-upgrade', name: 'é­”æ³•å‡çº§', desc: 'å»¶é•¿20%æ•ˆæœæ—¶é—´', price: 500 }
                ]
            }
        };
        let clock;
        // æ¸¸æˆå…ƒç´ 
        let player1Name = localStorage.getItem('username') || 'ç©å®¶1';
        let player2Name = localStorage.getItem('player2_username') || 'ç©å®¶2';
        const gameTimeElement = document.getElementById('game-time');
        const player1HealthElement = document.getElementById('player1-hp');
        const player1MaxHealthElement = document.getElementById('player1-max-hp');
        const player1HealthBar = document.getElementById('player1-health');
        const player2HealthElement = document.getElementById('player2-hp');
        const player2MaxHealthElement = document.getElementById('player2-max-hp');
        const player2HealthBar = document.getElementById('player2-health');
        const player1ShieldElement = document.getElementById('player1-shield');
        const player2ShieldElement = document.getElementById('player2-shield');
        const player1ScoreElement = document.getElementById('player1-score');
        const player2ScoreElement = document.getElementById('player2-score');
        const player1BallsElement = document.getElementById('player1-balls');
        const player2BallsElement = document.getElementById('player2-balls');
        const base1HpElement = document.getElementById('base1-hp');
        const base2HpElement = document.getElementById('base2-hp');
        const base1HealthBar = document.getElementById('base1-health');
        const base2HealthBar = document.getElementById('base2-health');
        const p1DamageOverlay = document.getElementById('p1-damage');
        const p2DamageOverlay = document.getElementById('p2-damage');
        const startButton = document.getElementById('start-btn');
        const resetButton = document.getElementById('reset-btn');
        const mapButton = document.getElementById('map-btn');
        const shop1Overlay = document.getElementById('shop1-overlay');
        const shop2Overlay = document.getElementById('shop2-overlay');
        const gameOverScreen = document.getElementById('game-over');
        const winnerText = document.getElementById('winner-text');
        const statsContainer = document.getElementById('stats-container');
        const playAgainButton = document.getElementById('play-again-btn');
        document.getElementById('player1-base-name').textContent = player1Name + 'åŸºåœ°';
        document.getElementById('player2-base-name').textContent = player2Name + 'åŸºåœ°';
        document.getElementById('player1-panel-name').textContent = player1Name;
        document.getElementById('player2-panel-name').textContent = player2Name;
        document.getElementById('player1-selection-title').textContent = player1Name + 'é€‰æ‹©è›‡ç±»å‹';
        document.getElementById('player2-selection-title').textContent = player2Name + 'é€‰æ‹©è›‡ç±»å‹';
        let homepageState = {
                visible: true,
                animationComplete: false
            };

            // åˆ›å»ºèƒŒæ™¯ç²’å­æ•ˆæœ
            function createParticles() {
                const particlesContainer = document.getElementById('particles');
                if (!particlesContainer) return;

                particlesContainer.innerHTML = '';

                // åˆ›å»º100ä¸ªç²’å­
                for (let i = 0; i < 100; i++) {
                    const particle = document.createElement('div');
                    particle.className = 'particle';

                    // éšæœºä½ç½®
                    const left = Math.random() * 100;
                    const top = Math.random() * 100;

                    // éšæœºå¤§å°å’Œé€æ˜åº¦
                    const size = 1 + Math.random() * 3;
                    const opacity = 0.2 + Math.random() * 0.5;

                    // éšæœºé¢œè‰²ï¼ˆé‡‘è‰²æˆ–è“è‰²ç³»ï¼‰
                    const colors = [
                        'rgba(255, 215, 0, {opacity})',    // é‡‘è‰²
                        'rgba(255, 127, 0, {opacity})',    // æ©™è‰²
                        'rgba(65, 105, 225, {opacity})',   // è“è‰²
                        'rgba(147, 112, 219, {opacity})'   // ç´«è‰²
                    ];
                    const color = colors[Math.floor(Math.random() * colors.length)]
                        .replace('{opacity}', opacity);

                    // éšæœºåŠ¨ç”»æ—¶é•¿
                    const duration = 10 + Math.random() * 20;
                    const delay = Math.random() * 5;

                    // è®¾ç½®æ ·å¼
                    particle.style.cssText = `
            left: ${left}%;
            top: ${top}%;
            width: ${size}px;
            height: ${size}px;
            background: ${color};
            animation-duration: ${duration}s;
            animation-delay: ${delay}s;
        `;

                    particlesContainer.appendChild(particle);
                }
            }

            // ä¸»é¡µè¿›å…¥åŠ¨ç”»
            function playHomepageAnimation() {
                const homepage = document.getElementById('homepage');
                if (!homepage) return;

                // åˆ›å»ºç²’å­æ•ˆæœ
                createParticles();

                // æ·»åŠ åŠ¨ç”»ç±»
                const animatedElements = homepage.querySelectorAll('.enter-animation');
                animatedElements.forEach((el, index) => {
                    el.style.animationDelay = `${index * 0.2}s`;
                });

                // è®¾ç½®ä¸»é¡µçŠ¶æ€
                homepageState.visible = true;
                homepageState.animationComplete = true;
            }

            // åˆ‡æ¢åˆ°é€‰æ‹©ç•Œé¢
            function goToSelectionScreen() {
                console.log(player2Name);
                let storedPlayer2Name = localStorage.getItem('player2_username');
                if(!storedPlayer2Name) {
                    loginPlayer2();
                }
                const homepage = document.getElementById('homepage');
                const selectionOverlay = document.getElementById('selection-overlay');

                if (!homepage || !selectionOverlay) return;

                // ä¸»é¡µæ·¡å‡ºåŠ¨ç”»
                homepage.style.opacity = '1';
                homepage.style.transition = 'opacity 0.8s ease-out';

                setTimeout(() => {
                    homepage.style.opacity = '0';

                    setTimeout(() => {
                        // éšè—ä¸»é¡µ
                        homepage.style.display = 'none';

                        // æ˜¾ç¤ºé€‰æ‹©ç•Œé¢
                        selectionOverlay.style.display = 'flex';
                        selectionOverlay.style.opacity = '0';
                        selectionOverlay.style.transition = 'opacity 0.8s ease-in';

                        setTimeout(() => {
                            selectionOverlay.style.opacity = '1';
                        }, 50);

                        // æ›´æ–°çŠ¶æ€
                        homepageState.visible = false;
                        gameState.selectionMode = true;
                    }, 800);
                }, 100);
            }

        function selectSnakeType(playerKey, type) {
            const player = gameState[playerKey];
            player.type = type;

            // æ ¹æ®ç±»å‹è®¾ç½®è¡€é‡
            if (type === 'hard') {
                player.maxHp = 15;
                player.hp = 15;
            } else {
                player.maxHp = 10;
                player.hp = 10;
            }

            // æ›´æ–°UIæ˜¾ç¤º
            const options = document.querySelectorAll(`.player-selection:nth-child(${playerKey === 'player1' ? 1 : 2}) .snake-option`);
            options.forEach(option => {
                if (option.dataset.type === type) {
                    option.classList.add('active');
                } else {
                    option.classList.remove('active');
                }
            });

            // æ›´æ–°é¢„è§ˆé¢œè‰²
            const previews = document.querySelectorAll(`.player-selection:nth-child(${playerKey === 'player1' ? 1 : 2}) .snake-preview`);
            previews.forEach((preview, index) => {
                const types = ['speed', 'hard', 'magic'];
                if (types[index] === type) {
                    if (playerKey === 'player1') {
                        preview.style.background = type === 'speed' ? '#FFA500' :
                            type === 'hard' ? '#C0C0C0' : '#9370DB';
                    } else {
                        preview.style.background = type === 'speed' ? '#4169E1' :
                            type === 'hard' ? '#C0C0C0' : '#9370DB';
                    }
                }
            });
        }

        // é€‰æ‹©åœ°å›¾ç±»å‹
        function selectMapType(mapType) {
            gameState.mapType = mapType;

            // æ›´æ–°UIæ˜¾ç¤º
            const options = document.querySelectorAll('.map-option');
            options.forEach(option => {
                if (option.dataset.map === mapType) {
                    option.classList.add('active');
                } else {
                    option.classList.remove('active');
                }
            });
        }

        // ä½¿ç”¨é€‰æ‹©å¼€å§‹æ¸¸æˆ
    function startGameWithSelections() {
        const selectionOverlay = document.getElementById('selection-overlay');
        const gameContainer = document.getElementById('game-container');

        if (selectionOverlay) {
            // æ·¡å‡ºé€‰æ‹©ç•Œé¢
                    // ç¡®ä¿è·å–å½“å‰é€‰ä¸­çš„è›‡ç±»å‹
            const player1Selected = selectionOverlay.querySelector('.player-selection:nth-child(1) .snake-option.active');
            const player2Selected = selectionOverlay.querySelector('.player-selection:nth-child(2) .snake-option.active');
            selectionOverlay.style.opacity = '0';
            selectionOverlay.style.transition = 'opacity 0.5s ease-out';
            if (player1Selected) {
                const player1Type = player1Selected.dataset.type;
                gameState.player1.type = player1Type;
                document.getElementById('player1-type').textContent = 
                    player1Type === 'speed' ? 'é€Ÿåº¦è›‡' :
                    player1Type === 'hard' ? 'åšç¡¬è›‡' : 'é­”æ³•è›‡';
            }

            if (player2Selected) {
                const player2Type = player2Selected.dataset.type;
                gameState.player2.type = player2Type;
                document.getElementById('player2-type').textContent = 
                    player2Type === 'speed' ? 'é€Ÿåº¦è›‡' :
                    player2Type === 'hard' ? 'åšç¡¬è›‡' : 'é­”æ³•è›‡';
            }
            setTimeout(() => {
                selectionOverlay.style.display = 'none';

                // æ˜¾ç¤ºæ¸¸æˆå®¹å™¨
                if (gameContainer) {
                    gameContainer.style.display = 'block';
                    gameContainer.style.opacity = '0';
                    gameContainer.style.transition = 'opacity 0.5s ease-in';

                    setTimeout(() => {
                        gameContainer.style.opacity = '1';
                    }, 50);
                }

                // åˆå§‹åŒ–æ¸¸æˆ
                initGame();

                // å¼€å§‹æ¸¸æˆ
                gameState.running = true;
                const startBtn = document.getElementById('start-btn');
                if (startBtn) {
                    startBtn.textContent = 'æ¸¸æˆä¸­';
                    startBtn.disabled = true;
                    startBtn.style.display = 'none';
                }

                if (clock) clock.start();

                // è®¾ç½®é€‰æ‹©æ¨¡å¼ä¸ºfalse
                gameState.selectionMode = false;
            }, 500);
        }
    }

        // éšè—ä¸å¿…è¦çš„UIå…ƒç´ 
        function hideUnnecessaryUI() {
            // å¯ä»¥åœ¨è¿™é‡Œé€‰æ‹©æ€§éšè—ä¸€äº›UIå…ƒç´ 
            const elementsToHide = [
                '.game-controls button:not(#start-btn)' // é™¤äº†å¼€å§‹æŒ‰é’®çš„å…¶ä»–æŒ‰é’®
            ];
            document.getElementById('view-records').style.display = 'none';
            elementsToHide.forEach(selector => {
                const elements = document.querySelectorAll(selector);
                elements.forEach(el => {
                    el.style.display = 'none';
                });
            });
        }

        // é‡æ–°å¼€å§‹æ¸¸æˆï¼ˆè¿”å›é€‰æ‹©ç•Œé¢ï¼‰
    function resetToSelection() {
        const gameContainer = document.getElementById('game-container');
        const selectionOverlay = document.getElementById('selection-overlay');

        if (gameState.running) {
            gameState.running = false;
        }

        // æ·¡å‡ºæ¸¸æˆå®¹å™¨
        if (gameContainer) {
            gameContainer.style.opacity = '0';
            gameContainer.style.transition = 'opacity 0.5s ease-out';

            setTimeout(() => {
                gameContainer.style.display = 'none';

                // æ˜¾ç¤ºé€‰æ‹©ç•Œé¢
                if (selectionOverlay) {
                    selectionOverlay.style.display = 'flex';
                    selectionOverlay.style.opacity = '0';
                    selectionOverlay.style.transition = 'opacity 0.5s ease-in';

                    setTimeout(() => {
                        selectionOverlay.style.opacity = '1';
                    }, 50);
                }

                // é€€å‡ºå…¨å±æ¨¡å¼
                document.body.classList.remove('game-fullscreen');

                // æ¢å¤UIå…ƒç´ 
                const elementsToShow = [
                    '.game-controls button'
                ];

                elementsToShow.forEach(selector => {
                    const elements = document.querySelectorAll(selector);
                    elements.forEach(el => {
                        el.style.display = '';
                    });
                });

                // è®¾ç½®é€‰æ‹©æ¨¡å¼ä¸ºtrue
                gameState.selectionMode = true;
            }, 500);
        }
    }
    document.addEventListener('DOMContentLoaded', function () {
        // ä¸»é¡µå¼€å§‹æ¸¸æˆæŒ‰é’®
        const startHomeBtn = document.getElementById('start-home-btn');
        if (startHomeBtn) {
            startHomeBtn.addEventListener('click', goToSelectionScreen);
        }

        // çª—å£å¤§å°æ”¹å˜æ—¶é‡æ–°ç”Ÿæˆç²’å­
        window.addEventListener('resize', function () {
            if (homepageState.visible) {
                createParticles();
            }
        });
    });
        // ä¿®æ”¹resetæŒ‰é’®äº‹ä»¶
        resetButton.addEventListener('click', resetToSelection);

        // ä¿®æ”¹playAgainæŒ‰é’®äº‹ä»¶
        playAgainButton.addEventListener('click', function () {
            // æ¸¸æˆç»“æŸåè¿”å›é€‰æ‹©ç•Œé¢
            resetToSelection();
        });

        // åˆå§‹åŒ–åœºæ™¯
        function initScene() {
            // åˆ›å»ºåœºæ™¯
            gameState.scene = new THREE.Scene();
            gameState.scene.fog = new THREE.Fog(0x87CEEB, 20, 200);
            clock = new THREE.Clock();
            // åˆ›å»ºç›¸æœº
            gameState.player1.camera = new THREE.PerspectiveCamera(
                75,
                (window.innerWidth / 2) / window.innerHeight,
                1,
                300
            );

            gameState.player2.camera = new THREE.PerspectiveCamera(
                75,
                (window.innerWidth / 2) / window.innerHeight,
                1,
                300
            );

            // åˆ›å»ºæ¸²æŸ“å™¨
            gameState.player1.renderer = new THREE.WebGLRenderer({
                canvas: document.getElementById('player1-canvas'),
                antialias: true,
                alpha: true
            });
            gameState.player1.renderer.setSize(window.innerWidth / 2, window.innerHeight);

            gameState.player2.renderer = new THREE.WebGLRenderer({
                canvas: document.getElementById('player2-canvas'),
                antialias: true,
                alpha: true
            });
            gameState.player2.renderer.setSize(window.innerWidth / 2, window.innerHeight);

            // åˆ›å»ºç¯å…‰
            createLights();

            // åˆ›å»ºç¯å¢ƒ
            createEnvironment();

            // ä¸åˆå§‹åŒ–æ¸¸æˆï¼Œç­‰å¾…é€‰æ‹©

            // å¼€å§‹åŠ¨ç”»å¾ªç¯
            animate();
        }

        // åˆ›å»ºç¯å…‰
        function createLights() {
            // ç¯å¢ƒå…‰
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            gameState.scene.add(ambientLight);

            // ä¸»æ–¹å‘å…‰
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 100, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.left = -100;
            directionalLight.shadow.camera.right = 100;
            directionalLight.shadow.camera.top = 100;
            directionalLight.shadow.camera.bottom = -100;
            gameState.scene.add(directionalLight);

            // è¡¥å……ç¯å…‰
            const fillLight = new THREE.DirectionalLight(0xffffff, 0.3);
            fillLight.position.set(-50, 50, -50);
            gameState.scene.add(fillLight);
        }

        // åˆ›å»ºç¯å¢ƒ
        function createEnvironment() {
            // å¤©ç©ºç›’
            const skyGeometry = new THREE.SphereGeometry(500, 32, 32);
            const skyMaterial = new THREE.MeshBasicMaterial({
                color: 0x87CEEB,
                side: THREE.BackSide
            });
            const sky = new THREE.Mesh(skyGeometry, skyMaterial);
            gameState.scene.add(sky);

            // åˆ›å»ºåœ°é¢
            createGround();
        }

        // åˆ›å»ºåœ°é¢
        function createGround() {
            const groundSize = 300;
            const groundGeometry = new THREE.PlaneGeometry(groundSize, groundSize, 32, 32);

            // åˆ›å»ºç½‘æ ¼åœ°é¢çº¹ç†
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');

            // ç»˜åˆ¶ç½‘æ ¼
            ctx.fillStyle = '#2E7D32'; // ç»¿è‰²èƒŒæ™¯
            ctx.fillRect(0, 0, 512, 512);

            // ç»˜åˆ¶ç½‘æ ¼çº¿
            ctx.strokeStyle = '#388E3C';
            ctx.lineWidth = 2;

            // æ°´å¹³çº¿
            for (let i = 0; i <= 20; i++) {
                const y = i * 25.6;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(512, y);
                ctx.stroke();
            }

            // å‚ç›´çº¿
            for (let i = 0; i <= 20; i++) {
                const x = i * 25.6;
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, 512);
                ctx.stroke();
            }

            const groundTexture = new THREE.CanvasTexture(canvas);
            groundTexture.wrapS = THREE.RepeatWrapping;
            groundTexture.wrapT = THREE.RepeatWrapping;
            groundTexture.repeat.set(10, 10);

            const groundMaterial = new THREE.MeshStandardMaterial({
                map: groundTexture,
                roughness: 0.9
            });

            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            gameState.scene.add(ground);

            // æ·»åŠ åœ°å›¾è¾¹ç•Œçº¿
            createMapBoundaries();
        }

        // åˆ›å»ºåœ°å›¾è¾¹ç•Œçº¿
        function createMapBoundaries() {
            const boundarySize = 100; // è¾¹ç•Œå¤§å°
            const boundaryHeight = 0.2; // è¾¹ç•Œçº¿é«˜åº¦
            const boundaryColor = 0xFF0000; // çº¢è‰²è¾¹ç•Œçº¿

            // åˆ›å»ºè¾¹ç•Œçº¿æè´¨
            const boundaryMaterial = new THREE.LineBasicMaterial({
                color: boundaryColor,
                linewidth: 3
            });

            // åˆ›å»ºè¾¹ç•Œå‡ ä½•ä½“
            const boundaryPoints = [];

            // å·¦ä¸Šè§’
            boundaryPoints.push(new THREE.Vector3(-boundarySize, boundaryHeight, -boundarySize));
            // å³ä¸Šè§’
            boundaryPoints.push(new THREE.Vector3(boundarySize, boundaryHeight, -boundarySize));
            // å³ä¸‹è§’
            boundaryPoints.push(new THREE.Vector3(boundarySize, boundaryHeight, boundarySize));
            // å·¦ä¸‹è§’
            boundaryPoints.push(new THREE.Vector3(-boundarySize, boundaryHeight, boundarySize));
            // é—­åˆå›åˆ°å·¦ä¸Šè§’
            boundaryPoints.push(new THREE.Vector3(-boundarySize, boundaryHeight, -boundarySize));

            const boundaryGeometry = new THREE.BufferGeometry().setFromPoints(boundaryPoints);
            const boundaryLine = new THREE.Line(boundaryGeometry, boundaryMaterial);
            gameState.scene.add(boundaryLine);

        }

            function initGame() {
                // æ¸…é™¤åœºæ™¯
                clearScene();
                hideUnnecessaryUI();

                // é‡ç½®æ¸¸æˆçŠ¶æ€
                resetGameState();

                // é‡ç½®æ¸¸æˆç»Ÿè®¡
                gameStats = {
                    startTime: performance.now(),
                    endTime: 0,
                    deathCauses: {
                        player1: null,
                        player2: null
                    }
                };

                // æ ¹æ®åœ°å›¾ç±»å‹åˆ›å»ºç¯å¢ƒ
                createMapEnvironment();

                // åˆ›å»ºåŸºåœ°
                createBases();

                // åˆ›å»ºè›‡
                createSnakes();

                // ç”Ÿæˆé£Ÿç‰©
                generateFood();

                // ç”Ÿæˆé­”æ³•çƒ
                generateMagicBalls();

                // æ›´æ–°ç›¸æœºåˆå§‹ä½ç½®
                updateCameras();

                // æ›´æ–°UI
                updateUI();
                clock = new THREE.Clock();

                // éšè—å•†åº—å’Œæ¸¸æˆç»“æŸç•Œé¢
                shop1Overlay.style.display = 'none';
                shop2Overlay.style.display = 'none';
                gameOverScreen.style.display = 'none';
            }
                    // æˆ˜ç»©æŸ¥è¯¢ç›¸å…³å‡½æ•°
                        document.getElementById('view-records').addEventListener('click', showAllRecords);
        // æ¸…é™¤åœºæ™¯
        function clearScene() {
            // ç§»é™¤æ‰€æœ‰æ¸¸æˆå¯¹è±¡
            const objectsToRemove = [];
            gameState.scene.children.forEach(child => {
                if (child.userData && child.userData.type) {
                    objectsToRemove.push(child);
                }
            });

            objectsToRemove.forEach(obj => gameState.scene.remove(obj));

            // æ¸…ç©ºæ•°ç»„
            gameState.magicBalls = [];
            gameState.food = [];
            gameState.walls = [];
            gameState.bullets = [];
            gameState.explosions = [];
            gameState.volcanoes = [];
        }

        // é‡ç½®æ¸¸æˆçŠ¶æ€
    function resetGameState() {
        gameState.running = false;
        gameState.paused = false;
        gameState.gameTime = 0;

        // é‡ç½®ç©å®¶1 - ä¿ç•™è›‡ç±»å‹ï¼Œåªé‡ç½®çŠ¶æ€
        gameState.player1.hp = gameState.player1.type === 'hard' ? 15 : 10;
        gameState.player1.maxHp = gameState.player1.type === 'hard' ? 15 : 10;
        gameState.player1.shield = 0;
        gameState.player1.score = 0;
        gameState.player1.magicBalls = [];
        gameState.player1.isInvincible = false;
        gameState.player1.isReversed = false;
        gameState.player1.isAttacking = false;
        gameState.player1.invincibleTime = 0;
        gameState.player1.reversedTime = 0;
        gameState.player1.attackTime = 0;
        gameState.player1.speedMultiplier = 1;
        gameState.player1.hardUpgrades = 0;
        gameState.player1.magicUpgrades = 0;
        gameState.player1.segments = [];
        gameState.player1.baseHp = 50;
        gameState.player1.position = { x: -80, y: 1.5, z: -80 };
        gameState.player1.direction = { x: 1, y: 0, z: 0 };
        gameState.player1.targetDirection = { x: 1, y: 0, z: 0 };
        gameState.player1.rotationAngle = 0;
        gameState.player1.paused = false;

        // æ­»äº¡åŸå› ç›¸å…³å­—æ®µ - ç¡®ä¿ä¸ä¼šè¦†ç›–ç±»å‹
        if (!gameState.player1.lastDamageSource) gameState.player1.lastDamageSource = null;
        if (!gameState.player1.lastDamageAmount) gameState.player1.lastDamageAmount = 0;
        if (!gameState.player1.deathReason) gameState.player1.deathReason = null;

        // ç»Ÿè®¡å­—æ®µ - ç¡®ä¿ä¸ä¼šè¦†ç›–ç±»å‹
        if (!gameState.player1.stats) {
            gameState.player1.stats = {
                totalDistance: 0,
                damageTaken: {
                    wall: 0,
                    snakeCollision: 0,
                    bullet: 0,
                    base: 0,
                    lava: 0,
                    bomb: 0,
                    total: 0
                },
                damageDealt: {
                    snakeCollision: 0,
                    bullet: 0,
                    bomb: 0,
                    baseDamage: 0,
                    total: 0
                }
            };
        } else {
            // é‡ç½®ç»Ÿè®¡ä½†ä¸è¦†ç›–æ•´ä¸ªå¯¹è±¡
            gameState.player1.stats.totalDistance = 0;
            gameState.player1.stats.damageTaken.wall = 0;
            gameState.player1.stats.damageTaken.snakeCollision = 0;
            gameState.player1.stats.damageTaken.bullet = 0;
            gameState.player1.stats.damageTaken.base = 0;
            gameState.player1.stats.damageTaken.lava = 0;
            gameState.player1.stats.damageTaken.bomb = 0;
            gameState.player1.stats.damageTaken.total = 0;
            gameState.player1.stats.damageDealt.snakeCollision = 0;
            gameState.player1.stats.damageDealt.bullet = 0;
            gameState.player1.stats.damageDealt.bomb = 0;
            gameState.player1.stats.damageDealt.baseDamage = 0;
            gameState.player1.stats.damageDealt.total = 0;
        }

        // é‡ç½®ç©å®¶2 - åŒæ ·ä¿ç•™è›‡ç±»å‹
        gameState.player2.hp = gameState.player2.type === 'hard' ? 15 : 10;
        gameState.player2.maxHp = gameState.player2.type === 'hard' ? 15 : 10;
        gameState.player2.shield = 0;
        gameState.player2.score = 0;
        gameState.player2.magicBalls = [];
        gameState.player2.isInvincible = false;
        gameState.player2.isReversed = false;
        gameState.player2.isAttacking = false;
        gameState.player2.invincibleTime = 0;
        gameState.player2.reversedTime = 0;
        gameState.player2.attackTime = 0;
        gameState.player2.speedMultiplier = 1;
        gameState.player2.hardUpgrades = 0;
        gameState.player2.magicUpgrades = 0;
        gameState.player2.segments = [];
        gameState.player2.baseHp = 50;
        gameState.player2.position = { x: 80, y: 1.5, z: 80 };
        gameState.player2.direction = { x: -1, y: 0, z: 0 };
        gameState.player2.targetDirection = { x: -1, y: 0, z: 0 };
        gameState.player2.rotationAngle = Math.PI;
        gameState.player2.paused = false;

        // æ­»äº¡åŸå› ç›¸å…³å­—æ®µ
        if (!gameState.player2.lastDamageSource) gameState.player2.lastDamageSource = null;
        if (!gameState.player2.lastDamageAmount) gameState.player2.lastDamageAmount = 0;
        if (!gameState.player2.deathReason) gameState.player2.deathReason = null;

        // ç»Ÿè®¡å­—æ®µ
        if (!gameState.player2.stats) {
            gameState.player2.stats = {
                totalDistance: 0,
                damageTaken: {
                    wall: 0,
                    snakeCollision: 0,
                    bullet: 0,
                    base: 0,
                    lava: 0,
                    bomb: 0,
                    total: 0
                },
                damageDealt: {
                    snakeCollision: 0,
                    bullet: 0,
                    bomb: 0,
                    baseDamage: 0,
                    total: 0
                }
            };
        } else {
            gameState.player2.stats.totalDistance = 0;
            gameState.player2.stats.damageTaken.wall = 0;
            gameState.player2.stats.damageTaken.snakeCollision = 0;
            gameState.player2.stats.damageTaken.bullet = 0;
            gameState.player2.stats.damageTaken.base = 0;
            gameState.player2.stats.damageTaken.lava = 0;
            gameState.player2.stats.damageTaken.bomb = 0;
            gameState.player2.stats.damageTaken.total = 0;
            gameState.player2.stats.damageDealt.snakeCollision = 0;
            gameState.player2.stats.damageDealt.bullet = 0;
            gameState.player2.stats.damageDealt.bomb = 0;
            gameState.player2.stats.damageDealt.baseDamage = 0;
            gameState.player2.stats.damageDealt.total = 0;
        }

        // é‡ç½®å…¶ä»–çŠ¶æ€
        gameState.magicBalls = [];
        gameState.food = [];
        gameState.walls = [];
        gameState.bullets = [];
        gameState.explosions = [];
        gameState.volcanoes = [];
        gameState.stormDirection = null;
        gameState.stormActive = false;
        gameState.stormWarning = false;
    }
        // åˆ›å»ºåœ°å›¾ç¯å¢ƒ
        function createMapEnvironment() {
            switch (gameState.mapType) {
                case 'classic':
                    createClassicMap();
                    break;
                case 'snow':
                    createSnowMap();
                    break;
                case 'volcano':
                    createVolcanoMap();
                    break;
            }
        }

        // åˆ›å»ºç»å…¸åœ°å›¾
    function createClassicMap() {
        // ç¡®ä¿åŸºåœ°ä½ç½®å·²åˆå§‹åŒ–
        if (!gameState.player1.basePosition) {
            gameState.player1.basePosition = { x: -80, y: 0, z: -80 };
        }
        if (!gameState.player2.basePosition) {
            gameState.player2.basePosition = { x: 80, y: 0, z: 80 };
        }

        const player1Base = gameState.player1.basePosition;
        const player2Base = gameState.player2.basePosition;

        // è®¾ç½®è¾¹ç•Œå’ŒåŸºåœ°çš„å®‰å…¨åŒºåŸŸ
        const boundaryMargin = 15;
        const baseSafeRadius = 25;

        // ç”Ÿæˆæ›´å¤šå¢™ï¼ˆå¢åŠ åˆ°30ä¸ªï¼‰
        const wallCount = 20;

        for (let i = 0; i < wallCount; i++) {
            let validPosition = false;
            let startX, startZ, endX, endZ;

            // å°è¯•ç”Ÿæˆæœ‰æ•ˆçš„ä½ç½®
            for (let attempts = 0; attempts < 10; attempts++) {
                // éšæœºç”Ÿæˆèµ·ç‚¹
                startX = Math.random() * 180 - 90;
                startZ = Math.random() * 180 - 90;

                // éšæœºç”Ÿæˆé•¿åº¦å’Œæ–¹å‘
                const length = 5 + Math.random() * 15;
                const angle = Math.random() * Math.PI * 2;

                // è®¡ç®—ç»ˆç‚¹
                endX = startX + Math.cos(angle) * length;
                endZ = startZ + Math.sin(angle) * length;

                // æ£€æŸ¥èµ·ç‚¹å’Œç»ˆç‚¹æ˜¯å¦éƒ½åœ¨è¾¹ç•Œå†…
                if (Math.abs(startX) > 100 - boundaryMargin || Math.abs(startZ) > 100 - boundaryMargin ||
                    Math.abs(endX) > 100 - boundaryMargin || Math.abs(endZ) > 100 - boundaryMargin) {
                    continue;
                }

                // è®¡ç®—åˆ°ä¸¤ä¸ªåŸºåœ°çš„è·ç¦»
                const distToBase1Start = Math.sqrt(Math.pow(startX - player1Base.x, 2) + Math.pow(startZ - player1Base.z, 2));
                const distToBase2Start = Math.sqrt(Math.pow(startX - player2Base.x, 2) + Math.pow(startZ - player2Base.z, 2));
                const distToBase1End = Math.sqrt(Math.pow(endX - player1Base.x, 2) + Math.pow(endZ - player1Base.z, 2));
                const distToBase2End = Math.sqrt(Math.pow(endX - player2Base.x, 2) + Math.pow(endZ - player2Base.z, 2));

                // ç¡®ä¿å¢™çš„èµ·ç‚¹å’Œç»ˆç‚¹éƒ½ä¸åœ¨åŸºåœ°å®‰å…¨åŒºåŸŸå†…
                if (distToBase1Start < baseSafeRadius || distToBase2Start < baseSafeRadius ||
                    distToBase1End < baseSafeRadius || distToBase2End < baseSafeRadius) {
                    continue;
                }

                // æ£€æŸ¥å¢™çš„ä¸­ç‚¹æ˜¯å¦å¤ªé è¿‘åŸºåœ°
                const midX = (startX + endX) / 2;
                const midZ = (startZ + endZ) / 2;
                const distToBase1Mid = Math.sqrt(Math.pow(midX - player1Base.x, 2) + Math.pow(midZ - player1Base.z, 2));
                const distToBase2Mid = Math.sqrt(Math.pow(midX - player2Base.x, 2) + Math.pow(midZ - player2Base.z, 2));

                if (distToBase1Mid < baseSafeRadius || distToBase2Mid < baseSafeRadius) {
                    continue;
                }

                validPosition = true;
                break;
            }

            if (!validPosition) {
                continue;
            }

            const wall = createWall(startX, startZ, endX, endZ);
            gameState.walls.push(wall);
            gameState.scene.add(wall);
        }

        // æ·»åŠ ä¸€äº›å›ºå®šæ–¹å‘çš„å¢™æ¥å¢åŠ å¤šæ ·æ€§ï¼ˆå¯é€‰ï¼‰
        addDirectionalWalls();
    }
        function addDirectionalWalls() {
            // æ°´å¹³å’Œå‚ç›´å¢™
            const directionalWalls = [
                // æ°´å¹³å¢™
                { x1: -60, z1: -30, x2: -30, z2: -30, length: 30 },
                { x1: 30, z1: -30, x2: 60, z2: -30, length: 30 },
                { x1: -60, z1: 30, x2: -30, z2: 30, length: 30 },
                { x1: 30, z1: 30, x2: 60, z2: 30, length: 30 },

                // å‚ç›´å¢™
                { x1: -30, z1: -60, x2: -30, z2: -30, length: 30 },
                { x1: 30, z1: -60, x2: 30, z2: -30, length: 30 },
                { x1: -30, z1: 30, x2: -30, z2: 60, length: 30 },
                { x1: 30, z1: 30, x2: 30, z2: 60, length: 30 },
            ];

            directionalWalls.forEach(wallData => {
                // æ£€æŸ¥æ˜¯å¦å¤ªé è¿‘åŸºåœ°
                const player1Base = gameState.player1.basePosition;
                const player2Base = gameState.player2.basePosition;
                const baseSafeRadius = 25;

                const midX = (wallData.x1 + wallData.x2) / 2;
                const midZ = (wallData.z1 + wallData.z2) / 2;

                const distToBase1 = Math.sqrt(Math.pow(midX - player1Base.x, 2) + Math.pow(midZ - player1Base.z, 2));
                const distToBase2 = Math.sqrt(Math.pow(midX - player2Base.x, 2) + Math.pow(midZ - player2Base.z, 2));

                if (distToBase1 < baseSafeRadius || distToBase2 < baseSafeRadius) {
                    return; // å¤ªé è¿‘åŸºåœ°ï¼Œè·³è¿‡
                }

                const wall = createWall(wallData.x1, wallData.z1, wallData.x2, wallData.z2);
                gameState.walls.push(wall);
                gameState.scene.add(wall);
            });
        }
        // åˆ›å»ºé›ªå±±åœ°åœ–
        function createSnowMap() {
            // æ”¹å˜å¤©ç©ºé¢œè‰²
            const sky = gameState.scene.children.find(child => child.material && child.material.color);
            if (sky) {
                sky.material.color.set(0x778899);
            }

            // æ·»åŠ ä¸€äº›å†°å—æ¡çŠ¶å¢™
            createClassicMap(); // ä½¿ç”¨ç›¸åŒçš„å¢™ç”Ÿæˆé€»è¾‘

            // æ·»åŠ é›ªå±±
            createMountains();
        }
        // åˆ›å»ºç«å±±åœ°å›¾
        function createVolcanoMap() {
            // æ”¹å˜å¤©ç©ºé¢œè‰²
            const sky = gameState.scene.children.find(child => child.material && child.material.color);
            if (sky) {
                sky.material.color.set(0xFF4500);
            }

            // ä½¿ç”¨ç›¸åŒçš„å¢™ç”Ÿæˆé€»è¾‘
            createClassicMap();

            // åˆ›å»ºç«å±±
            const volcanoCount = Math.floor(Math.random() * 4) + 4;
            for (let i = 0; i < volcanoCount; i++) {
                const volcano = createVolcano(
                    Math.random() * 150 - 75,
                    Math.random() * 150 - 75
                );
                if (volcano) {
                    gameState.volcanoes.push(volcano);
                    gameState.scene.add(volcano);
                }
            }
        }


        // åˆ›å»ºå¢™å£
        function createWall(x1, z1, x2, z2) {
            // è®¡ç®—å¢™çš„é•¿åº¦å’Œæ–¹å‘
            const length = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(z2 - z1, 2));
            const angle = Math.atan2(z2 - z1, x2 - x1);

            // åˆ›å»ºå¢™çš„å‡ ä½•ä½“ï¼šæ¡çŠ¶ï¼Œé«˜åº¦ä¸è›‡ç›¸åŒï¼ˆ2ä¸ªå•ä½ï¼‰ï¼Œå®½åº¦è¾ƒçª„
            const wallGeometry = new THREE.BoxGeometry(length, 2, 1); // é•¿åº¦å¯å˜ï¼Œé«˜åº¦2ï¼Œå®½åº¦1
            const wallMaterial = new THREE.MeshStandardMaterial({
                color: 0x808080,
                roughness: 0.8,
                metalness: 0.2
            });

            const wall = new THREE.Mesh(wallGeometry, wallMaterial);

            // è®¡ç®—ä¸­å¿ƒç‚¹ä½ç½®
            const centerX = (x1 + x2) / 2;
            const centerZ = (z1 + z2) / 2;

            wall.position.set(centerX, 1, centerZ); // é«˜åº¦è®¾ä¸º1ï¼ˆä¸­å¿ƒç‚¹åœ¨y=1ï¼Œæ€»é«˜åº¦2ï¼‰
            wall.rotation.y = -angle; // æ—‹è½¬åˆ°æ­£ç¡®æ–¹å‘

            wall.castShadow = true;
            wall.receiveShadow = true;
            wall.userData = {
                type: 'wall',
                start: { x: x1, z: z1 },
                end: { x: x2, z: z2 },
                length: length
            };

            return wall;
        }

        // åˆ›å»ºå†°å¢™
        function createIceWall(x, y, z) {
            const geometry = new THREE.BoxGeometry(5, 1, 5);
            const material = new THREE.MeshStandardMaterial({
                color: 0x87CEEB,
                roughness: 0.2,
                transparent: true,
                opacity: 0.7
            });
            const ice = new THREE.Mesh(geometry, material);
            ice.position.set(x, y, z);
            ice.castShadow = true;
            ice.receiveShadow = true;
            ice.userData = { type: 'wall' };
            return ice;
        }

        // åˆ›å»ºç†”å²©å¢™
        function createLavaWall(x, y, z) {
            const geometry = new THREE.BoxGeometry(5, 1, 5);
            const material = new THREE.MeshStandardMaterial({
                color: 0xFF4500,
                emissive: 0xFF4500,
                emissiveIntensity: 0.2,
                roughness: 0.5
            });
            const lavaRock = new THREE.Mesh(geometry, material);
            lavaRock.position.set(x, y, z);
            lavaRock.castShadow = true;
            lavaRock.receiveShadow = true;
            lavaRock.userData = { type: 'wall' };
            return lavaRock;
        }

        // åˆ›å»ºç«å±±
        function createVolcano(x, z) {
            const player1BasePos = gameState.player1.basePosition;
            const player2BasePos = gameState.player2.basePosition;
            const baseSafeRadius = 40; // ç«å±±éœ€è¦æ›´å¤§çš„å®‰å…¨è·ç¦»

            // æ£€æŸ¥æ˜¯å¦åœ¨åŸºåœ°å®‰å…¨åŒºåŸŸå†…
            const distToBase1 = Math.sqrt(
                Math.pow(x - player1BasePos.x, 2) +
                Math.pow(z - player1BasePos.z, 2)
            );

            const distToBase2 = Math.sqrt(
                Math.pow(x - player2BasePos.x, 2) +
                Math.pow(z - player2BasePos.z, 2)
            );

            // å¦‚æœåœ¨åŸºåœ°å®‰å…¨åŒºåŸŸå†…ï¼Œè¿”å›null
            if (distToBase1 < baseSafeRadius || distToBase2 < baseSafeRadius) {
                return null; // ä¸åœ¨åŸºåœ°é™„è¿‘ç”Ÿæˆç«å±±
            }
            const volcanoGroup = new THREE.Group();

            // ç«å±±ä¸»ä½“
            const coneGeometry = new THREE.ConeGeometry(8, 15, 32);
            const coneMaterial = new THREE.MeshStandardMaterial({
                color: 0x8B4513,
                roughness: 0.9
            });
            const volcano = new THREE.Mesh(coneGeometry, coneMaterial);
            volcano.position.y = 7.5;
            volcanoGroup.add(volcano);

            // ç«å±±å£
            const craterGeometry = new THREE.CylinderGeometry(3, 5, 2, 32);
            const craterMaterial = new THREE.MeshStandardMaterial({
                color: 0xFF4500,
                emissive: 0xFF4500,
                emissiveIntensity: 0.3
            });
            const crater = new THREE.Mesh(craterGeometry, craterMaterial);
            crater.position.y = 14;
            volcanoGroup.add(crater);

            volcanoGroup.position.set(x, 0, z);
            volcanoGroup.userData = {
                type: 'volcano',
                cooldown: 0,
                warning: false,
                active: false
            };

            return volcanoGroup;
        }

        // åˆ›å»ºå±±è„‰
        function createMountains() {
            const mountainGeometry = new THREE.ConeGeometry(20, 40, 32);
            const mountainMaterial = new THREE.MeshStandardMaterial({
                color: 0xFFFFFF,
                roughness: 0.8
            });

            // åœ¨è¾¹ç•Œå¤„æ·»åŠ å±±è„‰
            const positions = [
                { x: -120, z: -120 },
                { x: 120, z: -120 },
                { x: -120, z: 120 },
                { x: 120, z: 120 }
            ];

            positions.forEach(pos => {
                const mountain = new THREE.Mesh(mountainGeometry, mountainMaterial);
                mountain.position.set(pos.x, 20, pos.z);
                mountain.castShadow = true;
                gameState.scene.add(mountain);
            });
        }

        // åˆ›å»ºåŸºåœ°
        function createBase(position, color) {
            const baseGroup = new THREE.Group();

            // åŸºåœ°åº•åº§
            const baseGeometry = new THREE.BoxGeometry(30, 2, 30);
            const baseMaterial = new THREE.MeshStandardMaterial({
                color: color,
                emissive: color,
                emissiveIntensity: 0.3,
                transparent: true,
                opacity: 0.4,
                side: THREE.DoubleSide
            });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.position.y = 1;
            base.receiveShadow = true;
            baseGroup.add(base);

            // åŸºåœ°é˜²æŠ¤ç½©
            const shieldGeometry = new THREE.SphereGeometry(18, 32, 32);
            const shieldMaterial = new THREE.MeshStandardMaterial({
                color: color,
                emissive: color,
                emissiveIntensity: 0.2,
                transparent: true,
                opacity: 0.2,
                side: THREE.DoubleSide,
                wireframe: true
            });
            const shield = new THREE.Mesh(shieldGeometry, shieldMaterial);
            shield.position.y = 8;
            baseGroup.add(shield);

            baseGroup.position.set(position.x, position.y, position.z);
            baseGroup.userData = {
                type: 'base',
                safeRadius: 20,
                color: color
            };

            return baseGroup;
        }


        // æ›´æ–°åŸºåœ°è¡€é‡æ˜¾ç¤º
        function updateBaseHealthDisplay(playerKey) {
            const player = gameState[playerKey];
            if (!player || !player.baseHealthDisplay) {
                return;
            }

            const healthDisplay = player.baseHealthDisplay;

            // æ£€æŸ¥ healthDisplay æ˜¯å¦å·²è¢«é”€æ¯
            if (!healthDisplay.parent) {
                player.baseHealthDisplay = null;
                return;
            }

            const healthBar = healthDisplay.userData.healthBar;
            const sprite = healthDisplay.userData.textSprite;
            const ctx = healthDisplay.userData.ctx;
            const canvas = healthDisplay.userData.canvas;

            if (healthBar && healthBar.material) {
                // æ›´æ–°è¡€é‡æ¡å®½åº¦
                const healthRatio = player.baseHp / 50;
                healthBar.scale.x = Math.max(0, healthRatio);

                // æ ¹æ®è¡€é‡æ”¹å˜é¢œè‰²
                if (healthRatio > 0.5) {
                    healthBar.material.color.set(playerKey === 'player1' ? 0x00FF00 : 0x00AAFF);
                } else if (healthRatio > 0.25) {
                    healthBar.material.color.set(0xFFFF00);
                } else {
                    healthBar.material.color.set(0xFF0000);
                }
            }

            if (sprite && ctx && canvas) {
                // æ›´æ–°è¡€é‡æ•°å€¼
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // ç»˜åˆ¶èƒŒæ™¯
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // ç»˜åˆ¶è¡€é‡æ•°å€¼
                ctx.font = 'bold 40px Arial';
                ctx.fillStyle = '#FFFFFF';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const displayHp = Math.max(0, Math.ceil(player.baseHp));
                ctx.fillText(displayHp.toString(), 64, 32);

                // æ›´æ–°çº¹ç†
                if (sprite.material && sprite.material.map) {
                    sprite.material.map.needsUpdate = true;
                }
            }

            // åŸºåœ°è¢«æ‘§æ¯æ—¶ç§»é™¤æ˜¾ç¤º
            if (player.baseHp <= 0) {
                // ä¸åœ¨è¿™é‡Œç§»é™¤ï¼Œè®© destroyBase å¤„ç†
            }
        }
        function showBaseThreatWarning(position) {
            if (Math.random() > 0.1) return; // é™ä½é¢‘ç‡

            const warningGeometry = new THREE.RingGeometry(15, 17, 16);
            const warningMaterial = new THREE.MeshBasicMaterial({
                color: 0xFF0000,
                transparent: true,
                opacity: 0.3,
                side: THREE.DoubleSide
            });
            const warningRing = new THREE.Mesh(warningGeometry, warningMaterial);
            warningRing.rotation.x = -Math.PI / 2;
            warningRing.position.set(position.x, 0.1, position.z);

            gameState.scene.add(warningRing);

            // 1ç§’åç§»é™¤
            setTimeout(() => {
                if (warningRing.parent) {
                    gameState.scene.remove(warningRing);
                }
            }, 1000);
        }
        // åˆ›å»ºå•ä¸ªåŸºåœ°
        function createBases() {
            // ç©å®¶1åŸºåœ°
            const base1 = createBase(
                { x: -80, y: 0, z: -80 },
                0xFF7F00,
                'player1' // ä¼ é€’ playerKey
            );
            gameState.scene.add(base1);
            gameState.player1.baseObject = base1;
            gameState.player1.basePosition = { x: -80, y: 0, z: -80 };

            // ç©å®¶2åŸºåœ°
            const base2 = createBase(
                { x: 80, y: 0, z: 80 },
                0x4169E1,
                'player2' // ä¼ é€’ playerKey
            );
            gameState.scene.add(base2);
            gameState.player2.baseObject = base2;
            gameState.player2.basePosition = { x: 80, y: 0, z: 80 };
        }
        // åˆ›å»ºè›‡
        function createSnakes() {
            // ç©å®¶1çš„è›‡
            const snake1 = createSnake(
                gameState.player1.position,
                gameState.player1.direction,
                0xFF7F00
            );
            gameState.scene.add(snake1);
            gameState.player1.snake = snake1;

            // åˆå§‹åŒ–è›‡æ®µ
            for (let i = 0; i < 5; i++) {
                const segment = createSnakeSegment(
                    gameState.player1.position.x - i * 2,
                    gameState.player1.position.y - 0.25,
                    gameState.player1.position.z,
                    0xFFA500
                );
                gameState.scene.add(segment);
                gameState.player1.segments.push(segment);
            }

            // ç©å®¶2çš„è›‡
            const snake2 = createSnake(
                gameState.player2.position,
                gameState.player2.direction,
                0x4169E1
            );
            gameState.scene.add(snake2);
            gameState.player2.snake = snake2;

            // åˆå§‹åŒ–è›‡æ®µ
            for (let i = 0; i < 5; i++) {
                const segment = createSnakeSegment(
                    gameState.player2.position.x + i * 2,
                    gameState.player2.position.y - 0.25,
                    gameState.player2.position.z,
                    0x87CEEB
                );
                gameState.scene.add(segment);
                gameState.player2.segments.push(segment);
            }
        }

        // åˆ›å»ºè›‡å¤´ï¼ˆåœ¨ç¬¬ä¸€è§†è§’ä¸­ï¼Œè›‡å¤´ä¸å¯è§ï¼Œä½†ä¿ç•™ç”¨äºç¢°æ’æ£€æµ‹ï¼‰
        function createSnake(position, direction, color) {
            // åœ¨ç¬¬ä¸€è§†è§’ä¸­ï¼Œæˆ‘ä»¬ä¸éœ€è¦æ¸²æŸ“è›‡å¤´æ¨¡å‹
            // ä½†ä¸ºäº†ç¢°æ’æ£€æµ‹ï¼Œæˆ‘ä»¬åˆ›å»ºä¸€ä¸ªä¸å¯è§çš„ç«‹æ–¹ä½“
            const snakeHead = new THREE.Mesh(
                new THREE.BoxGeometry(2, 2, 2),
                new THREE.MeshBasicMaterial({ visible: false })
            );
            snakeHead.position.set(position.x, position.y, position.z);
            snakeHead.userData = { type: 'snake' };
            return snakeHead;
        }

        // åˆ›å»ºè›‡æ®µ
        function createSnakeSegment(x, y, z, color) {
            const geometry = new THREE.BoxGeometry(2, 2, 2);
            const material = new THREE.MeshStandardMaterial({
                color: color,
                roughness: 0.5
            });
            const segment = new THREE.Mesh(geometry, material);
            segment.position.set(x, y, z);
            segment.castShadow = true;
            segment.userData = { type: 'snakeSegment' };
            return segment;
        }

        // ç”Ÿæˆé£Ÿç‰©
        function generateFood() {
            for (let i = 0; i < 20; i++) {
                const food = createFood(
                    Math.random() * 200 - 100,
                    0.5,
                    Math.random() * 200 - 100
                );
                gameState.food.push(food);
                gameState.scene.add(food);
            }
        }

        // åˆ›å»ºé£Ÿç‰©
        function createFood(x, y, z) {
            const foodGroup = new THREE.Group();

            // é£Ÿç‰©ä¸»ä½“
            const foodGeometry = new THREE.SphereGeometry(0.8, 16, 16);
            const foodMaterial = new THREE.MeshStandardMaterial({
                color: 0x00FF00,
                emissive: 0x00FF00,
                emissiveIntensity: 0.2
            });
            const food = new THREE.Mesh(foodGeometry, foodMaterial);
            foodGroup.add(food);

            // é£Ÿç‰©èŒ
            const stemGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.5, 8);
            const stemMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22 });
            const stem = new THREE.Mesh(stemGeometry, stemMaterial);
            stem.position.y = 0.5;
            foodGroup.add(stem);

            foodGroup.position.set(x, y, z);
            foodGroup.userData = { type: 'food' };

            return foodGroup;
        }

        // ç”Ÿæˆé­”æ³•çƒ
        function generateMagicBalls() {
            const ballTypes = ['invincible', 'health', 'reverse', 'attack', 'bomb'];

            for (let i = 0; i < 10; i++) {
                const type = ballTypes[Math.floor(Math.random() * ballTypes.length)];
                const ball = createMagicBall(
                    Math.random() * 200 - 100,
                    0.5,
                    Math.random() * 200 - 100,
                    type
                );
                gameState.magicBalls.push(ball);
                gameState.scene.add(ball);
            }
        }

        // åˆ›å»ºé­”æ³•çƒ
        function createMagicBall(x, y, z, type) {
            const geometry = new THREE.SphereGeometry(1, 16, 16);
            let material;

            switch (type) {
                case 'invincible':
                    material = new THREE.MeshStandardMaterial({
                        color: 0xFFFF00,
                        emissive: 0xFFFF00,
                        emissiveIntensity: 0.5
                    });
                    break;
                case 'health':
                    material = new THREE.MeshStandardMaterial({
                        color: 0xFF0000,
                        emissive: 0xFF0000,
                        emissiveIntensity: 0.5
                    });
                    break;
                case 'reverse':
                    material = new THREE.MeshStandardMaterial({
                        color: 0x800080,
                        emissive: 0x800080,
                        emissiveIntensity: 0.5
                    });
                    break;
                case 'attack':
                    material = new THREE.MeshStandardMaterial({
                        color: 0x87CEEB,
                        emissive: 0x87CEEB,
                        emissiveIntensity: 0.5
                    });
                    break;
                case 'bomb':
                    material = new THREE.MeshStandardMaterial({
                        color: 0xFF8C00,
                        emissive: 0xFF8C00,
                        emissiveIntensity: 0.5
                    });
                    break;
            }

            const ball = new THREE.Mesh(geometry, material);
            ball.position.set(x, y, z);
            ball.userData = { type: 'magicBall', ballType: type };

            return ball;
        }

        // æ›´æ–°ç›¸æœºä½ç½®å’Œæœå‘ï¼ˆç¬¬ä¸€è§†è§’ï¼‰
        function updateCameras() {
            // ç©å®¶1ç›¸æœº - æ–œ45åº¦ä¿¯è§†è§†è§’
            const p1 = gameState.player1;
            const p1Camera = p1.camera;

            // ç›¸æœºé«˜åº¦å’Œè·ç¦»
            const cameraHeight = 50;  // ä¿¯è§†é«˜åº¦
            const cameraDistance = 40; // è·ç¦»ç©å®¶æ°´å¹³è·ç¦»

            // ç›¸æœºä½ç½®ï¼šåœ¨ç©å®¶æ–œä¸Šæ–¹45åº¦è§’
            p1Camera.position.set(
                p1.position.x + cameraDistance, // Xæ–¹å‘åç§»
                p1.position.y + cameraHeight,   // é«˜åº¦
                p1.position.z + cameraDistance  // Zæ–¹å‘åç§»
            );

            // ç›¸æœºæœå‘ï¼šçœ‹å‘ç©å®¶ä½ç½®
            p1Camera.lookAt(
                p1.position.x,
                p1.position.y + 10, // ç¨å¾®çœ‹å‘ç©å®¶ä¸Šæ–¹ä¸€ç‚¹
                p1.position.z
            );

            // ç©å®¶2ç›¸æœº - åŒæ ·çš„ä¿¯è§†è§†è§’
            const p2 = gameState.player2;
            const p2Camera = p2.camera;

            p2Camera.position.set(
                p2.position.x + cameraDistance,
                p2.position.y + cameraHeight,
                p2.position.z + cameraDistance
            );

            p2Camera.lookAt(
                p2.position.x,
                p2.position.y + 10,
                p2.position.z
            );
        }


        function updateInvincibleParticles(playerKey, deltaTime) {
            const player = gameState[playerKey];
            if (!player.isInvincible || !player.invincibleParticles) return;

            const particleGroup = player.invincibleParticles;
            const position = player.position;

            // æ›´æ–°ç²’å­ç»„ä½ç½®åˆ°è›‡çš„ä½ç½®
            particleGroup.position.set(position.x, position.y + 2, position.z);

            // æ›´æ–°å•ä¸ªç²’å­çš„æ—‹è½¬å’Œç§»åŠ¨
            particleGroup.children.forEach((particle, index) => {
                if (particle.userData) {
                    particle.userData.angle += particle.userData.speed * deltaTime;

                    // ç²’å­å›´ç»•è›‡æ—‹è½¬
                    particle.position.x = Math.cos(particle.userData.angle) * particle.userData.radius;
                    particle.position.z = Math.sin(particle.userData.angle) * particle.userData.radius;
                    particle.position.y = Math.sin(particle.userData.angle + index) * 1.5;

                    // ç²’å­é—ªçƒæ•ˆæœ
                    particle.material.opacity = 0.3 + 0.4 * Math.sin(gameState.gameTime * 5 + index);
                }
            });
        }
        // æ›´æ–°æ¸¸æˆ
        function update() {
            if (!clock) {
                clock = new THREE.Clock();
            }

            const deltaTime = clock.getDelta();

            if (gameState.running) {
                gameState.gameTime += deltaTime;
                updateGameTime();

                // === æ°¸è¿œæ›´æ–°çš„æ¸¸æˆå…ƒç´ ï¼ˆæ— è®ºæ˜¯å¦æš‚åœï¼‰===
                // è¿™äº›åº”è¯¥æ°¸è¿œè¿è¡Œï¼Œä¸å—ç©å®¶æš‚åœå½±å“ï¼š
                updateBullets(deltaTime);           // å­å¼¹ç»§ç»­é£è¡Œ
                updateExplosions(deltaTime);        // çˆ†ç‚¸æ•ˆæœç»§ç»­
                updateExplosionFragments(deltaTime);// ç¢ç‰‡æ•ˆæœç»§ç»­
                updateEnvironment(deltaTime);       // ç¯å¢ƒæ•ˆæœç»§ç»­
                updateCameras();                    // ç›¸æœºç»§ç»­æ›´æ–°
                renderScenes();                     // ç»§ç»­æ¸²æŸ“
                updateUI();                         // UIç»§ç»­æ›´æ–°

                // === æ£€æŸ¥æ¸¸æˆç»“æŸï¼ˆæ— è®ºæ˜¯å¦æš‚åœï¼‰===
                checkGameEnd();

                // === åˆ†åˆ«æ›´æ–°ä¸¤ä¸ªç©å®¶ï¼Œä½†åªæ§åˆ¶è›‡çš„ç§»åŠ¨ ===

                // ç©å®¶1ï¼šå³ä½¿æš‚åœä¹Ÿè¦æ›´æ–°çŠ¶æ€ï¼ˆæ¯”å¦‚æ— æ•Œæ—¶é—´å€’è®¡æ—¶ï¼‰
                updatePlayerStatus('player1', deltaTime);
                moveSnake('player1', deltaTime);
                checkCollisions('player1');
                updatePlayerStatus('player2', deltaTime);
                moveSnake('player2', deltaTime);
                checkCollisions('player2');

            }
        }

        // æ¸²æŸ“åœºæ™¯ï¼ˆä¸¤ä¸ªåˆ†å±è§†è§’ï¼‰
        function renderScenes() {
            // æ¸²æŸ“ç©å®¶1è§†è§’
            gameState.player1.renderer.render(gameState.scene, gameState.player1.camera);

            // æ¸²æŸ“ç©å®¶2è§†è§’
            gameState.player2.renderer.render(gameState.scene, gameState.player2.camera);
        }

        // æ›´æ–°æ¸¸æˆæ—¶é—´æ˜¾ç¤º
        function updateGameTime() {
            const minutes = Math.floor(gameState.gameTime / 60);
            const seconds = Math.floor(gameState.gameTime % 60);
            gameTimeElement.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        function updatePlayerStatus(playerKey, deltaTime) {
            const player = gameState[playerKey];

            // æ›´æ–°çŠ¶æ€æ—¶é—´
            if (player.status !== 'normal' && player.statusTime > 0) {
                player.statusTime -= deltaTime;
                if (player.statusTime <= 0) {
                    player.status = 'normal';
                    player.statusTime = 0;
                }
            }

            // æ›´æ–°ä¿¯å†²çŠ¶æ€
            if (player.isDashing && player.dashDuration > 0) {
                player.dashDuration -= deltaTime;
                if (player.dashDuration <= 0) {
                    player.isDashing = false;
                    player.dashDuration = 0;
                }
            }

            // é­”æ³•è›‡è‡ªåŠ¨ç”Ÿæˆé­”æ³•çƒ
            if (player.type === 'magic') {
                player.lastMagicGenerateTime += deltaTime;
                if (player.lastMagicGenerateTime >= 20) {
                    player.lastMagicGenerateTime = 0;
                    generateRandomMagicBall(playerKey);
                }
            }

            // æ›´æ–°æ”»å‡»æ¨¡å¼ä¸‹çš„è‡ªåŠ¨å°„å‡»
            if (player.status === 'attacking') {
                player.lastAttackTime = (player.lastAttackTime || 0) + deltaTime;
                if (player.lastAttackTime >= 0.4) {
                    player.lastAttackTime = 0;
                    shootBullet(playerKey);
                }
            }
        }

        // ä¸ºç©å®¶ç”Ÿæˆéšæœºé­”æ³•çƒ
        function generateRandomMagicBall(playerKey) {
            const player = gameState[playerKey];
            if (player.magicBalls.length >= 5) return;

            const rand = Math.random();
            let ballType;

            if (rand < 0.4) ballType = 'attack';      // 40%
            else if (rand < 0.7) ballType = 'health'; // 30%
            else if (rand < 0.9) ballType = 'invincible'; // 20%
            else ballType = 'reverse';                // 10%

            player.magicBalls.push(ballType);
            updateMagicBallsDisplay(playerKey);
        }
        // æ›´æ–°è›‡çš„æœå‘ï¼ˆç”¨äºè›‡å¤´æ¨¡å‹ï¼‰
        function updateSnakeOrientation(playerKey) {
            const player = gameState[playerKey];
            const snake = player.snake;
            if (!snake) return;

            // æ ¹æ®æ–¹å‘æ—‹è½¬è›‡å¤´
            const direction = player.direction;
            if (direction.x !== 0 || direction.z !== 0) {
                // è®¡ç®—æ—‹è½¬è§’åº¦
                const angle = Math.atan2(direction.z, direction.x);
                snake.rotation.y = -angle + Math.PI / 2;
            }
        }
        function getClosestPointOnSegment(px, pz, x1, z1, x2, z2) {
            const A = px - x1;
            const B = pz - z1;
            const C = x2 - x1;
            const D = z2 - z1;

            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            let param = -1;

            if (lenSq !== 0) {
                param = dot / lenSq;
            }

            let xx, zz;

            if (param < 0) {
                xx = x1;
                zz = z1;
            } else if (param > 1) {
                xx = x2;
                zz = z2;
            } else {
                xx = x1 + param * C;
                zz = z1 + param * D;
            }

            return { x: xx, z: zz };
        }
        function checkWallCollision(playerKey) {
            const player = gameState[playerKey];
            const currentTime = performance.now();
            const timeSinceLastCollision = currentTime - lastWallCollisionTime[playerKey];

            for (let i = gameState.walls.length - 1; i >= 0; i--) {
                const wall = gameState.walls[i];
                const wallData = wall.userData;

                if (!wallData) continue;

                // è®¡ç®—ç©å®¶åˆ°å¢™çº¿æ®µçš„æœ€è¿‘ç‚¹
                const closestPoint = getClosestPointOnSegment(
                    player.position.x, player.position.z,
                    wallData.start.x, wallData.start.z,
                    wallData.end.x, wallData.end.z
                );

                // è®¡ç®—è·ç¦»
                const distance = Math.sqrt(
                    Math.pow(player.position.x - closestPoint.x, 2) +
                    Math.pow(player.position.z - closestPoint.z, 2)
                );

                // è€ƒè™‘å¢™çš„å®½åº¦ï¼ˆ0.5ï¼‰å’Œç©å®¶çš„åŠå¾„ï¼ˆ1.5ï¼‰
                const collisionDistance = 0.5 + 1.5;

                if (distance < collisionDistance) {
                    // å¦‚æœè·ç¦»ä¸Šæ¬¡æ’å¢™ä¸åˆ°1ç§’ï¼Œè·³è¿‡ä¼¤å®³
                    if (timeSinceLastCollision > 1000) {
                        applyDamage(playerKey, 5, 'wall');
                        lastWallCollisionTime[playerKey] = currentTime;
                    }

                    // æ’çƒ‚å¢™
                    gameState.scene.remove(wall);
                    gameState.walls.splice(i, 1);

                    // æ˜¾ç¤ºå¢™è¢«æ’çƒ‚çš„æ•ˆæœ
                    showWallDestroyEffect({ x: closestPoint.x, y: 1, z: closestPoint.z });

                    break;
                }
            }
        }
        function showWallDestroyEffect(position) {
            // åˆ›å»ºç¢ç‰‡ç²’å­æ•ˆæœ
            const fragmentCount = 8;

            for (let i = 0; i < fragmentCount; i++) {
                const fragmentGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
                const fragmentMaterial = new THREE.MeshStandardMaterial({
                    color: 0x808080,
                    roughness: 0.8
                });
                const fragment = new THREE.Mesh(fragmentGeometry, fragmentMaterial);

                fragment.position.copy(position);
                fragment.position.y = 0.5; // ä»åœ°é¢é«˜åº¦å¼€å§‹

                // éšæœºé€Ÿåº¦å’Œæ–¹å‘
                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 8,
                    Math.random() * 4 + 2,
                    (Math.random() - 0.5) * 8
                );

                fragment.userData = {
                    velocity: velocity,
                    lifeTime: 1.5,
                    rotationSpeed: new THREE.Vector3(
                        Math.random() * 0.2 - 0.1,
                        Math.random() * 0.2 - 0.1,
                        Math.random() * 0.2 - 0.1
                    )
                };

                gameState.scene.add(fragment);

                // æ·»åŠ ç¢ç‰‡åˆ°ä¸´æ—¶æ•°ç»„ï¼Œç”¨äºæ›´æ–°
                if (!gameState.wallFragments) {
                    gameState.wallFragments = [];
                }
                gameState.wallFragments.push(fragment);
            }
        }
        function checkSnakeCollision(playerKey) {
            const player = gameState[playerKey];
            const otherPlayerKey = playerKey === 'player1' ? 'player2' : 'player1';
            const otherPlayer = gameState[otherPlayerKey];

            const currentTime = performance.now();
            const collisionCooldown = 500;

            // ä½¿ç”¨gameStateä¸­çš„lastCollisionTime
            if (currentTime - gameState.lastCollisionTime[playerKey] < collisionCooldown) {
                return;
            }

            // 1. åªæ£€æµ‹ä¸å¯¹æ–¹è›‡å¤´çš„ç¢°æ’
            const distanceToOtherHead = Math.sqrt(
                Math.pow(player.position.x - otherPlayer.position.x, 2) +
                Math.pow(player.position.z - otherPlayer.position.z, 2)
            );

            const headCollisionDistance = 5;

            if (distanceToOtherHead < headCollisionDistance) {

                const damage = 1;
                if (applyDamage(playerKey, damage, 'headCollision')) {
                    showDamageEffect(playerKey);
                }
                if (applyDamage(otherPlayerKey, damage, 'headCollision')) {
                    showDamageEffect(otherPlayerKey);
                }
                
                recordDamageDealt(playerKey, damage, otherPlayerKey, 'headCollision');
                recordDamageDealt(otherPlayerKey, damage, playerKey, 'headCollision');
                if (gameState[playerKey].hp <= 0) {
                    gameState[playerKey].deathReason = `ä¸${otherPlayerKey === 'player1' ?
                        localStorage.getItem('username') || 'ç©å®¶1' :
                        localStorage.getItem('player2_username') || 'ç©å®¶2'}è¿é¢ç›¸æ’èº«äº¡`;
                }
                // æ›´æ–°ç¢°æ’æ—¶é—´
                gameState.lastCollisionTime[playerKey] = currentTime;
                gameState.lastCollisionTime[otherPlayerKey] = currentTime;

                return;
            }

            // 2. ç§»é™¤è‡ªå·±æ’è‡ªå·±çš„æ£€æµ‹ï¼ˆå®Œå…¨æ³¨é‡Šæ‰ï¼‰
            // ä¸æ£€æµ‹è‡ªå·±æ’è‡ªå·±

            // 3. æ£€æµ‹ä¸å¯¹æ–¹è›‡èº«ä½“çš„ç¢°æ’ï¼ˆæ”¾å®½æ¡ä»¶ï¼‰
            for (let i = 2; i < otherPlayer.segments.length; i++) {
                const segment = otherPlayer.segments[i];
                const distance = Math.sqrt(
                    Math.pow(player.position.x - segment.position.x, 2) +
                    Math.pow(player.position.z - segment.position.z, 2)
                );

                const bodyCollisionDistance = 3.5;

                if (distance < bodyCollisionDistance) {
                    // åªæœ‰æ’åˆ°çš„è›‡æ‰è¡€
                    const damage = 1;
                    if (applyDamage(playerKey, damage, 'bodyCollision')) {
                        showDamageEffect(playerKey);
                                        // è®¾ç½®æ­»äº¡åŸå› 
                        if (gameState[playerKey].hp <= 0) {
                            gameState[playerKey].deathReason = `æ’åˆ°${otherPlayerKey === 'player1' ?
                                localStorage.getItem('username') || 'ç©å®¶1' :
                                localStorage.getItem('player2_username') || 'ç©å®¶2'}çš„è›‡èº«èº«äº¡`;
                        }
                    }
                    recordDamageDealt(otherPlayerKey, damage, playerKey, 'bodyCollision');
                    // æ›´æ–°ç¢°æ’æ—¶é—´
                    gameState.lastCollisionTime[playerKey] = currentTime;

                    // è¢«æ’çš„è›‡ä»ç¢°æ’ç‚¹æˆªæ–­ï¼ˆå¯é€‰ï¼Œå…ˆæ³¨é‡Šæ‰ï¼‰

                    if (i < otherPlayer.segments.length - 3 && i > 5) {
                        const segmentsToRemove = otherPlayer.segments.slice(i + 1);
                        segmentsToRemove.forEach(seg => {
                            if (seg.parent) {
                                gameState.scene.remove(seg);
                            }
                        });

                        otherPlayer.segments = otherPlayer.segments.slice(0, i + 1);
                    }


                    break;
                }
            }
        }

        // æ›´æ–°å¢™ç¢ç‰‡
        function updateWallFragments(deltaTime) {
            if (!gameState.wallFragments || gameState.wallFragments.length === 0) return;

            for (let i = gameState.wallFragments.length - 1; i >= 0; i--) {
                const fragment = gameState.wallFragments[i];
                const data = fragment.userData;

                // åº”ç”¨é‡åŠ›
                data.velocity.y -= 9.8 * deltaTime;

                // æ›´æ–°ä½ç½®
                fragment.position.x += data.velocity.x * deltaTime;
                fragment.position.y += data.velocity.y * deltaTime;
                fragment.position.z += data.velocity.z * deltaTime;

                // æ›´æ–°æ—‹è½¬
                fragment.rotation.x += data.rotationSpeed.x;
                fragment.rotation.y += data.rotationSpeed.y;
                fragment.rotation.z += data.rotationSpeed.z;

                // å‡å°‘ç”Ÿå‘½å‘¨æœŸ
                data.lifeTime -= deltaTime;

                // å¦‚æœç¢°åˆ°åœ°é¢æˆ–ç”Ÿå‘½å‘¨æœŸç»“æŸ
                if (fragment.position.y < 0 || data.lifeTime <= 0) {
                    gameState.scene.remove(fragment);
                    gameState.wallFragments.splice(i, 1);
                }
            }
        }
        // æ›´æ–°è›‡çš„æ–¹å‘
        function updateSnakeDirection(playerKey) {
            const player = gameState[playerKey];

            // ç©å®¶1æ§åˆ¶
            if (playerKey === 'player1') {
                if (player.isReversed) {
                    // åå‘æ§åˆ¶æ—¶ï¼ŒæŒ‰é”®æ˜ å°„ç›¸å
                    if ((gameState.keys['s'] || gameState.keys['S']) && player.direction.z <= 0) {
                        player.targetDirection.x = 0;
                        player.targetDirection.z = -1; // åŸæœ¬çš„Så˜æˆå‘ä¸Š
                    } else if ((gameState.keys['w'] || gameState.keys['W']) && player.direction.z >= 0) {
                        player.targetDirection.x = 0;
                        player.targetDirection.z = 1; // åŸæœ¬çš„Wå˜æˆå‘ä¸‹
                    } else if ((gameState.keys['d'] || gameState.keys['D']) && player.direction.x <= 0) {
                        player.targetDirection.x = -1; // åŸæœ¬çš„Då˜æˆå‘å·¦
                        player.targetDirection.z = 0;
                    } else if ((gameState.keys['a'] || gameState.keys['A']) && player.direction.x >= 0) {
                        player.targetDirection.x = 1; // åŸæœ¬çš„Aå˜æˆå‘å³
                        player.targetDirection.z = 0;
                    }
                } else {
                    // æ­£å¸¸æ§åˆ¶
                    if ((gameState.keys['w'] || gameState.keys['W']) && player.direction.z <= 0) {
                        player.targetDirection.x = 0;
                        player.targetDirection.z = -1;
                    } else if ((gameState.keys['s'] || gameState.keys['S']) && player.direction.z >= 0) {
                        player.targetDirection.x = 0;
                        player.targetDirection.z = 1;
                    } else if ((gameState.keys['a'] || gameState.keys['A']) && player.direction.x <= 0) {
                        player.targetDirection.x = -1;
                        player.targetDirection.z = 0;
                    } else if ((gameState.keys['d'] || gameState.keys['D']) && player.direction.x >= 0) {
                        player.targetDirection.x = 1;
                        player.targetDirection.z = 0;
                    }
                }
            }
            // ç©å®¶2æ§åˆ¶
            else if (playerKey === 'player2') {
                if (player.isReversed) {
                    // åå‘æ§åˆ¶
                    if (gameState.keys['ArrowDown'] && player.direction.z <= 0) {
                        player.targetDirection.x = 0;
                        player.targetDirection.z = -1; // ä¸‹é”®å˜æˆä¸Š
                    } else if (gameState.keys['ArrowUp'] && player.direction.z >= 0) {
                        player.targetDirection.x = 0;
                        player.targetDirection.z = 1; // ä¸Šé”®å˜æˆä¸‹
                    } else if (gameState.keys['ArrowRight'] && player.direction.x <= 0) {
                        player.targetDirection.x = -1; // å³é”®å˜æˆå·¦
                        player.targetDirection.z = 0;
                    } else if (gameState.keys['ArrowLeft'] && player.direction.x >= 0) {
                        player.targetDirection.x = 1; // å·¦é”®å˜æˆå³
                        player.targetDirection.z = 0;
                    }
                } else {
                    // æ­£å¸¸æ§åˆ¶
                    if (gameState.keys['ArrowUp'] && player.direction.z <= 0) {
                        player.targetDirection.x = 0;
                        player.targetDirection.z = -1;
                    } else if (gameState.keys['ArrowDown'] && player.direction.z >= 0) {
                        player.targetDirection.x = 0;
                        player.targetDirection.z = 1;
                    } else if (gameState.keys['ArrowLeft'] && player.direction.x <= 0) {
                        player.targetDirection.x = -1;
                        player.targetDirection.z = 0;
                    } else if (gameState.keys['ArrowRight'] && player.direction.x >= 0) {
                        player.targetDirection.x = 1;
                        player.targetDirection.z = 0;
                    }
                }
            }
        }
        function updatePlayerStatusDisplay(playerKey) {
            const player = gameState[playerKey];

            // æ£€æŸ¥æ˜¯å¦å·²åˆå§‹åŒ–è›‡å¯¹è±¡
            if (!player.snake) return;

            // æ— æ•Œæ—¶è›‡å†’é‡‘å…‰
            if (player.isInvincible) {
                // ç¡®ä¿è›‡å¤´æœ‰æè´¨
                if (player.snake.material) {
                    // è›‡å¤´ä¸å¯è§ï¼Œä¸éœ€è¦ä¿®æ”¹æè´¨
                }

                // ç»™æ‰€æœ‰è›‡æ®µæ·»åŠ é‡‘å…‰æ•ˆæœ
                for (let i = 0; i < player.segments.length; i++) {
                    const segment = player.segments[i];
                    if (segment && segment.material) {
                        segment.material.color.set(0xFFFF00);
                        if (segment.material.emissive) {
                            segment.material.emissive.set(0xFFFF00);
                            segment.material.emissiveIntensity = 0.3;
                        }
                    }
                }

                // æ·»åŠ é‡‘è‰²ç²’å­æ•ˆæœ
                if (!player.invincibleParticles) {
                    createInvincibleParticles(playerKey);
                }
            } else {
                // æ¢å¤è›‡æ®µçš„åŸå§‹é¢œè‰²
                const segmentColor = playerKey === 'player1' ? 0xFFA500 : 0x87CEEB;
                for (let i = 0; i < player.segments.length; i++) {
                    const segment = player.segments[i];
                    if (segment && segment.material) {
                        segment.material.color.set(segmentColor);
                        if (segment.material.emissive) {
                            segment.material.emissive.set(0x000000);
                            if (segment.material.emissiveIntensity) {
                                segment.material.emissiveIntensity = 0;
                            }
                        }
                    }
                }

                // ç§»é™¤ç²’å­æ•ˆæœ
                if (player.invincibleParticles) {
                    removeInvincibleParticles(playerKey);
                }
            }
        }
        // åˆ›å»ºæ— æ•Œæ—¶çš„ç²’å­æ•ˆæœ
        function createInvincibleParticles(playerKey) {
            const player = gameState[playerKey];

            // åˆ›å»ºä¸€ä¸ªç²’å­ç»„
            const particleGroup = new THREE.Group();

            // åœ¨è›‡å‘¨å›´åˆ›å»ºä¸€äº›é‡‘è‰²ç²’å­
            for (let i = 0; i < 10; i++) {
                const particleGeometry = new THREE.SphereGeometry(0.4, 6, 6);
                const particleMaterial = new THREE.MeshBasicMaterial({
                    color: 0xFFFF00,
                    transparent: true,
                    opacity: 0.5
                });
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);

                // éšæœºä½ç½®ï¼ˆåœ¨è›‡å‘¨å›´ï¼‰
                particle.userData = {
                    angle: Math.random() * Math.PI * 2,
                    radius: 3 + Math.random() * 2,
                    speed: 1 + Math.random() * 1
                };

                particleGroup.add(particle);
            }

            particleGroup.userData = {
                type: 'invincibleParticles',
                playerKey: playerKey
            };

            gameState.scene.add(particleGroup);
            player.invincibleParticles = particleGroup;
        }

        // ç§»é™¤æ— æ•Œç²’å­æ•ˆæœ
        function removeInvincibleParticles(playerKey) {
            const player = gameState[playerKey];
            if (player.invincibleParticles && player.invincibleParticles.parent) {
                gameState.scene.remove(player.invincibleParticles);
                player.invincibleParticles = null;
            }
        }
        function updateSnakeSegments(playerKey) {
            const player = gameState[playerKey];
            const segments = player.segments;

            if (segments.length === 0) {
                // åˆå§‹åŒ–è›‡æ®µ
                for (let i = 0; i < 5; i++) {
                    const segment = createSnakeSegment(
                        player.position.x - i * 2,
                        player.position.y - 0.25,
                        player.position.z,
                        playerKey === 'player1' ? 0xFFA500 : 0x87CEEB
                    );
                    gameState.scene.add(segment);
                    segments.push(segment);
                }
                return;
            }

            // æ­£å¸¸æ›´æ–°è›‡æ®µä½ç½®
            // å°†æœ€åä¸€ä¸ªè›‡æ®µç§»åŠ¨åˆ°è›‡å¤´åé¢
            const lastSegment = segments[segments.length - 1];
            lastSegment.position.set(
                player.position.x,
                player.position.y + 1.25,
                player.position.z
            );

            // å°†æœ€åä¸€ä¸ªè›‡æ®µç§»åˆ°æ•°ç»„å¼€å¤´
            segments.unshift(segments.pop());
        }

        // ç§»åŠ¨è›‡
        function moveSnake(playerKey, deltaTime) {
            const player = gameState[playerKey];
            const snake = player.snake;
            if (!snake) return;
            if (player.paused) return;

            // è®¡ç®—ç§»åŠ¨é€Ÿåº¦
            let speed = 22 * deltaTime; // åŸºç¡€é€Ÿåº¦

            // åº”ç”¨è›‡ç±»å‹çš„é€Ÿåº¦åŠ æˆ - è¿™é‡Œéœ€è¦æ£€æŸ¥
            if (player.type === 'speed') {
                speed *= 1.5; // é€Ÿåº¦è›‡å¢åŠ 50%
            } else if (player.type === 'magic') {
                speed *= 1.15; // é­”æ³•è›‡å¢åŠ 15%
            }
            // åº”ç”¨é€Ÿåº¦å‡çº§
            speed *= player.speedMultiplier;

            // åº”ç”¨ä¿¯å†²åŠ é€Ÿ
            if (player.isDashing) {
                speed *= 3; // ä¿¯å†²æœŸé—´3å€é€Ÿåº¦
            }

            // åº”ç”¨æš´é£é›ªå‡é€Ÿ
            if (gameState.stormActive) {
                speed *= 0.8; // æš´é£é›ªä¸­å‡é€Ÿ20%
            }

            // æ›´æ–°æ–¹å‘
            updateSnakeDirection(playerKey);

            // ç›´æ¥è®¾ç½®æ–¹å‘
            if (player.targetDirection.x !== 0 || player.targetDirection.z !== 0) {
                player.direction.x = player.targetDirection.x;
                player.direction.z = player.targetDirection.z;
            }
            const prevX = player.position.x;
            const prevZ = player.position.z;
            // æ›´æ–°ä½ç½®
            player.position.x += player.direction.x * speed;
            player.position.z += player.direction.z * speed;

            // è¾¹ç•Œæ£€æŸ¥ï¼ˆä½¿ç”¨æ–°çš„è¾¹ç•Œå¤§å°100ï¼‰
            const boundary = 100;
            if (player.position.x < -boundary) player.position.x = boundary;
            if (player.position.x > boundary) player.position.x = -boundary;
            if (player.position.z < -boundary) player.position.z = boundary;
            if (player.position.z > boundary) player.position.z = -boundary;
            // è®¡ç®—ç§»åŠ¨è·ç¦»ï¼ˆåƒç´ è·ç¦»ï¼‰
            const distancePixels = Math.sqrt(
                Math.pow(player.position.x - prevX, 2) +
                Math.pow(player.position.z - prevZ, 2)
            );

            // è½¬æ¢ä¸ºç±³ï¼ˆ1ç±³ = 20åƒç´ ï¼‰
            const distanceMeters = distancePixels / 20;
            player.stats.totalDistance += distanceMeters;
            // æ›´æ–°è›‡å¤´ä½ç½®
            snake.position.set(
                player.position.x,
                player.position.y,
                player.position.z
            );

            // æ›´æ–°è›‡æ®µä½ç½®
            updateSnakeSegments(playerKey);
        }


        // æ›´æ–°è›‡æ®µä½ç½®
        function addSnakeSegment(playerKey) {
            const player = gameState[playerKey];

            // å¦‚æœè›‡æ®µæ•°é‡ä¸º0ï¼Œåˆ›å»ºç¬¬ä¸€ä¸ªæ®µ
            if (player.segments.length === 0) {
                const segment = createSnakeSegment(
                    player.position.x,
                    player.position.y - 0.25,
                    player.position.z,
                    playerKey === 'player1' ? 0xFFA500 : 0x87CEEB
                );
                gameState.scene.add(segment);
                player.segments.push(segment);
                return;
            }

            // è·å–æœ€åä¸€ä¸ªè›‡æ®µ
            const lastSegment = player.segments[player.segments.length - 1];

            // ä¿®æ”¹ï¼šæ¯æ¬¡åƒçƒå¢åŠ 3ä¸ªæ®µï¼ˆåŸæ¥æ˜¯1ä¸ªï¼‰
            for (let i = 0; i < 9; i++) {
                const newSegment = createSnakeSegment(
                    lastSegment.position.x,
                    lastSegment.position.y,
                    lastSegment.position.z,
                    playerKey === 'player1' ? 0xFFA500 : 0x87CEEB
                );
                gameState.scene.add(newSegment);
                player.segments.push(newSegment);
            }
        }


        function checkCollisions(playerKey, deltaTime) {
            const player = gameState[playerKey];
            const otherPlayerKey = playerKey === 'player1' ? 'player2' : 'player1';
            const otherPlayer = gameState[otherPlayerKey];

            // æ£€æŸ¥ä¸é£Ÿç‰©çš„ç¢°æ’
            for (let i = gameState.food.length - 1; i >= 0; i--) {
                const food = gameState.food[i];
                const distance = Math.sqrt(
                    Math.pow(player.position.x - food.position.x, 2) +
                    Math.pow(player.position.z - food.position.z, 2)
                );

                if (distance < 2) {
                    // åƒé£Ÿç‰©ï¼Œå¢åŠ åˆ†æ•°
                    player.score += 50;

                    // è›‡å˜é•¿ï¼šå¢åŠ 3ä¸ªæ®µ
                    addSnakeSegment(playerKey);

                    // ç§»é™¤é£Ÿç‰©
                    gameState.scene.remove(food);
                    gameState.food.splice(i, 1);

                    // ç”Ÿæˆæ–°é£Ÿç‰©
                    const newFood = createFood(
                        Math.random() * 200 - 100,
                        0.5,
                        Math.random() * 200 - 100
                    );
                    gameState.food.push(newFood);
                    gameState.scene.add(newFood);
                }
            }

            // æ£€æŸ¥ä¸é­”æ³•çƒçš„ç¢°æ’
            for (let i = gameState.magicBalls.length - 1; i >= 0; i--) {
                const ball = gameState.magicBalls[i];
                const distance = Math.sqrt(
                    Math.pow(player.position.x - ball.position.x, 2) +
                    Math.pow(player.position.z - ball.position.z, 2)
                );

                if (distance < 2) {
                    player.score += 100;
                    // æ”¶é›†é­”æ³•çƒ
                    if (player.magicBalls.length < 5) {
                        player.magicBalls.push(ball.userData.ballType);
                        updateMagicBallsDisplay(playerKey);
                    }

                    // è›‡å˜é•¿ï¼šå¢åŠ 3ä¸ªæ®µï¼ˆé­”æ³•çƒä¹Ÿå¢é•¿ï¼‰
                    addSnakeSegment(playerKey);

                    // ç§»é™¤é­”æ³•çƒ
                    gameState.scene.remove(ball);
                    gameState.magicBalls.splice(i, 1);

                    // ç”Ÿæˆæ–°é­”æ³•çƒ
                    const ballTypes = ['invincible', 'health', 'reverse', 'attack', 'bomb'];
                    const type = ballTypes[Math.floor(Math.random() * ballTypes.length)];
                    const newBall = createMagicBall(
                        Math.random() * 200 - 100,
                        0.5,
                        Math.random() * 200 - 100,
                        type
                    );
                    gameState.magicBalls.push(newBall);
                    gameState.scene.add(newBall);
                }
            }

            // ä¿®æ”¹ï¼šè°ƒç”¨æ–°çš„æ’å¢™æ£€æµ‹å‡½æ•°
            checkWallCollision(playerKey);

            checkSnakeCollision(playerKey);

            // æ£€æŸ¥ä¸å­å¼¹çš„ç¢°æ’
            for (let i = gameState.bullets.length - 1; i >= 0; i--) {
                const bullet = gameState.bullets[i];

                if (bullet.userData.owner === playerKey) continue;

                const distance = Math.sqrt(
                    Math.pow(player.position.x - bullet.position.x, 2) +
                    Math.pow(player.position.z - bullet.position.z, 2)
                );

                if (distance < 2) {
                    applyDamage(playerKey, 0.5, 'bullet');
                    gameState.scene.remove(bullet);
                    gameState.bullets.splice(i, 1);
                }
            }

            // æ£€æŸ¥ä¸åŸºåœ°çš„äº¤äº’
            checkBaseInteraction(playerKey);

            // æ£€æŸ¥ä¸å²©æµ†çš„ç¢°æ’
            if (gameState.mapType === 'volcano') {
                checkLavaDamage(playerKey);
            }
        }
        // æ˜¾ç¤ºå—ä¼¤æ•ˆæœ
        function showDamageEffect(playerKey) {
            const damageOverlay = playerKey === 'player1' ? p1DamageOverlay : p2DamageOverlay;

            // æ˜¾ç¤ºçº¢è‰²è¦†ç›–å±‚
            damageOverlay.style.opacity = '0.7';

            // æ·»åŠ é•œå¤´æ™ƒåŠ¨æ•ˆæœ
            const viewport = playerKey === 'player1' ?
                document.getElementById('player1-viewport') :
                document.getElementById('player2-viewport');
            viewport.classList.add('camera-shake');

            // 1ç§’åéšè—æ•ˆæœ
            setTimeout(() => {
                damageOverlay.style.opacity = '0';
                viewport.classList.remove('camera-shake');
            }, 300);
        }

        // åº”ç”¨ä¼¤å®³
        function applyDamage(playerKey, damage, source) {
            const player = gameState[playerKey];
            player.lastDamageSource = source;
            player.lastDamageAmount = damage;
            if (source === 'wall') {
                player.stats.damageTaken.wall += damage;
            } else if (source === 'headCollision' || source === 'bodyCollision') {
                player.stats.damageTaken.snakeCollision += damage;
            } else if (source === 'bullet' || source === 'baseBullet') {
                player.stats.damageTaken.bullet += damage;
            } else if (source === 'base') {
                player.stats.damageTaken.base += damage;
            } else if (source === 'lava') {
                player.stats.damageTaken.lava += damage;
            } else if (source === 'bomb') {
                player.stats.damageTaken.bomb += damage;
            }
            player.stats.damageTaken.total += damage;
            // æ£€æŸ¥æ— æ•ŒçŠ¶æ€
            if (player.isInvincible) {
                return false;
            }

            // æ£€æŸ¥æŠ¤ç›¾
            if (player.shield > 0) {
                const shieldDamage = Math.min(damage, player.shield);
                player.shield -= shieldDamage;
                damage -= shieldDamage;
                if (player.shield <= 0) {
                    player.shield = 0;
                }

                if (damage <= 0) return false;
            }

            // åšç¡¬è›‡ç‰¹æ€§ï¼šéå­å¼¹ç±»ä¼¤å®³å‡åŠ
            let finalDamage = damage;
            if (player.type === 'hard' && source !== 'bullet' && source !== 'baseBullet') {
                finalDamage *= 0.5;

                // å­å¼¹å…ç–«ï¼š50%æ¦‚ç‡å…ç–«å­å¼¹ä¼¤å®³
                if ((source === 'bullet' || source === 'baseBullet') && Math.random() < 0.5) {
                    return false;
                }
            }

            const oldHp = player.hp;
            player.hp -= finalDamage;
            if (player.hp < 0) player.hp = 0;

            // å¦‚æœæ­»äº¡ï¼Œè®¾ç½®æ­»äº¡åŸå› 
            if (oldHp > 0 && player.hp <= 0) {
                player.deathReason = getDeathReason(source, damage, player);
            }

            // è¿”å›æ˜¯å¦å®é™…é€ æˆäº†ä¼¤å®³
            return oldHp > player.hp;
        }
        function getDeathReason(source, damage, player) {
                const playerName = player === gameState.player1 ?
                    localStorage.getItem('username') || 'ç©å®¶1' :
                    localStorage.getItem('player2_username') || 'ç©å®¶2';

                const opponentName = player === gameState.player1 ?
                    localStorage.getItem('player2_username') || 'ç©å®¶2' :
                    localStorage.getItem('username') || 'ç©å®¶1';

                switch (source) {
                    case 'wall':
                        return `${playerName}æ’å¢™è€Œæ­»`;

                    case 'headCollision':
                        return `${playerName}è›‡å¤´ç›¸æ’è€Œæ­»`;
                    case 'bodyCollision':
                        return `${playerName}è›‡èº«ç›¸æ’èº«äº¡`;

                    case 'bullet':
                        return `${playerName}è¢«å­å¼¹å‡»ä¸­`;

                    case 'baseBullet':
                        return `${playerName}è¢«åŸºåœ°é˜²å¾¡ç³»ç»Ÿå‡»æ€`;

                    case 'base':
                        return `${playerName}åœ¨å¯¹æ–¹åŸºåœ°å†…è¢«å‡»æ¯™`;

                    case 'lava':
                        return `${playerName}è¢«å²©æµ†çƒ§æ­»`;

                    case 'bomb':
                        return `${playerName}è¢«ç‚¸å¼¹ç‚¸æ­»`;

                    case 'dash':
                        return `${playerName}ä¿¯å†²è¿‡çŒ›èº«äº¡`;

                    case 'storm':
                        return `${playerName}åœ¨æš´é£é›ªä¸­å†»æ­»`;

                    case 'magic':
                        return `${playerName}è¢«é­”æ³•æ•ˆæœè‡´æ­»`;

                    default:
                        return 'è¢«å‡»è´¥';
                }
            }
    function recordDamageDealt(dealerKey, damage, targetKey, source) {
        const dealer = gameState[dealerKey];

        if (source === 'headCollision' || source === 'bodyCollision') {
            dealer.stats.damageDealt.snakeCollision += damage;
        } else if (source === 'bullet' || source === 'baseBullet') {
            dealer.stats.damageDealt.bullet += damage;
        } else if (source === 'bomb') {
            dealer.stats.damageDealt.bomb += damage;
        } else if (source === 'base') {
            dealer.stats.damageDealt.baseDamage += damage;
        }

        // æ€»è¾“å‡ºä¼¤å®³ï¼ˆä¸åŒ…æ‹¬å¯¹åŸºåœ°çš„ä¼¤å®³ï¼‰
        if (source !== 'base') {
            dealer.stats.damageDealt.total += damage;
        }
    }
        // æ£€æŸ¥åŸºåœ°äº¤äº’
        // æ£€æŸ¥åŸºåœ°äº¤äº’ - ä¿®å¤å›è¡€éƒ¨åˆ†
        function checkBaseInteraction(playerKey) {
            const player = gameState[playerKey];
            const otherPlayerKey = playerKey === 'player1' ? 'player2' : 'player1';
            const otherPlayer = gameState[otherPlayerKey];

            // å¦‚æœè‡ªå·±çš„åŸºåœ°è¢«æ‘§æ¯äº†ï¼Œä¸èƒ½å›è¡€
            if (player.baseDestroyed) {
                // åŸºåœ°è¢«æ‘§æ¯ï¼Œä¸èƒ½å›è¡€
                player.lastHealTime = null;
            } else {
                // 1. æ£€æŸ¥è‡ªå·±åŸºåœ°ï¼ˆå›è¡€ï¼‰- åªåœ¨åŸºåœ°æœªè¢«æ‘§æ¯æ—¶æœ‰æ•ˆ
                const distanceToOwnBaseCenter = Math.sqrt(
                    Math.pow(player.position.x - player.basePosition.x, 2) +
                    Math.pow(player.position.z - player.basePosition.z, 2)
                );

                const baseRadius = 15;
                if (distanceToOwnBaseCenter < baseRadius) {
                    // æ¯ç§’å›1ç‚¹è¡€
                    const currentTime = performance.now();
                    if (!player.lastHealTime) player.lastHealTime = currentTime;

                    if (currentTime - player.lastHealTime > 100) {
                        if (player.hp < player.maxHp) {
                            player.hp += 0.1;
                            if (player.hp > player.maxHp) player.hp = player.maxHp;
                        }
                        player.lastHealTime = currentTime;
                    }
                }
            }

            // 2. æ£€æŸ¥å¯¹æ–¹åŸºåœ°ï¼ˆæ”»å‡»ï¼‰- åªåœ¨å¯¹æ–¹åŸºåœ°æœªè¢«æ‘§æ¯æ—¶æœ‰æ•ˆ
            if (!otherPlayer.baseDestroyed && otherPlayer.baseObject) {
                const distanceToOtherBaseCenter = Math.sqrt(
                    Math.pow(player.position.x - otherPlayer.basePosition.x, 2) +
                    Math.pow(player.position.z - otherPlayer.basePosition.z, 2)
                );

                const baseRadius = 15;
                if (distanceToOtherBaseCenter < baseRadius) {
                    // å¯¹ç©å®¶è‡ªèº«é€ æˆä¼¤å®³ï¼ˆæ¯ç§’1ç‚¹ï¼‰
                    const currentTime = performance.now();
                    if (!player.lastBaseDamageTime) player.lastBaseDamageTime = currentTime;

                    if (currentTime - player.lastBaseDamageTime > 1000) {
                        if (player.status !== 'invincible') {
                            const damage = player.type === 'hard' ? 0.5 : 1;
                            applyDamage(playerKey, damage, 'base');
                        }
                        player.lastBaseDamageTime = currentTime;
                    }

                    // å¯¹åŸºåœ°é€ æˆä¼¤å®³ï¼ˆæ¯ç§’3ç‚¹ï¼‰
                    if (!otherPlayer.lastBaseUnderAttackTime) {
                        otherPlayer.lastBaseUnderAttackTime = currentTime;
                    }

                    if (currentTime - otherPlayer.lastBaseUnderAttackTime > 1000) {
                        otherPlayer.baseHp -= 3;
                        if (otherPlayer.baseHp < 0) otherPlayer.baseHp = 0;
                        otherPlayer.lastBaseUnderAttackTime = currentTime;

                        // æ˜¾ç¤ºåŸºåœ°è¢«æ”»å‡»æ•ˆæœ
                        showBaseDamageEffect(otherPlayer.basePosition);

                        // åŸºåœ°è¢«æ‘§æ¯
                        if (otherPlayer.baseHp <= 0) {
                            destroyBase(otherPlayerKey);
                        }
                    }
                } else {
                    // ç¦»å¼€åŸºåœ°èŒƒå›´ï¼Œé‡ç½®è®¡æ—¶å™¨
                    player.lastBaseDamageTime = null;
                    if (otherPlayer) otherPlayer.lastBaseUnderAttackTime = null;
                }

                // 3. åŸºåœ°é˜²å¾¡ç³»ç»Ÿ - åªåœ¨åŸºåœ°æœªè¢«æ‘§æ¯æ—¶æœ‰æ•ˆ
                const defenseDetectionRange = baseRadius + 50;
                if (distanceToOtherBaseCenter < defenseDetectionRange) {
                    // åŸºåœ°é˜²å¾¡ï¼šæ¯1ç§’å‘å°„ä¸€æ¬¡å­å¼¹
                    const currentTime = performance.now();
                    if (!otherPlayer.lastBaseShotTime) {
                        otherPlayer.lastBaseShotTime = 0;
                    }

                    if (currentTime - otherPlayer.lastBaseShotTime > 1000) {
                        shootBaseBullet(otherPlayerKey, playerKey);
                        otherPlayer.lastBaseShotTime = currentTime;
                    }
                }
            } else {
                // å¯¹æ–¹åŸºåœ°å·²è¢«æ‘§æ¯ï¼Œæ¸…é™¤ç›¸å…³è®¡æ—¶å™¨
                player.lastBaseDamageTime = null;
                if (otherPlayer) {
                    otherPlayer.lastBaseUnderAttackTime = null;
                    otherPlayer.lastBaseShotTime = null;
                }
            }
        }
        function destroyBase(playerKey) {
            const player = gameState[playerKey];

            console.log(`${playerKey}åŸºåœ°è¢«å®Œå…¨æ‘§æ¯ï¼`);

            // 1. è®¾ç½®åŸºåœ°è¡€é‡ä¸º0
            player.baseHp = 0;

            // 2. ç§»é™¤åŸºåœ°å¯¹è±¡
            if (player.baseObject && player.baseObject.parent) {
                // åˆ›å»ºçˆ†ç‚¸æ•ˆæœ
                createBaseExplosion(player.basePosition);

                // ç§»é™¤åŸºåœ°
                gameState.scene.remove(player.baseObject);
                player.baseObject = null;
            }

            // 3. åœæ­¢åŸºåœ°çš„æ‰€æœ‰åŠŸèƒ½
            // ç§»é™¤åŸºåœ°é˜²å¾¡ç³»ç»Ÿçš„å¼•ç”¨å’Œè®¡æ—¶å™¨
            player.lastBaseShotTime = null;
            player.lastBaseUnderAttackTime = null;
            player.lastBaseDamageTime = null;

            // 4. æ ‡è®°åŸºåœ°å·²è¢«æ‘§æ¯
            player.baseDestroyed = true;

            // 5. æ›´æ–°UI
            updateUI();
        }
        // åˆ›å»ºåŸºåœ°çˆ†ç‚¸æ•ˆæœ
        function createBaseExplosion(position) {
            // åˆ›å»ºå¤§å‹çˆ†ç‚¸æ•ˆæœ
            const explosionGroup = new THREE.Group();

            // çˆ†ç‚¸ç«çƒ
            const fireGeometry = new THREE.SphereGeometry(8, 32, 32);
            const fireMaterial = new THREE.MeshStandardMaterial({
                color: 0xFF4500,
                emissive: 0xFF4500,
                emissiveIntensity: 0.9,
                transparent: true,
                opacity: 0.8
            });
            const fireball = new THREE.Mesh(fireGeometry, fireMaterial);
            explosionGroup.add(fireball);

            // çˆ†ç‚¸å†²å‡»æ³¢
            const shockwaveGeometry = new THREE.RingGeometry(5, 15, 32);
            const shockwaveMaterial = new THREE.MeshBasicMaterial({
                color: 0xFFFF00,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.6
            });
            const shockwave = new THREE.Mesh(shockwaveGeometry, shockwaveMaterial);
            shockwave.rotation.x = -Math.PI / 2;
            shockwave.position.y = 0.1;
            explosionGroup.add(shockwave);

            // ç¢ç‰‡
            for (let i = 0; i < 20; i++) {
                const fragmentGeometry = new THREE.BoxGeometry(1, 1, 1);
                const fragmentMaterial = new THREE.MeshStandardMaterial({
                    color: Math.random() > 0.5 ? 0xFF7F00 : 0x4169E1,
                    emissiveIntensity: 0.3
                });
                const fragment = new THREE.Mesh(fragmentGeometry, fragmentMaterial);

                fragment.position.set(
                    position.x + (Math.random() - 0.5) * 5,
                    position.y + Math.random() * 3,
                    position.z + (Math.random() - 0.5) * 5
                );

                fragment.userData = {
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 10,
                        Math.random() * 5 + 2,
                        (Math.random() - 0.5) * 10
                    ),
                    rotationSpeed: new THREE.Vector3(
                        Math.random() * 0.2 - 0.1,
                        Math.random() * 0.2 - 0.1,
                        Math.random() * 0.2 - 0.1
                    ),
                    lifeTime: 2
                };

                explosionGroup.add(fragment);
                gameState.explosionFragments = gameState.explosionFragments || [];
                gameState.explosionFragments.push(fragment);
            }

            explosionGroup.position.set(position.x, position.y, position.z);
            explosionGroup.userData = { lifeTime: 1 };
            gameState.explosions.push(explosionGroup);
            gameState.scene.add(explosionGroup);
        }

        // æ›´æ–°çˆ†ç‚¸ç¢ç‰‡
        function updateExplosionFragments(deltaTime) {
            if (!gameState.explosionFragments) return;

            for (let i = gameState.explosionFragments.length - 1; i >= 0; i--) {
                const fragment = gameState.explosionFragments[i];
                const data = fragment.userData;

                if (!data) continue;

                // æ›´æ–°ä½ç½®
                fragment.position.x += data.velocity.x * deltaTime;
                fragment.position.y += data.velocity.y * deltaTime;
                fragment.position.z += data.velocity.z * deltaTime;

                // åº”ç”¨é‡åŠ›
                data.velocity.y -= 9.8 * deltaTime;

                // æ›´æ–°æ—‹è½¬
                fragment.rotation.x += data.rotationSpeed.x;
                fragment.rotation.y += data.rotationSpeed.y;
                fragment.rotation.z += data.rotationSpeed.z;

                // å‡å°‘ç”Ÿå‘½å‘¨æœŸ
                data.lifeTime -= deltaTime;

                // ç§»é™¤è¿‡æœŸç¢ç‰‡
                if (data.lifeTime <= 0 || fragment.position.y < 0) {
                    if (fragment.parent) {
                        gameState.scene.remove(fragment);
                    }
                    gameState.explosionFragments.splice(i, 1);
                }
            }
        }

        // æ£€æŸ¥å²©æµ†ä¼¤å®³
        function checkLavaDamage(playerKey) {
            const player = gameState[playerKey];

            // æ£€æŸ¥æ˜¯å¦åœ¨ç«å±±å–·å‘çš„å²©æµ†èŒƒå›´å†…
            for (const volcano of gameState.volcanoes) {
                if (volcano.userData.active) {
                    const distance = Math.sqrt(
                        Math.pow(player.position.x - volcano.position.x, 2) +
                        Math.pow(player.position.z - volcano.position.z, 2)
                    );

                    if (distance < 10) {
                        // å²©æµ†ä¼¤å®³
                        const damageApplied = applyDamage(playerKey, 2 * clock.getDelta(), 'lava');
                        if (damageApplied && playerKey === 'player1') {
                            showDamageEffect('player1');
                        } else if (damageApplied && playerKey === 'player2') {
                            showDamageEffect('player2');
                        }
                    }
                }
            }
        }
        function shootBullet(playerKey) {
            const player = gameState[playerKey];

            // æ ¹æ®æ”»å‡»å åŠ å±‚æ•°å¢åŠ å­å¼¹å¤§å°
            const attackStacks = player.attackStacks || 0;
            const sizeMultiplier = 1 + attackStacks * 0.2; // æ¯å±‚å¢åŠ 20%å¤§å°

            // è·å–è›‡çš„å½“å‰å‰è¿›æ–¹å‘
            const direction = player.direction;

            const bullet = createBullet(
                player.position.x,
                player.position.y + 1.5,
                player.position.z,
                direction,
                playerKey === 'player1' ? 0xFF7F00 : 0x4169E1,
                playerKey
            );

            // è°ƒæ•´å­å¼¹å¤§å°
            bullet.scale.set(sizeMultiplier, sizeMultiplier, sizeMultiplier);

            gameState.bullets.push(bullet);
            gameState.scene.add(bullet);
        }
        function createBullet(x, y, z, direction, color, owner) {
            // æ”¹å›åŸæ¥çš„0.4å¤§å°
            const geometry = new THREE.SphereGeometry(0.4, 8, 8);
            const material = new THREE.MeshStandardMaterial({
                color: color,
                emissive: color,
                emissiveIntensity: 0.5
            });
            const bullet = new THREE.Mesh(geometry, material);
            bullet.position.set(x, y, z);
            bullet.userData = {
                type: 'bullet',
                direction: { x: direction.x, y: 0, z: direction.z },
                speed: 180, // æ”¹å›åŸæ¥çš„é€Ÿåº¦
                lifeTime: 5,
                owner: owner,
                damage: 0.5
            };
            return bullet;
        }

        function createBaseBullet(x, y, z, direction, color) {
            const geometry = new THREE.SphereGeometry(0.4, 8, 8);
            const material = new THREE.MeshStandardMaterial({
                color: color,
                emissive: color,
                emissiveIntensity: 0.5
            });
            const bullet = new THREE.Mesh(geometry, material);
            bullet.position.set(x, y, z);
            bullet.userData = {
                type: 'baseBullet',
                direction: direction,
                speed: 15,
                damage: 0.5  // ä¼¤å®³0.5
            };
            return bullet;
        }

        function getPlayerSpeed(playerKey) {
            const player = gameState[playerKey];
            let speed = 15; // åŸºç¡€é€Ÿåº¦

            if (player.type === 'speed') {
                speed *= 1.5;
            } else if (player.type === 'magic') {
                speed *= 1.15;
            }

            speed *= player.speedMultiplier;

            if (player.isDashing) {
                speed *= 3;
            }

            return speed;
        }
        // ä¿®æ”¹shootBaseBulletå‡½æ•°
        // ä¿®æ”¹shootBaseBulletå‡½æ•°ä¸ºæ‰¹é‡å‘å°„
        function shootBaseBullet(baseOwnerKey, targetPlayerKey) {
            const owner = gameState[baseOwnerKey];
            const target = gameState[targetPlayerKey];

            if (target.hp <= 0) return;

            // è®¡ç®—ç›®æ ‡ç›¸å¯¹äºåŸºåœ°çš„æ–¹å‘
            const dx = target.position.x - owner.basePosition.x;
            const dz = target.position.z - owner.basePosition.z;

            // å†³å®šä»å“ªæ¡è¾¹å‘å°„ï¼ˆåŸºåœ°çš„å››ä¸ªè¾¹ï¼‰
            let side = '';
            if (Math.abs(dx) > Math.abs(dz)) {
                // Xæ–¹å‘è·ç¦»æ›´å¤§ï¼Œä»å·¦è¾¹æˆ–å³è¾¹å‘å°„
                side = dx > 0 ? 'right' : 'left';
            } else {
                // Zæ–¹å‘è·ç¦»æ›´å¤§ï¼Œä»ä¸Šè¾¹æˆ–ä¸‹è¾¹å‘å°„
                side = dz > 0 ? 'bottom' : 'top';
            }

            // ä»é€‰å®šçš„è¾¹å‘å°„6é¢—å­å¼¹ï¼Œå¯¹å‡†ç©å®¶
            const bulletCount = 6;
            const baseRadius = 15;

            for (let i = 0; i < bulletCount; i++) {
                let firePosition;
                let direction;

                // æ ¹æ®é€‰å®šçš„è¾¹è®¡ç®—å‘å°„ä½ç½®å’Œæ–¹å‘
                switch (side) {
                    case 'top': // ä¸Šè¾¹
                        firePosition = {
                            x: owner.basePosition.x - baseRadius + (2 * baseRadius / (bulletCount - 1)) * i,
                            y: 3,
                            z: owner.basePosition.z - baseRadius
                        };
                        // ä»åŸºåœ°ä¸Šè¾¹å‘ç©å®¶æ–¹å‘å‘å°„
                        direction = {
                            x: target.position.x - firePosition.x,
                            y: 0,
                            z: target.position.z - firePosition.z
                        };
                        break;

                    case 'bottom': // ä¸‹è¾¹
                        firePosition = {
                            x: owner.basePosition.x - baseRadius + (2 * baseRadius / (bulletCount - 1)) * i,
                            y: 3,
                            z: owner.basePosition.z + baseRadius
                        };
                        // ä»åŸºåœ°ä¸‹è¾¹å‘ç©å®¶æ–¹å‘å‘å°„
                        direction = {
                            x: target.position.x - firePosition.x,
                            y: 0,
                            z: target.position.z - firePosition.z
                        };
                        break;

                    case 'left': // å·¦è¾¹
                        firePosition = {
                            x: owner.basePosition.x - baseRadius,
                            y: 3,
                            z: owner.basePosition.z - baseRadius + (2 * baseRadius / (bulletCount - 1)) * i
                        };
                        // ä»åŸºåœ°å·¦è¾¹å‘ç©å®¶æ–¹å‘å‘å°„
                        direction = {
                            x: target.position.x - firePosition.x,
                            y: 0,
                            z: target.position.z - firePosition.z
                        };
                        break;

                    case 'right': // å³è¾¹
                        firePosition = {
                            x: owner.basePosition.x + baseRadius,
                            y: 3,
                            z: owner.basePosition.z - baseRadius + (2 * baseRadius / (bulletCount - 1)) * i
                        };
                        // ä»åŸºåœ°å³è¾¹å‘ç©å®¶æ–¹å‘å‘å°„
                        direction = {
                            x: target.position.x - firePosition.x,
                            y: 0,
                            z: target.position.z - firePosition.z
                        };
                        break;
                }

                // å½’ä¸€åŒ–æ–¹å‘ï¼ˆä½¿å…¶é•¿åº¦ä¸º1ï¼‰
                const length = Math.sqrt(direction.x * direction.x + direction.z * direction.z);
                if (length === 0) continue;
                direction.x /= length;
                direction.z /= length;

                // åˆ›å»ºå­å¼¹
                const bullet = createBaseBullet(
                    firePosition.x,
                    firePosition.y,
                    firePosition.z,
                    direction,
                    baseOwnerKey === 'player1' ? 0xFF7F00 : 0x4169E1
                );

                bullet.userData.owner = baseOwnerKey;
                bullet.userData.damage = 0.5;

                gameState.bullets.push(bullet);
                gameState.scene.add(bullet);
            }
        }


        // æ›´æ–°å­å¼¹
        // 4. ä¿®æ”¹ updateBullets å‡½æ•°ï¼Œç¡®ä¿ç¢°æ’æ£€æµ‹è¢«è°ƒç”¨
        function updateBullets(deltaTime) {
            for (let i = gameState.bullets.length - 1; i >= 0; i--) {
                const bullet = gameState.bullets[i];
                const data = bullet.userData;

                if (!data) continue;

                // å­å¼¹ç§»åŠ¨
                bullet.position.x += data.direction.x * data.speed * deltaTime;
                bullet.position.z += data.direction.z * data.speed * deltaTime;

                // è¾¹ç•Œæ£€æŸ¥
                const boundary = 120;
                if (Math.abs(bullet.position.x) > boundary ||
                    Math.abs(bullet.position.z) > boundary) {
                    gameState.scene.remove(bullet);
                    gameState.bullets.splice(i, 1);
                    continue;
                }

                // æ£€æŸ¥ä¸å¢™å£çš„ç¢°æ’
                checkBulletWallCollision(bullet, i);

                // å¦‚æœå­å¼¹è¿˜åœ¨ï¼Œæ£€æŸ¥ä¸åŸºåœ°çš„ç¢°æ’
                if (gameState.bullets[i] === bullet) {
                    checkBulletBaseCollision(bullet, i);
                }

                // å¦‚æœå­å¼¹è¿˜åœ¨ï¼Œæ£€æŸ¥ä¸ç©å®¶çš„ç¢°æ’
                if (gameState.bullets[i] === bullet) {
                    checkBulletPlayerCollision(bullet, i);
                }
            }
        }
        function createBullet(x, y, z, direction, color, owner) {
            const geometry = new THREE.SphereGeometry(0.4, 8, 8);
            const material = new THREE.MeshStandardMaterial({
                color: color,
                emissive: color,
                emissiveIntensity: 0.5
            });
            const bullet = new THREE.Mesh(geometry, material);
            bullet.position.set(x, y, z);
            bullet.userData = {
                type: 'bullet',
                direction: { x: direction.x, y: 0, z: direction.z },
                speed: 180,
                owner: owner,
                damage: 0.5
            };
            return bullet;
        }
        function checkBulletWallCollision(bullet, bulletIndex) {
            const data = bullet.userData;
            if (!data) return;

            for (let j = gameState.walls.length - 1; j >= 0; j--) {
                const wall = gameState.walls[j];
                const wallData = wall.userData;

                if (!wallData) continue;

                // è®¡ç®—å­å¼¹åˆ°å¢™çº¿æ®µçš„æœ€è¿‘ç‚¹
                const closestPoint = getClosestPointOnSegment(
                    bullet.position.x, bullet.position.z,
                    wallData.start.x, wallData.start.z,
                    wallData.end.x, wallData.end.z
                );

                const distance = Math.sqrt(
                    Math.pow(bullet.position.x - closestPoint.x, 2) +
                    Math.pow(bullet.position.z - closestPoint.z, 2)
                );

                // å¢™çš„å®½åº¦0.5ï¼Œå­å¼¹åŠå¾„0.4
                if (distance < 0.5 + 0.4) {
                    gameState.scene.remove(bullet);
                    gameState.bullets.splice(bulletIndex, 1);
                    break;
                }
            }
        }
        function checkBulletPlayerCollision(bullet, bulletIndex) {
            const data = bullet.userData;

            if (data.type !== 'bullet' && data.type !== 'baseBullet') return;

            const players = ['player1', 'player2'];

            for (const playerKey of players) {
                const player = gameState[playerKey];

                // è·³è¿‡è‡ªå·±çš„å­å¼¹
                if (data.owner === playerKey) continue;

                // æ£€æŸ¥ä¸è›‡å¤´çš„ç¢°æ’
                const playerRadius = 1.5;
                const bulletRadius = 0.4;

                const headDistance = Math.sqrt(
                    Math.pow(player.position.x - bullet.position.x, 2) +
                    Math.pow(player.position.z - bullet.position.z, 2)
                );

                if (headDistance < playerRadius + bulletRadius) {
                    const damageAmount = data.damage || 0.5;
                    const damageApplied = applyDamage(playerKey, damageAmount, data.type);

                    if (damageApplied) {
                        showDamageEffect(playerKey);
                            if (data.owner && data.owner !== playerKey) {
                            recordDamageDealt(data.owner, damageAmount, playerKey, data.type);
                        }
                    }

                    gameState.scene.remove(bullet);
                    gameState.bullets.splice(bulletIndex, 1);
                    return;
                }

                // æ£€æŸ¥ä¸è›‡èº«çš„ç¢°æ’
                for (let i = 0; i < player.segments.length; i++) {
                    const segment = player.segments[i];
                    if (!segment) continue;

                    const segmentDistance = Math.sqrt(
                        Math.pow(segment.position.x - bullet.position.x, 2) +
                        Math.pow(segment.position.z - bullet.position.z, 2)
                    );

                    if (segmentDistance < 1.5 + bulletRadius) {
                        const damageAmount = data.damage || 0.5;
                        const damageApplied = applyDamage(playerKey, damageAmount, data.type);

                        if (damageApplied) {
                            showDamageEffect(playerKey);
                        }

                        gameState.scene.remove(bullet);
                        gameState.bullets.splice(bulletIndex, 1);
                        return;
                    }
                }
            }
        }
        function checkBulletBaseCollision(bullet, bulletIndex) {
            const data = bullet.userData;
            if (!data) return;

            // æ£€æŸ¥æ‰€æœ‰ç©å®¶çš„åŸºåœ°
            const players = ['player1', 'player2'];

            for (const playerKey of players) {
                const player = gameState[playerKey];

                // è·³è¿‡è‡ªå·±çš„å­å¼¹å¯¹è‡ªå®¶åŸºåœ°çš„ä¼¤å®³
                if (data.owner === playerKey && data.type === 'bullet') continue;

                // å¦‚æœåŸºåœ°å·²è¢«æ‘§æ¯ï¼Œè·³è¿‡
                if (player.baseHp <= 0 || !player.baseObject) continue;

                // è®¡ç®—å­å¼¹åˆ°åŸºåœ°ä¸­å¿ƒçš„è·ç¦»
                const distance = Math.sqrt(
                    Math.pow(bullet.position.x - player.basePosition.x, 2) +
                    Math.pow(bullet.position.z - player.basePosition.z, 2)
                );

                // åŸºåœ°åŠå¾„çº¦15ï¼ˆ30/2ï¼‰ï¼Œå­å¼¹åŠå¾„0.4
                if (distance < 15 + 0.4) {
                    // ä¸åŒå­å¼¹ç±»å‹å¯¹åŸºåœ°ä¼¤å®³ä¸åŒ
                    let damage = 0;
                    if (data.type === 'baseBullet') {
                        damage = 0.5; // åŸºåœ°å­å¼¹å¯¹åŸºåœ°ä¼¤å®³0.5
                    } else {
                        damage = 1; // ç©å®¶å­å¼¹å¯¹åŸºåœ°ä¼¤å®³1
                    }

                    player.baseHp -= damage;
                    if (player.baseHp < 0) player.baseHp = 0;

                    // æ˜¾ç¤ºåŸºåœ°ä¼¤å®³æ•ˆæœ
                    showBaseDamageEffect(player.basePosition);

                    // ç§»é™¤å­å¼¹
                    gameState.scene.remove(bullet);
                    gameState.bullets.splice(bulletIndex, 1);

                    // åŸºåœ°è¢«æ‘§æ¯
                    if (player.baseHp <= 0 && player.baseObject) {
                        destroyBase(playerKey);
                    }

                    return;
                }
            }
        }

        // åŸºåœ°ä¼¤å®³æ•ˆæœ
        function showBaseDamageEffect(position) {
            // åˆ›å»ºä¼¤å®³ç²’å­æ•ˆæœ
            const particleCount = 5;
            for (let i = 0; i < particleCount; i++) {
                const particleGeometry = new THREE.SphereGeometry(0.3, 6, 6);
                const particleMaterial = new THREE.MeshBasicMaterial({
                    color: 0xFF0000,
                    transparent: true,
                    opacity: 0.7
                });
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);

                particle.position.set(
                    position.x + (Math.random() - 0.5) * 10,
                    position.y + Math.random() * 5,
                    position.z + (Math.random() - 0.5) * 10
                );

                gameState.scene.add(particle);

                // 1ç§’åç§»é™¤ç²’å­
                setTimeout(() => {
                    if (particle.parent) {
                        gameState.scene.remove(particle);
                    }
                }, 1000);
            }
        }
        // æ›´æ–°çˆ†ç‚¸æ•ˆæœ
        function updateExplosions(deltaTime) {
            for (let i = gameState.explosions.length - 1; i >= 0; i--) {
                const explosion = gameState.explosions[i];
                explosion.userData.lifeTime -= deltaTime;

                if (explosion.userData.lifeTime <= 0) {
                    gameState.scene.remove(explosion);
                    gameState.explosions.splice(i, 1);
                }
            }
        }

        // æ›´æ–°ç¯å¢ƒæ•ˆæœ
        function updateEnvironment(deltaTime) {
            // æ›´æ–°ç«å±±
            if (gameState.mapType === 'volcano') {
                updateVolcanoes(deltaTime);
            }

            // æ›´æ–°æš´é£é›ª
            if (gameState.mapType === 'snow') {
                updateSnowStorm(deltaTime);
            }
        }

        // æ›´æ–°ç«å±±
        function updateVolcanoes(deltaTime) {
            for (const volcano of gameState.volcanoes) {
                volcano.userData.cooldown -= deltaTime;

                if (volcano.userData.cooldown <= 0) {
                    if (!volcano.userData.warning && !volcano.userData.active) {
                        // å¼€å§‹è­¦å‘Šé˜¶æ®µ
                        volcano.userData.warning = true;
                        volcano.userData.warningTime = 5;

                        // ç«å±±é—ªçƒ
                        const crater = volcano.children[1];
                        if (crater && crater.material) {
                            crater.material.emissiveIntensity = 0.8;
                        }
                    } else if (volcano.userData.warning && volcano.userData.warningTime > 0) {
                        // è­¦å‘Šé˜¶æ®µå€’è®¡æ—¶
                        volcano.userData.warningTime -= deltaTime;

                        // ç«å±±é—ªçƒæ•ˆæœ
                        const crater = volcano.children[1];
                        if (crater && crater.material) {
                            crater.material.emissiveIntensity = 0.3 + 0.5 * Math.sin(gameState.gameTime * 10);
                        }

                        if (volcano.userData.warningTime <= 0) {
                            // å¼€å§‹å–·å‘
                            volcano.userData.warning = false;
                            volcano.userData.active = true;
                            volcano.userData.activeTime = 15;

                            // åˆ›å»ºå²©æµ†åŒºåŸŸ
                            createLavaZone(volcano.position.x, volcano.position.z);
                        }
                    } else if (volcano.userData.active && volcano.userData.activeTime > 0) {
                        // å–·å‘é˜¶æ®µå€’è®¡æ—¶
                        volcano.userData.activeTime -= deltaTime;

                        if (volcano.userData.activeTime <= 0) {
                            // ç»“æŸå–·å‘
                            volcano.userData.active = false;
                            volcano.userData.cooldown = 30;

                            // æ¢å¤ç«å±±å£äº®åº¦
                            const crater = volcano.children[1];
                            if (crater && crater.material) {
                                crater.material.emissiveIntensity = 0.3;
                            }
                        }
                    }
                }
            }
        }

        // åˆ›å»ºå²©æµ†åŒºåŸŸ
        function createLavaZone(x, z) {
            // åˆ›å»º3x3çš„å²©æµ†åŒºåŸŸ
            for (let dx = -1; dx <= 1; dx++) {
                for (let dz = -1; dz <= 1; dz++) {
                    const lava = createLavaPatch(x + dx * 6, z + dz * 6);
                    lava.userData.lifeTime = 15;
                    gameState.scene.add(lava);

                    // 15ç§’åç§»é™¤
                    setTimeout(() => {
                        if (lava.parent) {
                            gameState.scene.remove(lava);
                        }
                    }, 15000);
                }
            }
        }

        // åˆ›å»ºå²©æµ†è´´ç‰‡
        function createLavaPatch(x, z) {
            const geometry = new THREE.PlaneGeometry(5, 5);
            const material = new THREE.MeshStandardMaterial({
                color: 0xFF4500,
                emissive: 0xFF4500,
                emissiveIntensity: 0.5,
                transparent: true,
                opacity: 0.7
            });
            const lava = new THREE.Mesh(geometry, material);
            lava.rotation.x = -Math.PI / 2;
            lava.position.set(x, 0.1, z);
            lava.userData = { type: 'lava' };
            return lava;
        }

        // æ›´æ–°æš´é£é›ª
        function updateSnowStorm(deltaTime) {
            // éšæœºè§¦å‘æš´é£é›ª
            if (!gameState.stormActive && !gameState.stormWarning && Math.random() < 0.001) {
                gameState.stormWarning = true;
                gameState.stormWarningTime = 5;

                // éšæœºé€‰æ‹©ä¸€ä¸ªæ–¹å‘
                const directions = [
                    { x: 0, z: -1 }, // ä¸Š
                    { x: 0, z: 1 },  // ä¸‹
                    { x: -1, z: 0 }, // å·¦
                    { x: 1, z: 0 }   // å³
                ];
                gameState.stormDirection = directions[Math.floor(Math.random() * directions.length)];
            }

            if (gameState.stormWarning && gameState.stormWarningTime > 0) {
                gameState.stormWarningTime -= deltaTime;
                if (gameState.stormWarningTime <= 0) {
                    gameState.stormWarning = false;
                    gameState.stormActive = true;
                    gameState.stormActiveTime = 10;
                }
            }

            if (gameState.stormActive && gameState.stormActiveTime > 0) {
                gameState.stormActiveTime -= deltaTime;
                if (gameState.stormActiveTime <= 0) {
                    gameState.stormActive = false;
                }
            }
            // åœ¨updateSnowStormå‡½æ•°ä¸­æ·»åŠ 
            if (gameState.stormActive) {
                // å¯¹ä¸¤ä¸ªç©å®¶é€ æˆä¼¤å®³
                ['player1', 'player2'].forEach(playerKey => {
                    const player = gameState[playerKey];
                    // æ¯2ç§’é€ æˆ1ç‚¹ä¼¤å®³
                    if (performance.now() - (player.lastStormDamage || 0) > 2000) {
                        const damageApplied = applyDamage(playerKey, 1, 'storm');
                        if (damageApplied) {
                            showDamageEffect(playerKey);
                        }
                        player.lastStormDamage = performance.now();
                    }
                });
            }
        }

        // æ·»åŠ è›‡æ®µ
        function addSnakeSegment(playerKey) {
            const player = gameState[playerKey];

            if (player.segments.length === 0) {
                // åˆ›å»ºç¬¬ä¸€ä¸ªæ®µ
                const segment = createSnakeSegment(
                    player.position.x,
                    player.position.y - 0.25,
                    player.position.z,
                    playerKey === 'player1' ? 0xFFA500 : 0x87CEEB
                );
                gameState.scene.add(segment);
                player.segments.push(segment);
                return;
            }

            // è·å–æœ€åä¸€ä¸ªè›‡æ®µçš„ä½ç½®
            const lastSegment = player.segments[player.segments.length - 1];

            // æ·»åŠ 3ä¸ªæ–°æ®µ
            for (let i = 0; i < 3; i++) {
                const newSegment = createSnakeSegment(
                    lastSegment.position.x,
                    lastSegment.position.y,
                    lastSegment.position.z,
                    playerKey === 'player1' ? 0xFFA500 : 0x87CEEB
                );
                gameState.scene.add(newSegment);
                player.segments.push(newSegment);
            }
        }
        function showSnakeCutEffect(position, playerKey) {
            // åˆ›å»ºç²’å­æ•ˆæœ
            const particleCount = 5;
            const color = playerKey === 'player1' ? 0xFFA500 : 0x87CEEB;

            for (let i = 0; i < particleCount; i++) {
                const particleGeometry = new THREE.SphereGeometry(0.3, 6, 6);
                const particleMaterial = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.7
                });
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);

                particle.position.set(
                    position.x + (Math.random() - 0.5) * 2,
                    position.y + Math.random() * 1,
                    position.z + (Math.random() - 0.5) * 2
                );

                gameState.scene.add(particle);

                // åŠ¨ç”»æ•ˆæœ
                const velocity = {
                    x: (Math.random() - 0.5) * 3,
                    y: Math.random() * 2,
                    z: (Math.random() - 0.5) * 3
                };

                const startTime = performance.now();
                function animateParticle() {
                    const elapsed = performance.now() - startTime;
                    if (elapsed > 1000) {
                        if (particle.parent) gameState.scene.remove(particle);
                        return;
                    }

                    particle.position.x += velocity.x * 0.016;
                    particle.position.y += velocity.y * 0.016;
                    particle.position.z += velocity.z * 0.016;

                    particle.material.opacity = 0.7 * (1 - elapsed / 1000);

                    requestAnimationFrame(animateParticle);
                }
                animateParticle();
            }
        }
        // ä½¿ç”¨é­”æ³•çƒ
        function useMagicBall(playerKey, ballIndex) {
            const player = gameState[playerKey];
            if (ballIndex < 0 || ballIndex >= player.magicBalls.length) return;

            const ballType = player.magicBalls[ballIndex];

            // ç§»é™¤é­”æ³•çƒ
            player.magicBalls.splice(ballIndex, 1);
            updateMagicBallsDisplay(playerKey);

            // åº”ç”¨æ•ˆæœ
            switch (ballType) {
                case 'invincible':
                    player.isInvincible = true;
                    player.invincibleTime = player.type === 'magic' ? 15 : 10;
                    break;

                case 'health':
                    player.hp += 5;
                    if (player.hp > player.maxHp) player.hp = player.maxHp;
                    break;

                case 'reverse':
                    const otherPlayerKey = playerKey === 'player1' ? 'player2' : 'player1';
                    const otherPlayer = gameState[otherPlayerKey];
                    otherPlayer.isReversed = true;
                    otherPlayer.reversedTime = otherPlayer.type === 'magic' ? 12 : 8;
                    break;

                case 'attack':
                    player.isAttacking = true;
                    player.attackTime = player.type === 'magic' ? 30 : 20;
                    break;

                case 'bomb':
                    // åˆ›å»ºçˆ†ç‚¸æ•ˆæœ
                    createExplosion(player.position.x, player.position.y, player.position.z);

                    // çˆ†ç‚¸åŠå¾„
                    const explosionRadius = 10;

                    // å¯¹æ‰€æœ‰ç©å®¶å’ŒåŸºåœ°é€ æˆä¼¤å®³
                    const allTargets = ['player1', 'player2'];

                    allTargets.forEach(targetKey => {
                        const target = gameState[targetKey];

                        // è·³è¿‡è‡ªå·±ï¼ˆå¦‚æœç‚¸å¼¹ä¸ä¼¤å®³è‡ªå·±ï¼‰
                        if (targetKey === playerKey) return;

                        // è®¡ç®—åˆ°çˆ†ç‚¸ä¸­å¿ƒçš„è·ç¦»
                        const distance = Math.sqrt(
                            Math.pow(target.position.x - player.position.x, 2) +
                            Math.pow(target.position.z - player.position.z, 2)
                        );

                        // å¯¹ç©å®¶é€ æˆä¼¤å®³
                        if (distance < explosionRadius) {
                            let damage = 0;
                            if (distance < 3) damage = 5;
                            else if (distance < 6) damage = 2;
                            else if (distance < 10) damage = 1;

                            if (damage > 0) {
                                // è®°å½•ç›®æ ‡æ‰¿å—ä¼¤å®³
                                const damageApplied = applyDamage(targetKey, damage, 'bomb');

                                // è®°å½•æ–½æ³•è€…è¾“å‡ºä¼¤å®³
                                if (damageApplied) {
                                    showDamageEffect(targetKey);
                                    recordDamageDealt(playerKey, damage, targetKey, 'bomb');
                                }
                                                    // è®¾ç½®æ­»äº¡åŸå› 
                                if (gameState[targetKey].hp <= 0) {
                                    gameState[targetKey].deathReason = `è¢«${playerKey === 'player1' ?
                                        localStorage.getItem('username') || 'ç©å®¶1' :
                                        localStorage.getItem('player2_username') || 'ç©å®¶2'}çš„ç‚¸å¼¹ç‚¸æ­»`;
                                }
                            }
                        }

                        // å¯¹åŸºåœ°é€ æˆä¼¤å®³
                        const distanceToBase = Math.sqrt(
                            Math.pow(target.basePosition.x - player.position.x, 2) +
                            Math.pow(target.basePosition.z - player.position.z, 2)
                        );

                        // å¦‚æœçˆ†ç‚¸åœ¨åŸºåœ°30æ ¼èŒƒå›´å†…
                        if (distanceToBase < 30) {
                            let baseDamage = 0;
                            if (distanceToBase < 10) baseDamage = 10;
                            else if (distanceToBase < 20) baseDamage = 5;
                            else if (distanceToBase < 30) baseDamage = 2;

                            if (baseDamage > 0) {
                                target.baseHp -= baseDamage;

                                // è®°å½•å¯¹åŸºåœ°çš„ä¼¤å®³
                                player.stats.damageDealt.baseDamage += baseDamage;

                                if (target.baseHp < 0) target.baseHp = 0;

                                // æ˜¾ç¤ºåŸºåœ°è¢«æ”»å‡»æ•ˆæœ
                                showBaseDamageEffect(target.basePosition);

                                // æ£€æŸ¥åŸºåœ°æ˜¯å¦è¢«æ‘§æ¯
                                if (target.baseHp <= 0 && target.baseObject) {
                                    destroyBase(targetKey);
                                }
                            }
                        }
                    });

                    // å¯¹è‡ªå·±æ·»åŠ è½»å¾®åå†²æ•ˆæœ
                    const pushBack = 2;
                    player.position.x += player.direction.x * -pushBack;
                    player.position.z += player.direction.z * -pushBack;
                    break;
            }

            // æ›´æ–°çŠ¶æ€æ˜¾ç¤º
            updatePlayerStatusDisplay(playerKey);
        }

        function updatePlayerStatus(playerKey, deltaTime) {
            const player = gameState[playerKey];

            // æ›´æ–°æ— æ•ŒçŠ¶æ€æ—¶é—´
            if (player.isInvincible && player.invincibleTime > 0) {
                player.invincibleTime -= deltaTime;
                if (player.invincibleTime <= 0) {
                    player.isInvincible = false;
                    player.invincibleTime = 0;
                }
            }

            // æ›´æ–°åå‘çŠ¶æ€æ—¶é—´
            if (player.isReversed && player.reversedTime > 0) {
                player.reversedTime -= deltaTime;
                if (player.reversedTime <= 0) {
                    player.isReversed = false;
                    player.reversedTime = 0;
                }
            }

            // æ›´æ–°æ”»å‡»çŠ¶æ€æ—¶é—´
            if (player.isAttacking && player.attackTime > 0) {
                player.attackTime -= deltaTime;
                // æ”»å‡»çŠ¶æ€ä¸‹çš„è‡ªåŠ¨å°„å‡»
                player.lastAttackTime = (player.lastAttackTime || 0) + deltaTime;
                if (player.lastAttackTime >= 0.4) { // æ¯0.4ç§’å°„å‡»ä¸€æ¬¡
                    player.lastAttackTime = 0;
                    shootBullet(playerKey);
                }
                if (player.attackTime <= 0) {
                    player.isAttacking = false;
                    player.attackTime = 0;
                }
            }

            // é­”æ³•è›‡è‡ªåŠ¨ç”Ÿæˆé­”æ³•çƒ
            if (player.type === 'magic') {
                player.lastMagicGenerateTime = (player.lastMagicGenerateTime || 0) + deltaTime;
                if (player.lastMagicGenerateTime >= 20) {
                    player.lastMagicGenerateTime = 0;
                    generateRandomMagicBall(playerKey);
                }
            }

            // æ›´æ–°ä¿¯å†²çŠ¶æ€
            if (player.isDashing && player.dashDuration > 0) {
                player.dashDuration -= deltaTime;
                if (player.dashDuration <= 0) {
                    player.isDashing = false;
                    player.dashDuration = 0;
                }
            }

            // æ›´æ–°çŠ¶æ€æ˜¾ç¤º
            updatePlayerStatusDisplay(playerKey);
        }
        // åˆ›å»ºçˆ†ç‚¸æ•ˆæœ
        function createExplosion(x, y, z) {
            const explosionGroup = new THREE.Group();

            // çˆ†ç‚¸çƒä½“
            const explosionGeometry = new THREE.SphereGeometry(3, 16, 16);
            const explosionMaterial = new THREE.MeshStandardMaterial({
                color: 0xFF8C00,
                emissive: 0xFF8C00,
                emissiveIntensity: 0.8,
                transparent: true,
                opacity: 0.7
            });
            const explosion = new THREE.Mesh(explosionGeometry, explosionMaterial);
            explosionGroup.add(explosion);

            explosionGroup.position.set(x, y, z);
            explosionGroup.userData = { lifeTime: 1 };
            gameState.explosions.push(explosionGroup);
            gameState.scene.add(explosionGroup);
            
        }

        // æ£€æŸ¥æ¸¸æˆç»“æŸ
    function checkGameEnd() {
        if (gameState.player1.hp <= 0 || gameState.player2.hp <= 0) {
            // è®¾ç½®å…·ä½“çš„æ­»äº¡åŸå› 
            if (gameState.player1.hp <= 0 && !gameState.player1.deathReason) {
                gameState.player1.deathReason = getDeathReason(
                    gameState.player1.lastDamageSource || 'unknown',
                    gameState.player1.lastDamageAmount || 0,
                    gameState.player1
                );
            }

            if (gameState.player2.hp <= 0 && !gameState.player2.deathReason) {
                gameState.player2.deathReason = getDeathReason(
                    gameState.player2.lastDamageSource || 'unknown',
                    gameState.player2.lastDamageAmount || 0,
                    gameState.player2
                );
            }

            endGame();
        }
    }
            async function endGame() {
                if (!gameState.running) return;

                gameState.running = false;
                startButton.textContent = 'å¼€å§‹æ¸¸æˆ';
                startButton.disabled = false;
                document.getElementById('view-records').style.display = 'block';
                // è®°å½•æ­»äº¡åŸå› 
                recordDeathCauses();

                // è®¡ç®—èƒœè€…
                let winner;
                let loser;
                let currentWin1 = 0;
                let currentWin2 = 0;

                if (gameState.player1.hp > 0 && gameState.player2.hp <= 0) {
                    winner = 'player1';
                    loser = 'player2';
                    currentWin1 = 1;
                    currentWin2 = 0;
                } else if (gameState.player2.hp > 0 && gameState.player1.hp <= 0) {
                    winner = 'player2';
                    loser = 'player1';
                    currentWin1 = 0;
                    currentWin2 = 1;
                } else {
                    winner = 'draw';
                    currentWin1 = 0;
                    currentWin2 = 0;
                }

                // è·å–æœåŠ¡å™¨æ•°æ®å¹¶æ˜¾ç¤º
                getServerRecords().then(serverData => {
                    let player1Wins = serverData?.player1Wins || 0;
                    let player2Wins = serverData?.player2Wins || 0;

                    const deathAnalysis = generateDeathAnalysis();
                    const loserName = loser === 'player1' ?
                        localStorage.getItem('username') || 'ç©å®¶1' :
                        localStorage.getItem('player2_username') || 'ç©å®¶2';
                    const loserCause = gameStats.deathCauses[loser] || 'æœªçŸ¥åŸå› ';

                    const currentTime = performance.now();
                    const totalTime = Math.floor((currentTime - gameStats.startTime) / 1000);
                    gameStats.endTime = performance.now();
                    const minutes = Math.floor(totalTime / 60);
                    const seconds = totalTime % 60;
                    const timeString = `${minutes}åˆ†${seconds}ç§’`;

                    // åˆ›å»ºæ¸¸æˆç»“æŸç•Œé¢
                    gameOverScreen.innerHTML = `
<div class="game-over-content">
    <div class="winner-container">
        ${winner === 'draw' ? `
            <div class="trophy-icon">
                <i class="fas fa-trophy" style="color: #FFD700;"></i>
                <i class="fas fa-trophy" style="color: #C0C0C0;"></i>
            </div>
            <h2 class="winner-banner">å¹³å±€!</h2>
        ` : `
            <div class="trophy-icon">
                <i class="fas fa-trophy" style="color: ${winner === 'player1' ? '#FFD700' : '#C0C0C0'};"></i>
            </div>
            <h2 class="winner-banner ${winner === 'player1' ? 'player-1-win' : 'player-2-win'}">
                ${winner === 'player1' ? localStorage.getItem("username") : localStorage.getItem("player2_username")}è·èƒœ!
            </h2>
        `}
    </div>
    
    <!-- å¤±è´¥è€…æ­»äº¡åŸå›  -->
<!-- å¤±è´¥è€…æ­»äº¡åŸå›  -->
${loser ? `
    <div class="death-cause" id="death-cause" style="
        margin: 15px auto;
        padding: 10px;
        background: ${loser === 'player1' ? 'rgba(255, 87, 34, 0.2)' : 'rgba(33, 150, 243, 0.2)'};
        border-radius: 10px;
        max-width: 400px;
        text-align: center;
        border: 1px solid ${loser === 'player1' ? '#FF5722' : '#2196F3'};
    ">
        <div style="font-size: 14px; color: #ccc; margin-bottom: 5px;">
            <i class="fas fa-skull-crossbones"></i> åŸå› 
        </div>
        <div style="font-size: 18px; font-weight: bold; color: white;">
            ${gameState[loser].deathReason || 'è¢«å‡»è´¥'}
        </div>
        <div style="font-size: 12px; color: #aaa; margin-top: 5px;">
            æœ€åè¡€é‡: ${Math.max(0, gameState[loser].hp.toFixed(1))} | æœ€ç»ˆåˆ†æ•°: ${gameState[loser].score}
        </div>
    </div>
` : ''}
    
    <!-- è¯¦ç»†ç»Ÿè®¡ -->
    <div class="stats-container" id="stats-container">
        <div class="player-stats player-1-stats">
            <div class="player-avatar">
                <i class="fas fa-user" style="color: #FF5722;"></i>
            </div>
            <div class="player-name">${localStorage.getItem("username") || "ç©å®¶1"}</div>
            <div class="player-type" style="font-size: 12px; color: #FFA500; margin: 5px 0;">
                ${gameState.player1.type === 'speed' ? 'âš¡ é€Ÿåº¦è›‡' :
                            gameState.player1.type === 'hard' ? 'ğŸ›¡ï¸ åšç¡¬è›‡' :
                                gameState.player1.type === 'magic' ? 'âœ¨ é­”æ³•è›‡' : 'æœªé€‰æ‹©'}
            </div>
            <div class="win-count">
                <span class="history-wins">${player1Wins}</span>
                ${currentWin1 > 0 ? `<span class="current-win">+${currentWin1}</span>` : ''}
            </div>
            <div class="progress-bar">
                <div class="progress-fill" style="width: ${calculateWinPercentage(player1Wins, player2Wins)}%; background: linear-gradient(to right, #FF5722, #FF9800);"></div>
            </div>
            <div class="death-info" style="font-size: 12px; color: #ff6b6b; margin-top: 5px;">
                ${gameStats.deathCauses.player1 ? `ğŸ’€ ${gameStats.deathCauses.player1}` : gameState.player1.hp > 0 ? 'ğŸ‘ å­˜æ´»' : ''}
            </div>
        </div>
        
        <div class="vs-text">VS</div>
        
        <div class="player-stats player-2-stats">
            <div class="player-avatar">
                <i class="fas fa-user" style="color: #2196F3;"></i>
            </div>
            <div class="player-name">${localStorage.getItem("player2_username") || "ç©å®¶2"}</div>
            <div class="player-type" style="font-size: 12px; color: #00BCD4; margin: 5px 0;">
                ${gameState.player2.type === 'speed' ? 'âš¡ é€Ÿåº¦è›‡' :
                            gameState.player2.type === 'hard' ? 'ğŸ›¡ï¸ åšç¡¬è›‡' :
                                gameState.player2.type === 'magic' ? 'âœ¨ é­”æ³•è›‡' : 'æœªé€‰æ‹©'}
            </div>
            <div class="win-count">
                <span class="history-wins">${player2Wins}</span>
                ${currentWin2 > 0 ? `<span class="current-win">+${currentWin2}</span>` : ''}
            </div>
            <div class="progress-bar">
                <div class="progress-fill" style="width: ${calculateWinPercentage(player2Wins, player1Wins)}%; background: linear-gradient(to right, #2196F3, #00BCD4);"></div>
            </div>
            <div class="death-info" style="font-size: 12px; color: #ff6b6b; margin-top: 5px;">
                ${gameStats.deathCauses.player2 ? `ğŸ’€ ${gameStats.deathCauses.player2}` : gameState.player2.hp > 0 ? 'ğŸ‘ å­˜æ´»' : ''}
            </div>
        </div>
    </div>
    
<div class="detailed-stats-container" id="detailed-stats-container" style="display: none;">
    <div class="detailed-stats" style="
        background: rgba(0, 0, 0, 0.3);
        border-radius: 15px;
        padding: 20px;
        margin: 20px 0;
        border: 1px solid rgba(255, 215, 0, 0.3);
    ">
        <h3 style="color: #FFD700; text-align: center; margin-bottom: 20px;">
            <i class="fas fa-chart-bar"></i> æœ¬å±€è¯¦ç»†æ•°æ®ç»Ÿè®¡
        </h3>

        <div style="display: flex; justify-content: space-between; gap: 20px;">
            <!-- ç©å®¶1ç»Ÿè®¡ -->
            <div style="flex: 1;">
                <h4 style="color: #FF7F00; text-align: center;">${localStorage.getItem("username") || "ç©å®¶1"}</h4>
                <div style="font-size: 12px; color: #ccc; margin: 5px 0;">
                    <i class="fas fa-road"></i> æ€»è·¯ç¨‹: ${Math.round(gameState.player1.stats.totalDistance)} ç±³
                </div>
                
                <div style="background: rgba(255, 127, 0, 0.1); padding: 10px; border-radius: 8px; margin: 10px 0;">
                    <div style="color: #FFA500; font-weight: bold; margin-bottom: 8px;">æ‰¿å—ä¼¤å®³ç»Ÿè®¡:</div>
                    <div style="font-size: 12px; color: #ccc;">
                        <div>æ’å¢™ä¼¤å®³: ${Math.round(gameState.player1.stats.damageTaken.wall)}</div>
                        <div>è›‡ç¢°æ’ä¼¤å®³: ${Math.round(gameState.player1.stats.damageTaken.snakeCollision)}</div>
                        <div>å­å¼¹ä¼¤å®³: ${Math.round(gameState.player1.stats.damageTaken.bullet)}</div>
                        <div>åŸºåœ°ä¼¤å®³: ${Math.round(gameState.player1.stats.damageTaken.base)}</div>
                        ${gameState.mapType === 'volcano' ? `<div>å²©æµ†ä¼¤å®³: ${Math.round(gameState.player1.stats.damageTaken.lava)}</div>` : ''}
                        <div>ç‚¸å¼¹ä¼¤å®³: ${Math.round(gameState.player1.stats.damageTaken.bomb)}</div>
                        <div style="color: #FF6B6B; font-weight: bold; margin-top: 5px;">
                            æ€»è®¡: ${Math.round(gameState.player1.stats.damageTaken.total)}
                        </div>
                    </div>
                </div>
                
                <div style="background: rgba(255, 215, 0, 0.1); padding: 10px; border-radius: 8px; margin: 10px 0;">
                    <div style="color: #FFD700; font-weight: bold; margin-bottom: 8px;">è¾“å‡ºä¼¤å®³ç»Ÿè®¡:</div>
                    <div style="font-size: 12px; color: #ccc;">
                        <div>è›‡ç¢°æ’ä¼¤å®³: ${Math.round(gameState.player1.stats.damageDealt.snakeCollision)}</div>
                        <div>å­å¼¹ä¼¤å®³: ${Math.round(gameState.player1.stats.damageDealt.bullet)}</div>
                        <div>ç‚¸å¼¹ä¼¤å®³: ${Math.round(gameState.player1.stats.damageDealt.bomb)}</div>
                        <div>å¯¹åŸºåœ°ä¼¤å®³: ${Math.round(gameState.player1.stats.damageDealt.baseDamage)}</div>
                        <div style="color: #00FF00; font-weight: bold; margin-top: 5px;">
                            æ€»è¾“å‡ºä¼¤å®³: ${Math.round(gameState.player1.stats.damageDealt.total)}
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- æ¸¸æˆæ€»æ—¶é—´ -->
            <div style="flex: 0.5; display: flex; flex-direction: column; justify-content: center; align-items: center;">
                <div style="color: #FFD700; font-size: 1.2rem; font-weight: bold; margin-bottom: 10px;">
                    <i class="fas fa-clock"></i>
                </div>
                <div style="color: white; font-size: 1.8rem; font-weight: bold;">
                    ${Math.floor(gameState.gameTime / 60)}:${Math.floor(gameState.gameTime % 60).toString().padStart(2, '0')}
                </div>
                <div style="color: #aaa; font-size: 12px; margin-top: 5px;">æ€»æ¸¸æˆæ—¶é—´</div>
            </div>
            
            <!-- ç©å®¶2ç»Ÿè®¡ -->
            <div style="flex: 1;">
                <h4 style="color: #4169E1; text-align: center;">${localStorage.getItem("player2_username") || "ç©å®¶2"}</h4>
                <div style="font-size: 12px; color: #ccc; margin: 5px 0;">
                    <i class="fas fa-road"></i> æ€»è·¯ç¨‹: ${Math.round(gameState.player2.stats.totalDistance)} ç±³
                </div>
                
                <div style="background: rgba(65, 105, 225, 0.1); padding: 10px; border-radius: 8px; margin: 10px 0;">
                    <div style="color: #87CEEB; font-weight: bold; margin-bottom: 8px;">æ‰¿å—ä¼¤å®³ç»Ÿè®¡:</div>
                    <div style="font-size: 12px; color: #ccc;">
                        <div>æ’å¢™ä¼¤å®³: ${Math.round(gameState.player2.stats.damageTaken.wall)}</div>
                        <div>è›‡ç¢°æ’ä¼¤å®³: ${Math.round(gameState.player2.stats.damageTaken.snakeCollision)}</div>
                        <div>å­å¼¹ä¼¤å®³: ${Math.round(gameState.player2.stats.damageTaken.bullet)}</div>
                        <div>åŸºåœ°ä¼¤å®³: ${Math.round(gameState.player2.stats.damageTaken.base)}</div>
                        ${gameState.mapType === 'volcano' ? `<div>å²©æµ†ä¼¤å®³: ${Math.round(gameState.player2.stats.damageTaken.lava)}</div>` : ''}
                        <div>ç‚¸å¼¹ä¼¤å®³: ${Math.round(gameState.player2.stats.damageTaken.bomb)}</div>
                        <div style="color: #FF6B6B; font-weight: bold; margin-top: 5px;">
                            æ€»è®¡: ${Math.round(gameState.player2.stats.damageTaken.total)}
                        </div>
                    </div>
                </div>
                
                <div style="background: rgba(135, 206, 235, 0.1); padding: 10px; border-radius: 8px; margin: 10px 0;">
                    <div style="color: #87CEEB; font-weight: bold; margin-bottom: 8px;">è¾“å‡ºä¼¤å®³ç»Ÿè®¡:</div>
                    <div style="font-size: 12px; color: #ccc;">
                        <div>è›‡ç¢°æ’ä¼¤å®³: ${Math.round(gameState.player2.stats.damageDealt.snakeCollision)}</div>
                        <div>å­å¼¹ä¼¤å®³: ${Math.round(gameState.player2.stats.damageDealt.bullet)}</div>
                        <div>ç‚¸å¼¹ä¼¤å®³: ${Math.round(gameState.player2.stats.damageDealt.bomb)}</div>
                        <div>å¯¹åŸºåœ°ä¼¤å®³: ${Math.round(gameState.player2.stats.damageDealt.baseDamage)}</div>
                        <div style="color: #00FF00; font-weight: bold; margin-top: 5px;">
                            æ€»è¾“å‡ºä¼¤å®³: ${Math.round(gameState.player2.stats.damageDealt.total)}
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
    
    <div class="buttons-container">
    <button class="restart-btn" id="show-game-stats" onclick="toggleGameStats()">
        <i class="fas fa-chart-bar"></i> æ˜¾ç¤ºæœ¬å±€æ•°æ®
    </button>
        <button class="restart-btn" id="play-again">
            <i class="fas fa-redo"></i> å†æ¥ä¸€å±€
        </button>
        <button class="restart-btn upload-btn" id="save-record">
            <i class="fas fa-save"></i> ä¿å­˜æˆ˜ç»©
        </button>
    </div>
</div>
                `;

                    // å†æ¥ä¸€å±€æŒ‰é’®äº‹ä»¶
                    document.getElementById('play-again').addEventListener('click', () => {
                        gameOverScreen.style.display = 'none';
                        setTimeout(() => {
                            resetToSelection();
                        }, 300);
                    });

                    // ä¿å­˜æˆ˜ç»©æŒ‰é’®äº‹ä»¶
                    document.getElementById('save-record').addEventListener('click', () => {
                        // ç¦ç”¨æŒ‰é’®é˜²æ­¢é‡å¤ç‚¹å‡»
                        const saveBtn = document.getElementById('save-record');
                        saveBtn.disabled = true;
                        saveBtn.innerHTML = `<i class="fas fa-spinner fa-spin"></i> ä¿å­˜ä¸­...`;

                        // ä¸Šä¼ æœ¬æ¬¡æ¯”èµ›ç»“æœ
                        uploadGameRecord(currentWin1, currentWin2).then(() => {
                            // ä¸Šä¼ æˆåŠŸåæ›´æ–°æ˜¾ç¤º
                            const historyWins1 = document.querySelector('.player-1-stats .history-wins');
                            const historyWins2 = document.querySelector('.player-2-stats .history-wins');

                            if (historyWins1 && historyWins2) {
                                // æ›´æ–°æ˜¾ç¤ºä¸ºå†å²æˆ˜ç»©+æœ¬æ¬¡ç»“æœ
                                historyWins1.textContent = player1Wins + currentWin1;
                                historyWins2.textContent = player2Wins + currentWin2;

                                // éšè—+1æç¤º
                                const currentWinElements = document.querySelectorAll('.current-win');
                                currentWinElements.forEach(el => el.remove());

                                // æ›´æ–°è¿›åº¦æ¡
                                const progress1 = document.querySelector('.player-1-stats .progress-fill');
                                const progress2 = document.querySelector('.player-2-stats .progress-fill');
                                if (progress1 && progress2) {
                                    progress1.style.width = `${calculateWinPercentage(player1Wins + currentWin1, player2Wins + currentWin2)}%`;
                                    progress2.style.width = `${calculateWinPercentage(player2Wins + currentWin2, player1Wins + currentWin1)}%`;
                                }

                                // æ˜¾ç¤ºä¿å­˜æˆåŠŸæç¤º
                                showGameOverMessage('æˆ˜ç»©ä¿å­˜æˆåŠŸ!', '#4CAF50');

                                // æ›´æ–°æŒ‰é’®çŠ¶æ€
                                saveBtn.innerHTML = `<i class="fas fa-check"></i> å·²ä¿å­˜`;
                            }
                        }).catch(error => {
                            console.error('ä¿å­˜æˆ˜ç»©å¤±è´¥:', error);
                            showGameOverMessage('ä¿å­˜å¤±è´¥: ' + error.message, '#FF5722');

                            // æ¢å¤æŒ‰é’®çŠ¶æ€
                            saveBtn.disabled = false;
                            saveBtn.innerHTML = `<i class="fas fa-save"></i> ä¿å­˜æˆ˜ç»©`;
                        });
                    });

                    // æ˜¾ç¤ºæ¸¸æˆç»“æŸç•Œé¢
                    gameOverScreen.style.display = 'flex';
                    gameOverScreen.classList.add('show');
                    // æ·»åŠ åº†ç¥æ•ˆæœ
                    if (winner !== 'draw') {
                        createCelebrationEffect(winner === 'player1' ? '#FF5722' : '#2196F3');
                    }
                });
            }
            function toggleGameStats() {
                    const statsContainer = document.getElementById('detailed-stats-container');
                    const button = document.getElementById('show-game-stats');

                    if (statsContainer.style.display === 'none') {
                        // æ˜¾ç¤ºæ•°æ®ç»Ÿè®¡
                        statsContainer.style.display = 'block';
                        button.innerHTML = '<i class="fas fa-chart-bar"></i> éšè—æœ¬å±€æ•°æ®';
                        document.getElementById('death-cause').style.display = 'none';
                        document.getElementById('stats-container').style.display = 'none';
                        // æ·»åŠ åŠ¨ç”»æ•ˆæœ
                        statsContainer.style.opacity = '0';
                        statsContainer.style.transform = 'translateY(-20px)';
                        statsContainer.style.transition = 'all 0.3s ease-out';

                        setTimeout(() => {
                            statsContainer.style.opacity = '1';
                            statsContainer.style.transform = 'translateY(0)';
                        }, 10);
                    } else {
                        // éšè—æ•°æ®ç»Ÿè®¡
                        statsContainer.style.opacity = '0';
                        statsContainer.style.transform = 'translateY(-20px)';
                        document.getElementById('death-cause').style.display = 'block';
                        document.getElementById('stats-container').style.display = 'flex';
                        setTimeout(() => {
                            statsContainer.style.display = 'none';
                            button.innerHTML = '<i class="fas fa-chart-bar"></i> æ˜¾ç¤ºæœ¬å±€æ•°æ®';
                        }, 300);
                    }
                }

            function recordDeathCauses() {
                if (gameState.player1.hp <= 0) {
                    if (gameState.player1.shield <= 0) {
                        gameStats.deathCauses.player1 = 'è¢«å‡»è´¥';
                    } else {
                        gameStats.deathCauses.player1 = 'æŠ¤ç›¾è€—å°½';
                    }
                }

                if (gameState.player2.hp <= 0) {
                    if (gameState.player2.shield <= 0) {
                        gameStats.deathCauses.player2 = 'è¢«å‡»è´¥';
                    } else {
                        gameStats.deathCauses.player2 = 'æŠ¤ç›¾è€—å°½';
                    }
                }
            }

            // ç”Ÿæˆæ­»äº¡åˆ†æ
            function generateDeathAnalysis() {
                return {
                    player1: {
                        health: gameState.player1.hp,
                        score: gameState.player1.score,
                        cause: gameStats.deathCauses.player1
                    },
                    player2: {
                        health: gameState.player2.hp,
                        score: gameState.player2.score,
                        cause: gameStats.deathCauses.player2
                    }
                };
            }

            // æ˜¾ç¤ºæ¸¸æˆç»“æŸæ¶ˆæ¯
            function showGameOverMessage(message, color) {
                const messageEl = document.createElement('div');
                messageEl.className = 'game-over-message';
                messageEl.textContent = message;
                messageEl.style.color = color;

                const buttonsContainer = document.querySelector('.buttons-container');
                if (buttonsContainer) {
                    buttonsContainer.insertAdjacentElement('beforebegin', messageEl);

                    // 3ç§’åæ·¡å‡º
                    setTimeout(() => {
                        messageEl.style.opacity = '0';
                        setTimeout(() => {
                            messageEl.remove();
                        }, 500);
                    }, 3000);
                }
            }

            // è®¡ç®—èƒœç‡ç™¾åˆ†æ¯”
            function calculateWinPercentage(wins, opponentWins) {
                const total = wins + opponentWins;
                return total > 0 ? Math.round((wins / total) * 100) : 50;
            }

            // åˆ›å»ºåº†ç¥æ•ˆæœ
            function createCelebrationEffect(color) {
                const colors = [color, '#FFFFFF', '#FFD700'];

                for (let i = 0; i < 50; i++) {
                    const particle = document.createElement('div');
                    particle.className = 'celebration-particle';

                    // éšæœºå±æ€§
                    const size = 5 + Math.random() * 10;
                    const duration = 1 + Math.random() * 2;
                    const delay = Math.random() * 0.5;
                    const distance = 50 + Math.random() * 100;
                    const angle = Math.random() * Math.PI * 2;

                    // è®¾ç½®æ ·å¼
                    particle.style.width = `${size}px`;
                    particle.style.height = `${size}px`;
                    particle.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                    particle.style.animationDuration = `${duration}s`;
                    particle.style.animationDelay = `${delay}s`;

                    // è®¾ç½®åˆå§‹ä½ç½®
                    particle.style.left = '50%';
                    particle.style.top = '30%';

                    // è®¾ç½®åŠ¨ç”»ç»ˆç‚¹
                    particle.style.setProperty('--tx', `${Math.cos(angle) * distance}px`);
                    particle.style.setProperty('--ty', `${Math.sin(angle) * distance}px`);

                    gameOverScreen.appendChild(particle);

                    // åŠ¨ç”»ç»“æŸåç§»é™¤
                    setTimeout(() => {
                        particle.remove();
                    }, duration * 1000);
                }
            }
        // æ˜¾ç¤ºç»Ÿè®¡æ•°æ®
        function displayStats() {
            const stats = `
                <div class="stat-item">
                    <span>æ¸¸æˆæ—¶é•¿:</span>
                    <span>${Math.floor(gameState.gameTime)}ç§’</span>
                </div>
                <div class="stat-item">
                    <span>${player1Name}åˆ†æ•°:</span>
                    <span>${gameState.player1.score}</span>
                </div>
                <div class="stat-item">
                    <span>${player2Name}åˆ†æ•°:</span>
                    <span>${gameState.player2.score}</span>
                </div>
                <div class="stat-item">
                    <span>${player1Name}å‰©ä½™ç”Ÿå‘½:</span>
                    <span>${gameState.player1.hp.toFixed(1)}</span>
                </div>
                <div class="stat-item">
                    <span>${player2Name}å‰©ä½™ç”Ÿå‘½:</span>
                    <span>${gameState.player2.hp.toFixed(1)}</span>
                </div>
                <div class="stat-item">
                    <span>${player1Name}åŸºåœ°ç”Ÿå‘½:</span>
                    <span>${gameState.player1.baseHp.toFixed(1)}</span>
                </div>
                <div class="stat-item">
                    <span>${player2Name}åŸºåœ°ç”Ÿå‘½:</span>
                    <span>${gameState.player2.baseHp.toFixed(1)}</span>
                </div>
            `;

            statsContainer.innerHTML = stats;
        }

        // æ›´æ–°UI
        function updateUI() {
            // æ›´æ–°ç©å®¶1ä¿¡æ¯
            player1HealthElement.textContent = gameState.player1.hp.toFixed(1);
            player1MaxHealthElement.textContent = gameState.player1.maxHp;
            player1HealthBar.style.width = `${(gameState.player1.hp / gameState.player1.maxHp) * 100}%`;
            player1ShieldElement.textContent = gameState.player1.shield;
            player1ScoreElement.textContent = gameState.player1.score;

            // æ›´æ–°ç©å®¶2ä¿¡æ¯
            player2HealthElement.textContent = gameState.player2.hp.toFixed(1);
            player2MaxHealthElement.textContent = gameState.player2.maxHp;
            player2HealthBar.style.width = `${(gameState.player2.hp / gameState.player2.maxHp) * 100}%`;
            player2ShieldElement.textContent = gameState.player2.shield;
            player2ScoreElement.textContent = gameState.player2.score;

            // æ›´æ–°åŸºåœ°è¡€é‡æ˜¾ç¤ºï¼ˆåœ¨UIæ ä¸­ï¼‰
            base1HpElement.textContent = Math.max(0, Math.floor(gameState.player1.baseHp));
            base1HealthBar.style.width = `${(gameState.player1.baseHp / 50) * 100}%`;
            base2HpElement.textContent = Math.max(0, Math.floor(gameState.player2.baseHp));
            base2HealthBar.style.width = `${(gameState.player2.baseHp / 50) * 100}%`;

            // å¦‚æœåŸºåœ°è¢«æ‘§æ¯ï¼Œæ˜¾ç¤ºç‰¹æ®ŠçŠ¶æ€
            if (gameState.player1.baseHp <= 0) {
                base1HpElement.textContent = "å·²æ‘§æ¯";
                base1HealthBar.style.background = '#808080';
            }

            if (gameState.player2.baseHp <= 0) {
                base2HpElement.textContent = "å·²æ‘§æ¯";
                base2HealthBar.style.background = '#808080';
            }

            // æ›´æ–°æ— æ•Œè§†è§‰æ•ˆæœ
            updatePlayerStatusDisplay('player1');
            updatePlayerStatusDisplay('player2');

            // æ›´æ–°é­”æ³•çƒæ˜¾ç¤ºï¼ˆåœ¨çŠ¶æ€æ ä¸­ï¼‰
            updateMagicBallsDisplay('player1');
            updateMagicBallsDisplay('player2');
        }
        // æ›´æ–°é­”æ³•çƒæ˜¾ç¤º
    function updateMagicBallsDisplay(playerKey) {
        const player = gameState[playerKey];
        const ballsElement = document.getElementById(`${playerKey}-balls`);

        if (!ballsElement) return;

        ballsElement.innerHTML = '';

        // ç¡®ä¿ magicBalls å­˜åœ¨
        if (!player.magicBalls) {
            player.magicBalls = [];
        }

        // å®‰å…¨åœ°éå†
        player.magicBalls.forEach((ballType, index) => {
            const ballSlot = document.createElement('div');
            ballSlot.className = `ball-slot ${ballType}`;

            // è®¾ç½®ç¼©å†™
            let abbreviation;
            switch (ballType) {
                case 'invincible': abbreviation = 'æ— '; break;
                case 'health': abbreviation = 'è¡€'; break;
                case 'reverse': abbreviation = 'å'; break;
                case 'attack': abbreviation = 'æ”»'; break;
                case 'bomb': abbreviation = 'çˆ†'; break;
                default: abbreviation = '?';
            }

            ballSlot.textContent = abbreviation;
            ballSlot.title = getBallDescription(ballType);

            // æ·»åŠ ç‚¹å‡»äº‹ä»¶
            ballSlot.style.cursor = 'pointer';
            ballSlot.onclick = () => useMagicBall(playerKey, index);

            ballsElement.appendChild(ballSlot);
        });

        // æ·»åŠ ç©ºæ§½ä½
        const emptySlots = 5 - (player.magicBalls ? player.magicBalls.length : 0);
        for (let i = 0; i < emptySlots; i++) {
            const emptySlot = document.createElement('div');
            emptySlot.className = 'ball-slot';
            emptySlot.textContent = '';
            ballsElement.appendChild(emptySlot);
        }
    }
        // è·å–é­”æ³•çƒæè¿°
        function getBallDescription(ballType) {
            switch (ballType) {
                case 'invincible': return 'æ— æ•Œçƒï¼šä¸€æ®µæ—¶é—´å†…å…ç–«æ‰€æœ‰ä¼¤å®³';
                case 'health': return 'è¡€çƒï¼šæ¢å¤5ç‚¹ç”Ÿå‘½å€¼';
                case 'reverse': return 'åè½¬çƒï¼šä½¿å¯¹æ‰‹æ§åˆ¶åå‘';
                case 'attack': return 'æ”»å‡»çƒï¼šæ¿€æ´»è‡ªåŠ¨æ”»å‡»æ¨¡å¼';
                case 'bomb': return 'ç‚¸å¼¹çƒï¼šè§¦å‘èŒƒå›´çˆ†ç‚¸';
                default: return 'æœªçŸ¥é­”æ³•çƒ';
            }
        }

        function openShop(playerKey) {
            const player = gameState[playerKey];
            const shop = shopState[playerKey];
            const shopOverlay = playerKey === 'player1' ? shop1Overlay : shop2Overlay;

            if (!shopOverlay) {
                console.error(`å•†åº—è¦†ç›–å±‚æœªæ‰¾åˆ°: ${playerKey}`);
                return;
            }

            console.log(`æ‰“å¼€ ${playerKey} çš„å•†åº—`);

            // å…è®¸åŒæ—¶æ‰“å¼€ä¸¤ä¸ªå•†åº—ï¼Œä¸æ£€æŸ¥å…¶ä»–å•†åº—çŠ¶æ€

            // è®°å½•ç©å®¶æ˜¯å¦æ‰‹åŠ¨æš‚åœ
            const wasManuallyPaused = player.paused;

            // æš‚åœç©å®¶ï¼ˆå¦‚æœä¹‹å‰ä¸æ˜¯æ‰‹åŠ¨æš‚åœçš„ï¼‰
            if (!wasManuallyPaused) {
                player.paused = true;
                player.wasPausedForShop = true;
                updatePauseStatus(playerKey);
            } else {
                player.wasManuallyPaused = true;
            }

            // æ›´æ–°å•†åº—çŠ¶æ€
            shop.open = true;
            shop.selectedIndex = 0;

            // æ˜¾ç¤ºå•†åº—
            shopOverlay.style.display = 'flex';

            // æ¸²æŸ“å•†åº—é¡¹ç›®
            renderShopItems(playerKey);

            // æ›´æ–°é€‰ä¸­çš„é¡¹ç›®
            updateShopSelection(playerKey);
        }
        function closeShop(playerKey) {
            const player = gameState[playerKey];
            const shop = shopState[playerKey];
            const shopOverlay = playerKey === 'player1' ? shop1Overlay : shop2Overlay;

            if (!shopOverlay) return;

            console.log(`å…³é—­ ${playerKey} çš„å•†åº—`);

            // éšè—å•†åº—
            shopOverlay.style.display = 'none';
            shop.open = false;

            // å¦‚æœæ˜¯å› ä¸ºå•†åº—æš‚åœçš„ï¼Œä¸”ä¸æ˜¯æ‰‹åŠ¨æš‚åœçš„ï¼Œæ¢å¤æ¸¸æˆ
            if (player.wasPausedForShop && !player.wasManuallyPaused) {
                player.paused = false;
                delete player.wasPausedForShop;
                updatePauseStatus(playerKey);
            }

            // æ¸…é™¤æ‰‹åŠ¨æš‚åœæ ‡è®°
            if (player.wasManuallyPaused) {
                delete player.wasManuallyPaused;
            }
        }
        function renderShopItems(playerKey) {
            const shop = shopState[playerKey];
            const shopId = playerKey === 'player1' ? 'shop1-overlay' : 'shop2-overlay';
            const shopItemsElement = document.querySelector(`#${shopId} .shop-items`);

            if (!shopItemsElement) {
                console.error(`å•†åº—é¡¹ç›®å®¹å™¨æœªæ‰¾åˆ°: #${shopId} .shop-items`);
                return;
            }

            shopItemsElement.innerHTML = '';

            // æ·»åŠ å•†åº—æ ‡é¢˜
            const shopTitle = document.createElement('div');
            shopTitle.className = 'shop-title';
            shopTitle.style.cssText = `
        color: ${playerKey === 'player1' ? '#FF7F00' : '#4169E1'};
        font-size: 1.5rem;
        text-align: center;
        margin-bottom: 20px;
        text-shadow: 0 0 10px currentColor;
    `;
            shopTitle.textContent = `${playerKey === 'player1' ? player1Name : player2Name}å•†åº—`;
            shopItemsElement.appendChild(shopTitle);

            // æ¸²æŸ“å•†åº—é¡¹ç›®
            shop.items.forEach((item, index) => {
                const shopItem = document.createElement('div');
                shopItem.className = 'shop-item';
                shopItem.dataset.item = item.id;
                shopItem.dataset.index = index;

                // æ ¹æ®ç©å®¶è®¾ç½®ä¸åŒé¢œè‰²
                const playerColor = playerKey === 'player1' ? '#FF7F00' : '#4169E1';

                shopItem.innerHTML = `
            <div class="item-name" style="color: ${playerColor}">${item.name}</div>
            <div class="item-desc" style="color: #CCCCCC; font-size: 0.9rem; margin: 5px 0;">${item.desc}</div>
            <div class="item-price" style="color: #87CEEB; font-weight: bold;">ä»·æ ¼: ${item.price}åˆ†</div>
        `;

                shopItemsElement.appendChild(shopItem);
            });

            // æ·»åŠ æ§åˆ¶æç¤º
            const hint = document.createElement('div');
            hint.className = 'shop-hint';
            hint.style.cssText = `
        text-align: center;
        margin-top: 20px;
        color: #AAAAAA;
        font-size: 0.9rem;
        padding: 10px;
        background: rgba(0, 0, 0, 0.5);
        border-radius: 5px;
        border: 1px solid rgba(255, 255, 255, 0.2);
    `;

            if (playerKey === 'player1') {
                hint.innerHTML = `
            <div>æ§åˆ¶: <span style="color: #FFD700">WASD</span> é€‰æ‹©</div>
            <div><span style="color: #00FF00">R</span> è´­ä¹° | <span style="color: #FF4444">E</span> é€€å‡º</div>
        `;
            } else {
                hint.innerHTML = `
            <div>æ§åˆ¶: <span style="color: #FFD700">æ–¹å‘é”®</span> é€‰æ‹©</div>
            <div><span style="color: #00FF00">Enter</span> è´­ä¹° | <span style="color: #FF4444">+</span> é€€å‡º</div>
        `;
            }

            shopItemsElement.appendChild(hint);

            // åˆå§‹é€‰ä¸­ç¬¬ä¸€ä¸ªé¡¹ç›®
            updateShopSelection(playerKey);
        }

        // 7. æ·»åŠ å•†åº—é€‰æ‹©æ›´æ–°å‡½æ•°
        function updateShopSelection(playerKey) {
            const shop = shopState[playerKey];
            const shopId = playerKey === 'player1' ? 'shop1-overlay' : 'shop2-overlay';
            const shopItems = document.querySelectorAll(`#${shopId} .shop-item`);

            console.log(`æ›´æ–°å•†åº—é€‰æ‹©: ${playerKey}, é€‰ä¸­ç´¢å¼•: ${shop.selectedIndex}, æ€»é¡¹ç›®æ•°: ${shopItems.length}`);

            shopItems.forEach((item, index) => {
                if (index === shop.selectedIndex) {
                    item.classList.add('selected');

                    // æ·»åŠ æ»šåŠ¨åˆ°å¯è§åŒºåŸŸ
                    item.scrollIntoView({
                        behavior: 'smooth',
                        block: 'center',
                        inline: 'nearest'
                    });
                } else {
                    item.classList.remove('selected');
                }
            });
        }
        function handleShopControls(playerKey) {
            const shop = shopState[playerKey];
            if (!shop.open) return;

            const items = shop.items;
            let selectionChanged = false;

            // è°ƒè¯•ä¿¡æ¯
            console.log(`Handling shop controls for ${playerKey}`);
            console.log(`Player1 shop open: ${shopState.player1.open}, Player2 shop open: ${shopState.player2.open}`);

            // ç©å®¶1å•†åº—æ§åˆ¶
            if (playerKey === 'player1') {
                console.log(`Player1 keys - w:${gameState.keys['w']}, s:${gameState.keys['s']}, r:${gameState.keys['r']}`);

                if (gameState.keys['w'] || gameState.keys['W']) {
                    console.log("Player1 shop: W pressed");
                    shop.selectedIndex = Math.max(0, shop.selectedIndex - 1);
                    selectionChanged = true;
                    // ä¸æ¸…é™¤æŒ‰é”®çŠ¶æ€ï¼Œè®©updateå‡½æ•°ç»§ç»­å¤„ç†
                }
                if (gameState.keys['s'] || gameState.keys['S']) {
                    console.log("Player1 shop: S pressed");
                    shop.selectedIndex = Math.min(items.length - 1, shop.selectedIndex + 1);
                    selectionChanged = true;
                    // ä¸æ¸…é™¤æŒ‰é”®çŠ¶æ€ï¼Œè®©updateå‡½æ•°ç»§ç»­å¤„ç†
                }
                if (gameState.keys['r'] || gameState.keys['R']) {
                    console.log("Player1 shop: R pressed");
                    // è´­ä¹°é€‰ä¸­çš„ç‰©å“
                    const selectedItem = items[shop.selectedIndex];
                    if (selectedItem) {
                        console.log(`Player1 buying: ${selectedItem.name}`);
                        buyItem(playerKey, selectedItem.id);
                    }
                    // ä¸æ¸…é™¤æŒ‰é”®çŠ¶æ€
                }
            }
            // ç©å®¶2å•†åº—æ§åˆ¶
            else if (playerKey === 'player2') {
                console.log(`Player2 keys - ArrowUp:${gameState.keys['ArrowUp']}, ArrowDown:${gameState.keys['ArrowDown']}, Enter:${gameState.keys['Enter']}`);

                if (gameState.keys['ArrowUp']) {
                    console.log("Player2 shop: ArrowUp pressed");
                    shop.selectedIndex = Math.max(0, shop.selectedIndex - 1);
                    selectionChanged = true;
                    // ä¸æ¸…é™¤æŒ‰é”®çŠ¶æ€
                }
                if (gameState.keys['ArrowDown']) {
                    console.log("Player2 shop: ArrowDown pressed");
                    shop.selectedIndex = Math.min(items.length - 1, shop.selectedIndex + 1);
                    selectionChanged = true;
                    // ä¸æ¸…é™¤æŒ‰é”®çŠ¶æ€
                }
                if (gameState.keys['Enter']) {
                    console.log("Player2 shop: Enter pressed");
                    // è´­ä¹°é€‰ä¸­çš„ç‰©å“
                    const selectedItem = items[shop.selectedIndex];
                    if (selectedItem) {
                        console.log(`Player2 buying: ${selectedItem.name}`);
                        buyItem(playerKey, selectedItem.id);
                    }
                    // ä¸æ¸…é™¤æŒ‰é”®çŠ¶æ€
                }
            }

            if (selectionChanged) {
                console.log(`Shop selection changed for ${playerKey} to index: ${shop.selectedIndex}`);
                updateShopSelection(playerKey);
            }
        }

        // è´­ä¹°ç‰©å“
        function buyItem(playerKey, item) {
            const player = gameState[playerKey];

            switch (item) {
                case 'shield':
                    if (player.score >= 400 && player.shield === 0) {
                        player.score -= 400;
                        player.shield = 10;
                    }
                    break;

                case 'magic-pack':
                    if (player.score >= 400) {
                        player.score -= 400;
                        for (let i = 0; i < 3 && player.magicBalls.length < 5; i++) {
                            const ballTypes = ['invincible', 'health', 'reverse', 'attack', 'bomb'];
                            const type = ballTypes[Math.floor(Math.random() * ballTypes.length)];
                            player.magicBalls.push(type);
                        }
                        updateMagicBallsDisplay(playerKey);
                    }
                    break;

                case 'speed-upgrade':
                    if (player.score >= 500) {
                        player.score -= 500;
                        player.speedMultiplier *= 1.15;
                    }
                    break;

                case 'hard-upgrade':
                    if (player.score >= 500 && player.hardUpgrades < 3) { // å¢åŠ å‡çº§æ¬¡æ•°
                        player.score -= 500;
                        player.hardUpgrades++;
                        // åšç¡¬è›‡å¢åŠ 3ç‚¹ï¼Œå…¶ä»–è›‡å¢åŠ 2ç‚¹
                        const hpIncrease = player.type === 'hard' ? 3 : 2;
                        player.maxHp += hpIncrease;
                        player.hp += hpIncrease;
                    }
                    break;

                case 'magic-upgrade':
                    if (player.score >= 500 && player.magicUpgrades < 2) {
                        player.score -= 500;
                        player.magicUpgrades++;
                    }
                    break;
            }

            // å…³é—­å•†åº—
            closeShop(playerKey);
        }

        // åŠ¨ç”»å¾ªç¯
        function animate() {
            requestAnimationFrame(animate);
            update();
        }
        function togglePlayerPause(playerKey) {
            if (!gameState.running) return;

            const player = gameState[playerKey];

            // å¦‚æœæ˜¯å› ä¸ºå•†åº—æš‚åœçš„ï¼Œä¸èƒ½æ‰‹åŠ¨å–æ¶ˆæš‚åœ
            if (player.wasPausedForShop && player.paused) {
                console.log(`${playerKey} å› å•†åº—æš‚åœï¼Œä¸èƒ½æ‰‹åŠ¨å–æ¶ˆæš‚åœ`);
                return;
            }

            player.paused = !player.paused;

            console.log(`${playerKey} ${player.paused ? 'æš‚åœ' : 'ç»§ç»­'}`);

            if (player.paused) {
                player.wasManuallyPaused = true;
            } else {
                delete player.wasManuallyPaused;
                delete player.wasPausedForShop; // æ¸…é™¤å•†åº—æš‚åœæ ‡è®°
            }

            updatePauseStatus(playerKey);
        }

        // æ›´æ–°æš‚åœçŠ¶æ€æ˜¾ç¤º
        function updatePauseStatus(playerKey) {
            const player = gameState[playerKey];

            if (player.paused) {
                // åœ¨è›‡ä¸Šæ–¹æ˜¾ç¤ºæš‚åœå›¾æ ‡
                showPauseIndicator(playerKey);
            }
            else {
                // ç§»é™¤æš‚åœå›¾æ ‡
                removePauseIndicator(playerKey);
            }
        }

        // æ˜¾ç¤ºæš‚åœæŒ‡ç¤ºå™¨
        function showPauseIndicator(playerKey) {
            const player = gameState[playerKey];

            // åˆ›å»ºæš‚åœå›¾æ ‡
            const pauseGeometry = new THREE.BoxGeometry(3, 3, 0.5);
            const pauseMaterial = new THREE.MeshBasicMaterial({
                color: 0xFF0000,
                transparent: true,
                opacity: 0.7
            });
            const pauseIndicator = new THREE.Mesh(pauseGeometry, pauseMaterial);

            // æ”¾åœ¨è›‡ä¸Šæ–¹
            pauseIndicator.position.set(
                player.position.x,
                player.position.y + 5,
                player.position.z
            );
            pauseIndicator.userData = { type: 'pauseIndicator', player: playerKey };

            gameState.scene.add(pauseIndicator);
            player.pauseIndicator = pauseIndicator;
        }

        // ç§»é™¤æš‚åœæŒ‡ç¤ºå™¨
        function removePauseIndicator(playerKey) {
            const player = gameState[playerKey];
            if (player.pauseIndicator) {
                gameState.scene.remove(player.pauseIndicator);
                player.pauseIndicator = null;
            }
        }

        // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰ç©å®¶éƒ½æš‚åœäº†
        function checkAllPlayersPaused() {
            const player1Paused = gameState.player1.paused;
            const player2Paused = gameState.player2.paused;

            // å¦‚æœä¸¤ä¸ªç©å®¶éƒ½æš‚åœäº†ï¼Œæ•´ä½“æ¸¸æˆæš‚åœ
            gameState.paused = player1Paused && player2Paused;

            if (gameState.paused) {
                // æ˜¾ç¤ºæ•´ä½“æš‚åœæç¤º
            } else {
            }
        }
        // äº‹ä»¶å¤„ç†
        document.addEventListener('keydown', (e) => {
            const relevantKeys = [
                'w', 'W', 'a', 'A', 's', 'S', 'd', 'D',
                'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight',
                'e', 'E', '+', 'r', 'R', 'Enter',
                '1', '2', '3', '4', '5', '6', '7', '8', '9', '0',
                ' ', 'q', 'Q', '/', '?',
                'Numpad6', 'Numpad7', 'Numpad8', 'Numpad9', 'Numpad0'
            ];

            if (!relevantKeys.includes(e.key)) return;

            gameState.keys[e.key] = true;

            // é˜²æ­¢æ–¹å‘é”®æ»šåŠ¨é¡µé¢
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'w', 'W', 'a', 'A', 's', 'S', 'd', 'D', ' '].includes(e.key)) {
                e.preventDefault();
            }

            // === 1. æ°¸è¿œå¯ç”¨çš„åŠŸèƒ½ï¼šæš‚åœé”®å’Œé­”æ³•çƒ ===

            // ç©å®¶1æš‚åœ/ç»§ç»­ï¼šQ é”®
            if ((e.key === 'q' || e.key === 'Q') && gameState.running) {
                // æ£€æŸ¥ç©å®¶1æ˜¯å¦å› ä¸ºå•†åº—æš‚åœ
                if (!gameState.player1.wasPausedForShop) {
                    togglePlayerPause('player1');
                }
                e.preventDefault();
                return; // å¤„ç†å®Œæš‚åœï¼Œç›´æ¥è¿”å›
            }

            // ç©å®¶2æš‚åœ/ç»§ç»­ï¼š/ æˆ– ? é”®
            if ((e.key === '/' || e.key === '?') && gameState.running) {
                // æ£€æŸ¥ç©å®¶2æ˜¯å¦å› ä¸ºå•†åº—æš‚åœ
                if (!gameState.player2.wasPausedForShop) {
                    togglePlayerPause('player2');
                }
                e.preventDefault();
                return; // å¤„ç†å®Œæš‚åœï¼Œç›´æ¥è¿”å›
            }

            // é­”æ³•çƒä½¿ç”¨ï¼ˆæ°¸è¿œå¯ç”¨ï¼Œæ— è®ºå•†åº—æ˜¯å¦æ‰“å¼€ï¼‰
            if (gameState.running) {
                // ç©å®¶1é­”æ³•çƒï¼ˆæ•°å­—é”®1-5ï¼‰
                if (e.key >= '1' && e.key <= '5') {
                    const index = parseInt(e.key) - 1;
                    useMagicBall('player1', index);
                    e.preventDefault();
                    return; // å¤„ç†å®Œé­”æ³•çƒï¼Œç›´æ¥è¿”å›
                }

                // ç©å®¶2é­”æ³•çƒï¼ˆæ•°å­—é”®6-0æˆ–å°é”®ç›˜ï¼‰
                if (e.key === '6' || e.key === 'Numpad6') {
                    useMagicBall('player2', 0);
                    e.preventDefault();
                    return;
                } else if (e.key === '7' || e.key === 'Numpad7') {
                    useMagicBall('player2', 1);
                    e.preventDefault();
                    return;
                } else if (e.key === '8' || e.key === 'Numpad8') {
                    useMagicBall('player2', 2);
                    e.preventDefault();
                    return;
                } else if (e.key === '9' || e.key === 'Numpad9') {
                    useMagicBall('player2', 3);
                    e.preventDefault();
                    return;
                } else if (e.key === '0' || e.key === 'Numpad0') {
                    useMagicBall('player2', 4);
                    e.preventDefault();
                    return;
                }
            }

            // === 2. å•†åº—ç›¸å…³åŠŸèƒ½ ===

            // ç©å®¶1å•†åº—å¼€å…³ï¼šEé”®
            if ((e.key === 'e' || e.key === 'E') && gameState.running) {
                e.preventDefault();
                if (shopState.player1.open) {
                    closeShop('player1');
                } else {
                    openShop('player1');
                }
                return; // å¤„ç†å®Œå•†åº—å¼€å…³ï¼Œç›´æ¥è¿”å›
            }

            // ç©å®¶2å•†åº—å¼€å…³ï¼š+é”®
            if (e.key === '+' && gameState.running) {
                e.preventDefault();
                if (shopState.player2.open) {
                    closeShop('player2');
                } else {
                    openShop('player2');
                }
                return; // å¤„ç†å®Œå•†åº—å¼€å…³ï¼Œç›´æ¥è¿”å›
            }

            // ç©å®¶1å•†åº—é€‰æ‹©
            if (shopState.player1.open) {
                e.preventDefault();

                if (e.key === 'w' || e.key === 'W') {
                    console.log("Player1 shop: W pressed (direct)");
                    const shop = shopState.player1;
                    shop.selectedIndex = Math.max(0, shop.selectedIndex - 1);
                    updateShopSelection('player1');
                    return; // å¤„ç†å®Œå•†åº—é€‰æ‹©ï¼Œç›´æ¥è¿”å›
                } else if (e.key === 's' || e.key === 'S') {
                    console.log("Player1 shop: S pressed (direct)");
                    const shop = shopState.player1;
                    shop.selectedIndex = Math.min(shop.items.length - 1, shop.selectedIndex + 1);
                    updateShopSelection('player1');
                    return; // å¤„ç†å®Œå•†åº—é€‰æ‹©ï¼Œç›´æ¥è¿”å›
                } else if (e.key === 'r' || e.key === 'R') {
                    console.log("Player1 shop: R pressed (direct)");
                    const shop = shopState.player1;
                    const selectedItem = shop.items[shop.selectedIndex];
                    if (selectedItem) {
                        console.log(`Player1 buying: ${selectedItem.name}`);
                        buyItem('player1', selectedItem.id);
                    }
                    return; // å¤„ç†å®Œè´­ä¹°ï¼Œç›´æ¥è¿”å›
                }
            }

            // ç©å®¶2å•†åº—é€‰æ‹©
            if (shopState.player2.open) {
                e.preventDefault();

                if (e.key === 'ArrowUp') {
                    console.log("Player2 shop: ArrowUp pressed (direct)");
                    const shop = shopState.player2;
                    shop.selectedIndex = Math.max(0, shop.selectedIndex - 1);
                    updateShopSelection('player2');
                    return; // å¤„ç†å®Œå•†åº—é€‰æ‹©ï¼Œç›´æ¥è¿”å›
                } else if (e.key === 'ArrowDown') {
                    console.log("Player2 shop: ArrowDown pressed (direct)");
                    const shop = shopState.player2;
                    shop.selectedIndex = Math.min(shop.items.length - 1, shop.selectedIndex + 1);
                    updateShopSelection('player2');
                    return; // å¤„ç†å®Œå•†åº—é€‰æ‹©ï¼Œç›´æ¥è¿”å›
                } else if (e.key === 'Enter') {
                    console.log("Player2 shop: Enter pressed (direct)");
                    const shop = shopState.player2;
                    const selectedItem = shop.items[shop.selectedIndex];
                    if (selectedItem) {
                        console.log(`Player2 buying: ${selectedItem.name}`);
                        buyItem('player2', selectedItem.id);
                    }
                    return; // å¤„ç†å®Œè´­ä¹°ï¼Œç›´æ¥è¿”å›
                }
            }

            // === 3. å…¶ä»–æ¸¸æˆæ§åˆ¶ï¼ˆåªåœ¨æ²¡æœ‰å•†åº—æ‰“å¼€æ—¶ï¼‰===
            if (!shopState.player1.open && !shopState.player2.open) {
                // é€Ÿåº¦è›‡ä¿¯å†²
                if (e.key === ' ') {
                    checkSpeedSnakeDash('player1');
                    e.preventDefault();
                }
            }
        });
        document.addEventListener('keyup', (e) => {
            const relevantKeys = [
                'w', 'W', 'a', 'A', 's', 'S', 'd', 'D',
                'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight',
                'e', 'E', '+', 'r', 'R', 'Enter',
                '1', '2', '3', '4', '5', '6', '7', '8', '9', '0',
                ' ', 'q', 'Q', '/', '?',
                'Numpad6', 'Numpad7', 'Numpad8', 'Numpad9', 'Numpad0'
            ];

            if (relevantKeys.includes(e.key)) {
                gameState.keys[e.key] = false;
            }
        });

        document.addEventListener('keyup', (e) => {
            gameState.keys[e.key] = false;
        });

        window.addEventListener('resize', () => {
            const width = window.innerWidth;
            const height = window.innerHeight;

            // æ›´æ–°ç©å®¶1ç›¸æœºå’Œæ¸²æŸ“å™¨
            gameState.player1.camera.aspect = (width / 2) / height;
            gameState.player1.camera.updateProjectionMatrix();
            gameState.player1.renderer.setSize(width / 2, height);

            // æ›´æ–°ç©å®¶2ç›¸æœºå’Œæ¸²æŸ“å™¨
            gameState.player2.camera.aspect = (width / 2) / height;
            gameState.player2.camera.updateProjectionMatrix();
            gameState.player2.renderer.setSize(width / 2, height);
        });

        startButton.addEventListener('click', () => {
            if (!gameState.running) {
                gameState.running = true;
                startButton.textContent = 'æ¸¸æˆä¸­';
                startButton.disabled = true;
                clock.start();
            }
        });

        resetButton.addEventListener('click', () => {
            initGame();
        });

        mapButton.addEventListener('click', () => {
            const maps = ['classic', 'snow', 'volcano'];
            const currentIndex = maps.indexOf(gameState.mapType);
            gameState.mapType = maps[(currentIndex + 1) % maps.length];
            mapButton.textContent = `åœ°å›¾: ${gameState.mapType === 'classic' ? 'ç»å…¸' :
                gameState.mapType === 'snow' ? 'é›ªå±±' : 'ç«å±±'}`;
            initGame();
        });

        playAgainButton.addEventListener('click', () => {
            initGame();
            gameState.running = true;
            startButton.textContent = 'æ¸¸æˆä¸­';
            startButton.disabled = true;
            clock.start();
        });

        // åŠ è½½Three.jså¹¶åˆå§‹åŒ–
    function loadThreeJS() {
        if (typeof THREE === 'undefined') {
            const script = document.createElement('script');
            script.src = 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js';
            script.onload = function () {
                initScene();
                // å»¶è¿Ÿæ˜¾ç¤ºä¸»é¡µåŠ¨ç”»
                setTimeout(playHomepageAnimation, 500);
            };
            document.head.appendChild(script);
        } else {
            initScene();
            // å»¶è¿Ÿæ˜¾ç¤ºä¸»é¡µåŠ¨ç”»
            setTimeout(playHomepageAnimation, 500);
        }
    }

        // åˆå§‹åŒ–é­”æ³•çƒæ˜¾ç¤º
        setTimeout(() => {
            updateMagicBallsDisplay('player1');
            updateMagicBallsDisplay('player2');
        }, 100);

        loadThreeJS();
function loginPlayer2() {
        document.getElementById('confirm-start-btn').style.display = 'none';
    swal({
        title: "ç©å®¶2ç™»å½•",
        text: "è¯·è¾“å…¥ç”¨æˆ·åå’Œå¯†ç ",
        type: "input",
        inputType: "text",
        inputPlaceholder: "è¯·è¾“å…¥ç”¨æˆ·å",
        showCancelButton: true,
        cancelButtonText: "å–æ¶ˆ",
        confirmButtonText: "ä¸‹ä¸€æ­¥",
        closeOnConfirm: false
    }, function(username) {
        if (username === false) return false;
        if (!username) {
            swal.showInputError("è¯·è¾“å…¥ç”¨æˆ·å");
            return false;
        }
        
        // æ£€æŸ¥æ˜¯å¦ä¸ç©å®¶1ç”¨æˆ·åç›¸åŒ
        const player1Username = localStorage.getItem('username');
        if (player1Username && username === player1Username) {
            swal.showInputError("ç”¨æˆ·åä¸èƒ½ä¸ç©å®¶1ç›¸åŒ");
            return false;
        }
        
        // ç¬¬äºŒæ­¥ï¼šè¯¢é—®å¯†ç 
        swal({
            title: "ç©å®¶2ç™»å½•",
            text: "è¯·è¾“å…¥å¯†ç ",
            type: "input",
            inputType: "password",
            inputPlaceholder: "è¯·è¾“å…¥å¯†ç ",
            showCancelButton: true,
            cancelButtonText: "ä¸Šä¸€æ­¥",
            confirmButtonText: "ç™»å½•",
            closeOnConfirm: false
        }, function(password) {
            if (password === false) {
                // ç‚¹å‡»å–æ¶ˆè¿”å›ä¸Šä¸€æ­¥
                loginPlayer2();
                return false;
            }
            if (!password) {
                swal.showInputError("è¯·è¾“å…¥å¯†ç ");
                return false;
            }
            
            // å‘é€ç™»å½•è¯·æ±‚
            fetch(`${serverurl}/login`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    username: username,
                    password: password
                })
            })
            .then(response => response.text())
            .then(data => {
                if (data.includes('<h1>ç™»å½•æˆåŠŸ</h1>')) {
                    localStorage.setItem('player2_username', username);
                    fetch(`${serverurl}/get-user-id-by-username`, {
                                method: 'POST', // æŒ‡å®šè¯·æ±‚æ–¹æ³•
                                headers: {
                                    'Content-Type': 'application/json' // è®¾ç½®è¯·æ±‚å¤´
                                },
                                body: JSON.stringify({ username: username }) // è¯·æ±‚ä½“
                            })
                                .then(response => {
                                    if (!response.ok) {
                                        throw new Error('Network response was not ok');
                                    }
                                    return response.json(); // è§£æJSONæ•°æ®
                                })
                                .then(data => {
                                    // å¤„ç†è¿”å›çš„æ•°æ®
                                    if (data.success) {
                                        // å‡è®¾data.dataä¸­åŒ…å«userId
                                        const userId = data.data.userId;
                                        localStorage.setItem("player2_userid",userId);
                                        document.getElementById('player1-panel-name').textContent = player1Name;
                                        document.getElementById('player2-panel-name').textContent = player2Name;
                                        document.getElementById('player1-selection-title').textContent = player1Name + 'é€‰æ‹©è›‡ç±»å‹';
                                        player1Name = localStorage.getItem('username') || 'ç©å®¶1';
                                        player2Name = localStorage.getItem('player2_username') || 'ç©å®¶2';
                                        document.getElementById('player2-selection-title').textContent = player2Name + 'é€‰æ‹©è›‡ç±»å‹';
                                        document.getElementById('player2-base-name').textContent = player2Name + 'åŸºåœ°';
                                        document.getElementById('player2-panel-name').textContent = player2Name;
                                        document.getElementById('confirm-start-btn').style.display = 'block';
                                        swal("ç™»å½•æˆåŠŸ", "ç©å®¶2å·²ç™»å½•", "success");
                                    } else {
                                        // æ˜¾ç¤ºé”™è¯¯ä¿¡æ¯
                                        console.log(data.message);
                                    }
                                })
                                .catch(error => {
                                    // å¤„ç†è¯·æ±‚è¿‡ç¨‹ä¸­çš„é”™è¯¯
                                    console.error('Fetch error:', error);
                                });
                } else if (data.includes('ç™»å½•å¤±è´¥')) {
                    swal("ç™»å½•å¤±è´¥", 'ç”¨æˆ·åæˆ–å¯†ç é”™è¯¯', 'error');
                    document.getElementById('confirm-start-btn').style.display = "none";
                }
            })
            .catch(error => {
                console.error(error);
                swal("è¯·æ±‚å¤±è´¥", "è¯·ç¨åé‡è¯•", "error");
            });
        });
    });
}      
            async function getServerRecords() {
                try {
                    const userId = localStorage.getItem("userid");
                    const player2UserId = localStorage.getItem("player2_userid");
                    const currentUsername = localStorage.getItem("username");
                    const player2Username = localStorage.getItem("player2_username");

                    if (!userId || !player2UserId || !currentUsername || !player2Username) {
                        return null;
                    }

                    // è·å–å½“å‰ç”¨æˆ·çš„è®°å½•
                    const currentUserData = await getUserCustomData(userId);
                    const player2Data = await getUserCustomData(player2UserId);

                    let player1Wins = 0;
                    let player2Wins = 0;

                    // ä»å½“å‰ç”¨æˆ·æ•°æ®ä¸­è§£æ
                    if (currentUserData) {
                        const records = currentUserData.split(';');
                        for (const record of records) {
                            if (record.startsWith(`snakegame_record3D_with_${player2Username}`)) {
                                const parts = record.split(':')[1].split(',');
                                player1Wins += parseInt(parts[0]) || 0;
                                player2Wins += parseInt(parts[1]) || 0;
                            }
                        }
                    }
                    return {
                        player1Wins,
                        player2Wins
                    };
                } catch (error) {
                    console.error('è·å–æœåŠ¡å™¨è®°å½•å¤±è´¥:', error);
                    return null;
                }
            }

            // ä¸Šä¼ æ¸¸æˆè®°å½•
            let hasUploaded = false;
            async function uploadGameRecord(player1Wins, player2Wins) {
                if (hasUploaded) {
                    throw new Error('æˆ˜ç»©å·²ä¿å­˜ï¼Œè¯·å‹¿é‡å¤æäº¤');
                }

                try {
                    const userId = localStorage.getItem("userid");
                    const player2UserId = localStorage.getItem("player2_userid");
                    const currentUsername = localStorage.getItem("username");
                    const player2Username = localStorage.getItem("player2_username");

                    if (!userId || !player2UserId || !currentUsername || !player2Username) {
                        throw new Error('ç”¨æˆ·ä¿¡æ¯ä¸å®Œæ•´');
                    }

                    // å‡†å¤‡ä¸Šä¼ çš„æ•°æ®
                    const recordForCurrentUser = `snakegame_record3D_with_${player2Username}:${player1Wins},${player2Wins}`;
                    const recordForPlayer2 = `snakegame_record3D_with_${currentUsername}:${player2Wins},${player1Wins}`;

                    // è·å–å½“å‰ç”¨æˆ·çš„ç°æœ‰æ•°æ®
                    const currentUserData = await getUserCustomData(userId);
                    const player2Data = await getUserCustomData(player2UserId);

                    // æ›´æ–°æ•°æ®
                    const updatedCurrentUserData = updateRecord(currentUserData, recordForCurrentUser);
                    const updatedPlayer2Data = updateRecord(player2Data, recordForPlayer2);

                    // ä¸Šä¼ æ›´æ–°åçš„æ•°æ®
                    await Promise.all([
                        updateUserCustomData(userId, updatedCurrentUserData),
                        updateUserCustomData(player2UserId, updatedPlayer2Data)
                    ]);

                    hasUploaded = true;
                    return true;
                } catch (error) {
                    console.error('ä¸Šä¼ æˆ˜ç»©å¤±è´¥:', error);
                    throw error;
                }
            }

            // è·å–ç”¨æˆ·è‡ªå®šä¹‰æ•°æ®
            async function getUserCustomData(userId) {
                try {
                    const response = await fetch(`${serverurl}/get-custom-data-by-id`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            userId: userId
                        })
                    });

                    const data = await response.json();
                    if (data.success) {
                        return data.data.customData || '';
                    }
                    throw new Error(data.message || 'è·å–ç”¨æˆ·æ•°æ®å¤±è´¥');
                } catch (error) {
                    console.error('è·å–ç”¨æˆ·æ•°æ®å¤±è´¥:', error);
                    throw error;
                }
            }

            // æ›´æ–°è®°å½•
            function updateRecord(currentData, newRecord) {
                if (!currentData) return newRecord;

                const recordKey = newRecord.split(':')[0];
                const records = currentData.split(';');
                let found = false;

                const updatedRecords = records.map(record => {
                    if (record.startsWith(recordKey)) {
                        found = true;
                        const [oldP1Wins, oldP2Wins] = record.split(':')[1].split(',').map(Number);
                        const [newP1Wins, newP2Wins] = newRecord.split(':')[1].split(',').map(Number);
                        return `${recordKey}:${oldP1Wins + newP1Wins},${oldP2Wins + newP2Wins}`;
                    }
                    return record;
                });

                if (!found) {
                    updatedRecords.push(newRecord);
                }

                return updatedRecords.filter(r => r).join(';');
            }

            // æ›´æ–°ç”¨æˆ·è‡ªå®šä¹‰æ•°æ®
            async function updateUserCustomData(userId, customData) {
                try {
                    const response = await fetch(`${serverurl}/update-custom-data`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            userId: userId,
                            customData: customData
                        })
                    });

                    const data = await response.json();
                    if (!data.success) {
                        throw new Error(data.message || 'æ›´æ–°æ•°æ®å¤±è´¥');
                    }
                } catch (error) {
                    console.error('æ›´æ–°ç”¨æˆ·æ•°æ®å¤±è´¥:', error);
                    throw error;
                }
            }

            // æ˜¾ç¤ºæ‰€æœ‰æˆ˜ç»©è®°å½•
            async function showAllRecords() {
                try {
                    const modal = document.getElementById('records-modal');
                    const container = document.getElementById('records-container');

                    // æ˜¾ç¤ºåŠ è½½ä¸­
                    container.innerHTML = '<div class="loading">åŠ è½½ä¸­...</div>';
                    modal.style.display = 'block';

                    // è·å–æ‰€æœ‰ç”¨æˆ·æ•°æ®
                    const response = await fetch(`${serverurl}/get-all-custom-data`);
                    const data = await response.json();

                    if (!data.success) {
                        throw new Error('è·å–æ•°æ®å¤±è´¥');
                    }

                    // å¤„ç†å¹¶æ˜¾ç¤ºæ•°æ®
                    displayRecords(data.data);

                    // æ·»åŠ æœç´¢åŠŸèƒ½
                    document.getElementById('search-username').addEventListener('input', (e) => {
                        filterRecords(e.target.value, data.data);
                    });

                    // åˆ·æ–°æŒ‰é’®
                    document.getElementById('refresh-records').addEventListener('click', showAllRecords);

                } catch (error) {
                    console.error('è·å–æˆ˜ç»©å¤±è´¥:', error);
                    document.getElementById('records-container').innerHTML =
                        `<div class="error">è·å–æˆ˜ç»©å¤±è´¥: ${error.message}</div>`;
                }
            }

            // æ˜¾ç¤ºæˆ˜ç»©è®°å½•
            function displayRecords(users) {
                const container = document.getElementById('records-container');
                container.innerHTML = '';

                if (!users || users.length === 0) {
                    container.innerHTML = '<div class="no-data">æš‚æ— æˆ˜ç»©æ•°æ®</div>';
                    return;
                }

                // å¤„ç†æ¯ä¸ªç”¨æˆ·çš„è®°å½•
                users.forEach(user => {
                    if (!user.customData) return;

                    // è§£æå¯¹æˆ˜è®°å½•
                    const records = parseRecords(user.customData);
                    if (records.length === 0) return;

                    // è®¡ç®—æ€»èƒœç‡
                    const stats = calculateStats(records);

                    // åˆ›å»ºè®°å½•å…ƒç´ 
                    const recordElement = document.createElement('div');
                    recordElement.className = 'record-item';
                    recordElement.innerHTML = `
                    <div class="record-details">
                        <div class="record-username">${user.username}</div>
                        <div class="record-stats">
                            <div class="record-stat">æ€»åœºæ¬¡: ${stats.totalMatches}</div>
                            <div class="record-stat">æ€»èƒœåœº: ${stats.totalWins}</div>
                            <div class="record-stat">èƒœç‡: ${stats.winRate}%</div>
                        </div>
                        ${records.map(record => `
                            <div class="record-match">
                                <div class="record-match-opponent">
                                    <span>å¯¹æˆ˜ ${record.opponentName}</span>
                                </div>
                                <div>æˆ˜ç»©: ${record.wins}èƒœ ${record.losses}è´Ÿ</div>
                                <div>èƒœç‡: ${record.winRate}%</div>
                            </div>
                        `).join('')}
                    </div>
                `;

                    container.appendChild(recordElement);
                });
            }

            // è¿‡æ»¤è®°å½•
            function filterRecords(searchTerm, allUsers) {
                const filteredUsers = allUsers.filter(user => {
                    // æ£€æŸ¥ç”¨æˆ·åæ˜¯å¦åŒ¹é…
                    if (user.username.toLowerCase().includes(searchTerm.toLowerCase())) {
                        return true;
                    }

                    // æ£€æŸ¥å¯¹æˆ˜è®°å½•ä¸­æ˜¯å¦åŒ…å«æœç´¢è¯
                    if (user.customData && user.customData.toLowerCase().includes(searchTerm.toLowerCase())) {
                        return true;
                    }

                    return false;
                });

                displayRecords(filteredUsers);
            }

            // è§£æè®°å½•æ•°æ®
            function parseRecords(customData) {
                if (!customData) return [];

                const records = [];
                const recordStrings = customData.split(';');

                recordStrings.forEach(str => {
                    if (!str.startsWith('snakegame_record3D_with_')) return;

                    const parts = str.split(':');
                    if (parts.length !== 2) return;

                    const opponentName = parts[0].replace('snakegame_record3D_with_', '');
                    const [wins, losses] = parts[1].split(',').map(Number);

                    if (isNaN(wins) || isNaN(losses)) return;

                    const total = wins + losses;
                    const winRate = total > 0 ? Math.round((wins / total) * 100) : 0;

                    records.push({
                        opponentName,
                        wins,
                        losses,
                        winRate,
                        opponentAvatar: `${serverurl}/get-icon-by-id?username=${encodeURIComponent(opponentName)}`
                    });
                });

                return records;
            }

            // è®¡ç®—ç»Ÿè®¡æ•°æ®
            function calculateStats(records) {
                let totalWins = 0;
                let totalLosses = 0;

                records.forEach(record => {
                    totalWins += record.wins;
                    totalLosses += record.losses;
                });

                const totalMatches = totalWins + totalLosses;
                const winRate = totalMatches > 0 ? Math.round((totalWins / totalMatches) * 100) : 0;

                return {
                    totalMatches,
                    totalWins,
                    totalLosses,
                    winRate
                };
            }

            // å…³é—­æ¨¡æ€æ¡†
            document.querySelectorAll('.close-modal').forEach(btn => {
                btn.addEventListener('click', function () {
                    const modalId = this.getAttribute('data-modal') || 'records-modal';
                    document.getElementById(modalId).style.display = 'none';
                });
            });

            // ç‚¹å‡»å¤–éƒ¨å…³é—­
            window.addEventListener('click', function (event) {
                const modals = ['records-modal'];
                modals.forEach(modalId => {
                    const modal = document.getElementById(modalId);
                    if (event.target === modal) {
                        modal.style.display = 'none';
                    }
                });
            });  
    </script>
</body>

</html>